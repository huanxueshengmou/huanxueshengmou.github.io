<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>幻雪的博客</title>
  
  <subtitle>鱼跃此时，花开彼岸。</subtitle>
  <link href="https://huanxueblog.top/atom.xml" rel="self"/>
  
  <link href="https://huanxueblog.top/"/>
  <updated>2024-11-24T09:55:39.864Z</updated>
  <id>https://huanxueblog.top/</id>
  
  <author>
    <name>幻雪</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>喂饭级，通过内网穿透自动拉取git仓库代码</title>
    <link href="https://huanxueblog.top/posts/309fd10a.html"/>
    <id>https://huanxueblog.top/posts/309fd10a.html</id>
    <published>2024-11-24T06:25:46.000Z</published>
    <updated>2024-11-24T09:55:39.864Z</updated>
    
    <content type="html"><![CDATA[<div class="tabs" id="uniquename1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename1-1"><i class="icon"></i>思路</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename1-1"><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>通过 github 的 webhook 来通知本地拉取代码<br>本地通过 ngrok 开放端口，并且设置一个服务器对该端口进行监听<br>在监听服务器当中设置下拉操作和对非 github webhook 的操作进行过滤处理</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div class="tabs" id="uniquename2"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename2-1"><i class="icon"></i>有什么用</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename2-1"><h3 id="有什么用"><a href="#有什么用" class="headerlink" title="有什么用"></a>有什么用</h3><p>因为大部分人是没有公网 ip 的，更多是本地电脑的操作代码，所以好处在于，只要设置好 hook，那么团队的操作将不需要自己 pull (如果不喜欢 pull 自己改)，自动同步代码。</p><p>如果是服务器，那么省略掉 ngrok，直接监听端口，可以完成持续性集成的操作</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div class="tabs" id="uniquename3"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename3-1"><i class="icon"></i>注册一个 ngrok</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename3-1"><h3 id="注册一个-ngrok"><a href="#注册一个-ngrok" class="headerlink" title="注册一个 ngrok"></a>注册一个 ngrok</h3><p>去官网注册一个账号 <a href="https://ngrok.com/">https://ngrok.com/</a><br>这里 qq 的邮箱是不可以的，如果有谷歌的账号就直接注册跳到如何使用 ngrok</p><p>如果没有谷歌账号那么看下一步<br>去注册这个邮箱 <a href="https://app.tuta.com">https://app.tuta.com</a><br><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/20241124150811.png" alt=""><br>然后再去注册，回到邮箱收到如下<br><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/20241124151130.png" alt=""><br>把 https 的部分复制出来访问即可激活 ngrok</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div class="tabs" id="uniquename4"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename4-1"><i class="icon"></i>如何使用 ngrok</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename4-1"><h3 id="如何使用-ngrok"><a href="#如何使用-ngrok" class="headerlink" title="如何使用 ngrok"></a>如何使用 ngrok</h3><p><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/20241124151331.png" alt=""><br>这样就是注册成功了，然后我们点击跳过，到 win 的下载页面（mac 选 mac，linux 选 linux）<br><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/20241124151506.png" alt=""><br>下载好选一个地方解压，这个地方日后作为你启动该内网穿透的地方<br>解压完后会出现一个可执行文件<br><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/20241124151813.png" alt=""><br>在地址栏输入 cmd<br>然后把刚刚的<br><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/20241124152017.png" alt=""><br>粘贴到 cmd 当中执行</p><p>出现如图就是成功了，并且以后你可以修改其中的值<br>![[Pasted image 20241124152109.png]]<br>值参考官网 <a href="https://ngrok.com/docs/agent/config/">https://ngrok.com/docs/agent/config/</a><br>不过默认不需要修改</p><p>再执行 <code>ngrok http 8080</code><br>出现如下就是可以了，蓝色箭头的是提供给外部访问的地址<br><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/20241124152403.png" alt=""></p><p>自行在其他手机端或者其他端测试该地址是否可以访问</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div class="tabs" id="uniquename5"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename5-1"><i class="icon"></i>配合 github 钩子</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename5-1"><h3 id="配合-github-钩子"><a href="#配合-github-钩子" class="headerlink" title="配合 github 钩子"></a>配合 github 钩子</h3><p>Server 监听端口，内网穿透修改对应端口，即可在外部访问</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div class="tabs" id="uniquename6"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename6-1"><i class="icon"></i>Server 端代码</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename6-1"><h3 id="Server-端代码"><a href="#Server-端代码" class="headerlink" title="Server 端代码"></a>Server 端代码</h3><p>依赖express 和 node<br>安装 node <a href="https://nodejs.org/en/download/package-manager">https://nodejs.org/en/download/package-manager</a><br>安装 <code>npm install express</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入必要的模块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; exec &#125; = <span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置服务器端口号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">PORT</span> = <span class="number">3000</span>;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于解析 application/json 和 application/x-www-form-urlencoded 数据</span></span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">json</span>());</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">urlencoded</span>(&#123; <span class="attr">extended</span>: <span class="literal">true</span> &#125;));</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment">// GitHub Webhook 处理路由</span></span><br><span class="line"></span><br><span class="line">app.<span class="title function_">post</span>(<span class="string">&#x27;/webhook&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取请求头中的 GitHub 事件类型</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> githubEvent = req.<span class="title function_">header</span>(<span class="string">&#x27;X-GitHub-Event&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> githubDelivery = req.<span class="title function_">header</span>(<span class="string">&#x27;X-GitHub-Delivery&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 确认这是一个 ping 或 push 事件</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (githubEvent === <span class="string">&#x27;ping&#x27;</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;收到 GitHub 的 ping 事件&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    res.<span class="title function_">status</span>(<span class="number">200</span>).<span class="title function_">send</span>(<span class="string">&#x27;Pong!&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Postman 检查：ping 事件处理成功！&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (githubEvent === <span class="string">&#x27;push&#x27;</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`收到推送事件: Delivery ID - <span class="subst">$&#123;githubDelivery&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 git 命令拉取最新代码(要修改目录)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> gitPullCommand = <span class="string">&#x27;cd &quot;D:/Users/27599/Desktop/gitea/基于github的action测试&quot; &amp;&amp; git pull&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="title function_">exec</span>(gitPullCommand, <span class="function">(<span class="params">error, stdout, stderr</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (error) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">`拉取代码时出现错误: <span class="subst">$&#123;error.message&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res.<span class="title function_">status</span>(<span class="number">500</span>).<span class="title function_">send</span>(<span class="string">&#x27;Error pulling code from GitHub repository&#x27;</span>);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (stderr) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">`错误输出: <span class="subst">$&#123;stderr&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`拉取代码的输出: <span class="subst">$&#123;stdout&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">      res.<span class="title function_">status</span>(<span class="number">200</span>).<span class="title function_">send</span>(<span class="string">&#x27;Code pulled successfully from GitHub repository&#x27;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Postman 检查：push 事件处理成功，代码已成功拉取！&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`未知事件类型: <span class="subst">$&#123;githubEvent&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">    res.<span class="title function_">status</span>(<span class="number">400</span>).<span class="title function_">send</span>(<span class="string">&#x27;Unknown event type&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Postman 检查：收到未知的 GitHub 事件类型。&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听指定端口</span></span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="variable constant_">PORT</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`服务器在端口 <span class="subst">$&#123;PORT&#125;</span> 上运行并监听 GitHub Webhook 通知`</span>);</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Postman 检查：服务器已启动，准备接收 Webhook 通知。&#x27;</span>);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 捕获所有可能的未捕获异常</span></span><br><span class="line"></span><br><span class="line">process.<span class="title function_">on</span>(<span class="string">&#x27;uncaughtException&#x27;</span>, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;未捕获的异常:&#x27;</span>, err);</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Postman 检查：出现未捕获的异常，请检查错误信息。&#x27;</span>);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">process.<span class="title function_">on</span>(<span class="string">&#x27;unhandledRejection&#x27;</span>, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;未处理的拒绝:&#x27;</span>, err);</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Postman 检查：出现未处理的 Promise 拒绝，请检查错误信息。&#x27;</span>);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>其中注意要修改的目录地址</p><div class="tip warning"><p>其 server 文件和你的 git仓库项目（.git 在项目里面）是同级的关系</p></div><p>在 server 目录下执行<br><code>node server.js</code><br>把服务器开启</p><p>会如图下所示<br><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/20241124153557.png" alt=""><br>然后保证你的内网映射端口是 3000<br><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/20241124153700.png" alt=""></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div class="tabs" id="uniquename7"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename7-1"><i class="icon"></i>配置 github webhook</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename7-1"><h3 id="配置-github-webhook"><a href="#配置-github-webhook" class="headerlink" title="配置 github webhook"></a>配置 github webhook</h3><p><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/20241124154031.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/20241124154155.png" alt=""><br>提交<br><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/20241124154250.png" alt=""><br>你会收到<br><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/20241124154357.png" alt=""><br>说明连接上了</p><p>然后我们 push 一下新代码，看看能不能下拉<br><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/20241124154534.png" alt=""><br>这样就成功了</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div class="tabs" id="uniquename8"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename8-1"><i class="icon"></i>使用 pm 2持久化自动拉取</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename8-1"><h3 id="使用-pm-2持久化自动拉取"><a href="#使用-pm-2持久化自动拉取" class="headerlink" title="使用 pm 2持久化自动拉取"></a>使用 pm 2持久化自动拉取</h3><p>我们如果总是这样开着一个很麻烦，那么有没有办法让其默认启动呢？<br>就是使用 pm 2 来代为管理<br>安装参考： <a href="https://blog.csdn.net/sunyctf/article/details/130655852">https://blog.csdn.net/sunyctf/article/details/130655852</a></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div class="tabs" id="uniquename9"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename9-1"><i class="icon"></i>例子</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename9-1"><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>例如 <code>pm2 start server.js --name &quot;pull automatic program&quot;</code><br>就可以 <code>pm2 list</code> 查看该进程<br><code>pm2 restart &quot;pull automatic program&quot;</code> 重启该进程<br><code>pm2 stop &quot;pull automatic program&quot;</code> 停止该进程<br><code>pm2 delete &quot;pull automatic program&quot;</code> 删除该进程<br><code>pm2 logs &quot;pull automatic program&quot;</code> 查看日志</p><p><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/20241124161440.png" alt=""></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>]]></content>
    
    
    <summary type="html">git</summary>
    
    
    
    <category term="git" scheme="https://huanxueblog.top/categories/git/"/>
    
    
    <category term="git" scheme="https://huanxueblog.top/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>关于创建mysql连接池的具体思路和实现</title>
    <link href="https://huanxueblog.top/posts/a3bc84e3.html"/>
    <id>https://huanxueblog.top/posts/a3bc84e3.html</id>
    <published>2024-05-12T14:52:45.000Z</published>
    <updated>2024-05-13T03:40:23.831Z</updated>
    
    <content type="html"><![CDATA[<div class="tabs" id="uniquename2"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename2-1"><i class="icon"></i>思路</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename2-1"><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>首先连接池做的就是管理连接的作用</p><p>而用户需要的是连接</p><p>我们就是管理连接并且提供连接的过程</p><p>所以我们围绕的是 getconnection，如何让用户获得一个连接。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div class="tabs" id="uniquename3"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename3-1"><i class="icon"></i>目的</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename3-1"><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>原本的 mysql 的 api 或者封装的 mysql 类，都可以建立连接，为什么要做一个连接池来管理呢？</p><p>因为大量的用户连接请求会导致大量的连接创建和销毁，消耗资源，所以就想能不能优化这一部分？</p><p>其中大量的连接是重复的，是可以被重新调用访问数据库的。也就是说很多是不需要销毁的，如果恰好够用且不销毁，那么就不会大量创建，所以其中创建和销毁是重复的。</p><p>所以整个的数据库连接池就是为了提升效率，减少重复的冗余操作。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div class="tabs" id="uniquename4"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename4-1"><i class="icon"></i>整个 mysql 结构图</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename4-1"><h3 id="整个-mysql-结构图"><a href="#整个-mysql-结构图" class="headerlink" title="整个 mysql 结构图"></a>整个 mysql 结构图</h3><p><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/46546a5w1d5.png" alt=""></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div class="tabs" id="uniquename5"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename5-1"><i class="icon"></i>单例设计思路</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename5-1"><h3 id="单例设计思路"><a href="#单例设计思路" class="headerlink" title="单例设计思路"></a>单例设计思路</h3><p>单例推荐采用的是 c++11 支持的性质：”在 C++中，函数内部可以声明静态局部变量。这些变量在函数第一次执行到它们的声明时进行初始化，并且在程序的整个运行期间保持它们的值，即使函数已经返回。每次函数被调用时，这些变量都会保持它们上一次调用结束时的状态。”</p><p>也就是说，只要被执行一次，那么就会初始化，且只初始化一次。</p><p>所以也引出我们单例设计的模式：“magic static“</p><p>其他的单例模式不是很推荐，因为或多或少都有其他的问题，像 <code>饿汉模式</code>，如果程序运行过程中可能不会使用到该单例，会导致资源浪费，而 <code>双重检查锁定模式</code> 会因为编译器的优化导致出现线程安全问题，就是你想的和编译器以为的不一样。还有就是 <code>枚举类型</code> 实现起来繁琐且不直观。</p><p>所以采用 <code>magic static</code> 的方式，简单且安全</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取单例实例</span></span><br><span class="line"><span class="function">connection_pool&amp; <span class="title">connection_pool::GetInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> connection_pool connPool;</span><br><span class="line">    <span class="keyword">return</span> connPool;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div class="tabs" id="uniquename6"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename6-1"><i class="icon"></i>RAII 设计思路</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename6-1"><h3 id="RAII-设计思路"><a href="#RAII-设计思路" class="headerlink" title="RAII 设计思路"></a>RAII 设计思路</h3><p>我们获取当前的连接池的单例后，要考虑的就是如何写我们的构造函数，这个应该参照 RAII 设计</p><p> RAII 模式，也就是“资源获取即初始化”，为的是将资源的获取和释放与对象的生命周期绑定在一起。当对象被创建时，它负责获取所需的资源；当对象被销毁时，它负责释放资源。</p><p>所以我们的构造函数和析构函数就要围绕构造的时候获取什么？析构的时候顺带销毁什么？</p><p>连接池，那就是 sql 连接管理的池子，自然就是<strong>构造函数获取初始连接，析构函数析构所有连接</strong></p><p>所以设计上应该需要在构造函数和析构函数中设置两个循环，分别管理连接</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">ConnectionPool::~<span class="built_in">ConnectionPool</span>()</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放队列中的所有连接</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!m_connectionQ.<span class="built_in">empty</span>())&#123;</span><br><span class="line"></span><br><span class="line">        MySqlConn *conn = m_connectionQ.<span class="built_in">front</span>();</span><br><span class="line"></span><br><span class="line">        m_connectionQ.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span> conn;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放在外面的连接</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (MySqlConn* conn : m_memoryS) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span> conn;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div class="tabs" id="uniquename7"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename7-1"><i class="icon"></i>生产者线程，消费者线程</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename7-1"><h3 id="生产者线程，消费者线程"><a href="#生产者线程，消费者线程" class="headerlink" title="生产者线程，消费者线程"></a>生产者线程，消费者线程</h3><ul><li>首先生产者线程应该有生产函数</li><li>消费者线程有消费函数</li><li>两者线程应该分离开来区别于主线程</li></ul><p>所以引出三个问题<br>主线程是什么？<br>消费者函数怎么写？<br>生产者函数怎么写？</p><h4 id="主线程"><a href="#主线程" class="headerlink" title="主线程"></a>主线程</h4><p>母庸质疑就是调用线程池的 main 方法。</p><p>那么不可能在调用 main 方法的地方我们分离生产者函数和消费者函数，因为我们是封装好的类，应该只提供让用户 get 的接口，而不是让用户操作，应该让用户将其看成黑盒，而不是做更多的操作。</p><p>所以，应该如何分离消费者线程和和生产者线程呢？</p><p>首先，从线程安全的角度看，如果生产者，消费者线程，启动得太快，那么就会访问到未初始化的数据，如果启动得太慢，又无法动态调整连接数量，导致响应过慢，影响效率。</p><p>再从职责上讲，函数无非就是 <code>getconnection</code> ，<code>produceConnection</code>，<code>recycleConnection</code> <code>getInstance</code><br>什么样的函数就应该只做怎么样的事情，所以选择在构造函数中分离生产函数和消费函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">ConnectionPool::<span class="built_in">ConnectionPool</span>()</span><br><span class="line"></span><br><span class="line">&#123;  </span><br><span class="line">    <span class="comment">//加载配置文件</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">parseJsonFile</span>())&#123;</span><br><span class="line"></span><br><span class="line">        std::cerr&lt;&lt;<span class="string">&quot;pareseJsonFile is failed&quot;</span>&lt;&lt;std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_CntSize=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建连接个数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m_minSize;i++)&#123;</span><br><span class="line">    <span class="built_in">addConnection</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调用两个线程分别生产和消费</span></span><br><span class="line"><span class="comment">//选择在构造函数中分离生产函数和消费函数</span></span><br><span class="line">    <span class="function">std::thread <span class="title">producer</span><span class="params">(&amp;ConnectionPool::produceConnection,<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">recycler</span><span class="params">(&amp;ConnectionPool::recycleConnection,<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    producer.<span class="built_in">detach</span>();</span><br><span class="line">    recycler.<span class="built_in">detach</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="生产者函数"><a href="#生产者函数" class="headerlink" title="生产者函数"></a>生产者函数</h4><p>生产函数 <code>produceConnection</code></p><p>首先他需要线程分离，然后 <code>不断</code> 地去判断一些条件，符合条件的就生产，因为 <code>不断</code> 所以我们必须用 <code>while</code> 来覆盖住整个函数。</p><p>前面提到，如果我们需要按时间回收，用队列是比较好的选择，所以我们存储方式是选择队列，当符合条件就生产，加入队列。</p><p>那么这个条件是什么呢?</p><p>这个条件有两点  </p><ul><li>第一如果队列中有可用连接就不生产  </li><li>第二如果生产连接达到上限就不生产  </li></ul><p>这样做就可以让连接维持在一个规定的上界，同时让队列始终保持有连接。  </p><p>随后当我们调用完函数以后就需要通知消费者消费，所以函数最后要加一个信号量通知。  </p><p>但有一个问题，生产者如果不生产需不需要通知消费者?<br>事实上是不需要的，等待调用连接结束，可以通过智能指针回收连接到队列当中，同时再唤醒消费者即可。  </p><p>所以整个的逻辑是<br>当消费者消费时，生产者就得被唤醒，判断队列是否为空，如果为空，就说明需要生产连接，再判断是否生产在上限以内，如果是就生产，然后唤醒，不是就重新循环等待被唤醒。  </p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ConnectionPool::produceConnection</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="comment">//创建自动管理锁的对象</span></span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(m_mutexQ)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(!m_connectionQ.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            m_cond.<span class="built_in">wait</span>(locker);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(m_CntSize&lt;m_maxSize)&#123;</span><br><span class="line">        <span class="built_in">addConnection</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//生产后要去唤醒消费者线程</span></span><br><span class="line">        m_cond.<span class="built_in">notify_all</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div class="tabs" id="uniquename8"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename8-1"><i class="icon"></i>消费者线程</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename8-1"><h3 id="消费者线程"><a href="#消费者线程" class="headerlink" title="消费者线程"></a>消费者线程</h3><h4 id="getconnection"><a href="#getconnection" class="headerlink" title="getconnection"></a>getconnection</h4><p>消费者线程就是 <code>getConnection</code> 函数和<code>recycleConnection</code>函数两个函数，我们先说 <code>getConnection</code>，<code>getConnection</code> 是主线程用户调用的线程，通过调用获得连接。  </p><p><code>getConnection</code>无非就是拿的过程，从什么地方拿?从队列中拿，拿取头一个元素，返回的是一个指针类型。  </p><p>那么拿走的连接如何还回到队列当中呢?时间上肯定是需要单用户结束调用的时候，还回到队列当中，一般的想法是提供一个用户接口，让用户把连接放进去，但是这样太不优雅了，不应该让用户管理释放。  </p><p>那么回到刚刚说的，返回的是一个指针类型，是不是就可以考虑智能指针，来管理连接。通过lambda函数，把释放的链接放入队列。另外的关于智能指针的选择，推荐使用独占智能制造，因为共享智能指针可能会被用户错误的使用导致循环引用等问题，同时出现bug也不好寻找析构的代码行。所以优先考虑独占智能指针。  </p><p>那么回到代码上来，首先<code>getConnection</code>函数是通过用户主线程调用的，所以是不需要向分离线程一样，使用一个while来维持线程运作，这是区别于生产者线程和回收者线程的。  </p><p>首先通过锁实现线程同步，再去访问当前的队列有没有连接，有连接就拿。没有连接就阻塞一段时间，再访问，如果没有得到打印错误信息，直接返回空。得到的连接用智能指针管理，释放智能指针的时候，同时把连接放回队列当中。最后通知生产者判断有没有必要生产，返回一个智能指针类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;MySqlConn&gt;ConnectionPool::<span class="built_in">getConnection</span>()</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">locker</span><span class="params">(m_mutexQ)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先判断是否有连接可用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果是空的，那么就保证阻塞</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m_connectionQ.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cv_status::timeout == m_cond.<span class="built_in">wait_for</span>(locker, chrono::<span class="built_in">milliseconds</span>(m_timeout))) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果阻塞后仍然为空那么就记入次数，同时再次进入阻塞</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (m_connectionQ.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Unable to acquire connection from pool&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记忆当前的连接</span></span><br><span class="line"></span><br><span class="line">    m_memoryS.<span class="built_in">insert</span>(m_connectionQ.<span class="built_in">front</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//然后直接获取</span></span><br><span class="line"></span><br><span class="line">    shared_ptr&lt;MySqlConn&gt;<span class="built_in">connptr</span>(m_connectionQ.<span class="built_in">front</span>(),[<span class="keyword">this</span>](MySqlConn*conn)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//由于资源是共享的，所以要加锁</span></span><br><span class="line"></span><br><span class="line">        lock_guard&lt;mutex&gt; <span class="built_in">locker</span>(m_mutexQ);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果找到就删除</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (m_memoryS.<span class="built_in">find</span>(conn) != m_memoryS.<span class="built_in">end</span>()) &#123;</span><br><span class="line"></span><br><span class="line">        m_memoryS.<span class="built_in">erase</span>(conn);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        conn-&gt;<span class="built_in">refreshAliveTime</span>();</span><br><span class="line"></span><br><span class="line">        m_connectionQ.<span class="built_in">push</span>(conn);</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    m_connectionQ.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">    m_cond.<span class="built_in">notify_all</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> connptr;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="回收线程"><a href="#回收线程" class="headerlink" title="回收线程"></a>回收线程</h4><p>回收线程的设计是基于如果多余的连接超时就释放连接，以保证空闲时没有大量的连接占用。  </p><p>因为需要再后台去轮询所有的连接是否超时，所以需要用到线程分离，那么就需要一个while循环这个函数代码。<br>但是也不能一直轮询，会浪费cpu调度，那么就使用一个sleep隔一段时间回收一次。<br>回收的时候需要对队列资源进行访问，所以要用到锁，上一个锁然后开始访问资源，访问哪一个资源呢?如果回收连接的话，回收那一刻一定是最新的，所以在队头的一定是最旧的，所以从队头到队尾轮询时间。<br>如果此时连接数量大于初始设置数量，且超时，那么就回收连接，否则就直接返回，因为如果当前没有超市，后面更新的也不会超时了。  </p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="type">void</span> <span class="title">ConnectionPool::recycleConnection</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// std::cerr&lt;&lt;&quot;recycleConnection&quot;&lt;&lt;std::endl;</span></span><br><span class="line"></span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(m_mutexQ)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(m_CntSize&gt;m_minSize)&#123;</span><br><span class="line"></span><br><span class="line">            MySqlConn* conn=m_connectionQ.<span class="built_in">front</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//为什么队头的存活时间是最长的？</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(conn-&gt;<span class="built_in">getAliveTime</span>()&gt;=m_maxIdleTime)&#123;</span><br><span class="line"></span><br><span class="line">                m_connectionQ.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                m_CntSize--;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">delete</span> conn;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div class="tabs" id="uniquename9"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename9-1"><i class="icon"></i>析构函数</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename9-1"><h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>那么因为我们使用的是RAII原则，所以创建的要再析构中释放掉，那么我们释放的是什么，是连接对吧，所以我们把队列中的全部弹出来释放掉就可以了。  </p><p>但是有没有发现一个问题，如果说用户提前调用了析构函数，那么是不是队列没了，队列里面的连接释放了，但是分出去的连接还会回来访问队列，出现未定义的行为?  </p><p>那么如果我们把析构函数设置成私有的似乎是可以的，不让用户提前删除，但是如果用户就想关闭数据库怎么办?<br>而且因为析构函数是私有的，那么栈上就无法释放这个实例，因为当作用域结束，编译器是会自动调用析构函数的，如果私有将无法调用，从而出现内存泄漏。  </p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div class="tabs" id="uniquename10"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename10-1"><i class="icon"></i>一些额外的问题</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename10-1"><h3 id="一些额外的问题"><a href="#一些额外的问题" class="headerlink" title="一些额外的问题"></a>一些额外的问题</h3><p>如果我们考虑使用一个<code>close</code>函数通过<code>while</code>配合信号量，当返回的时候通知<code>close</code>判断是否符合析构条件，如果析构，听起来好像还行，但是问题在于，我们的析构函数是不应该被成员函数调用的，如果成员函数使用了成员变量，那么这个成员变量被析构了又在成员函数作用域，这样容易引起错误。  </p><p>所以我对此的想法就是做再做一个集合，存放分出去的连接，当析构函数被调用的时候，两个集合都便利一遍，释放就可以了。  </p><p>所以在<code>getConnection</code>函数中我们把连接添加到分出去集合<br>在<code>lambda</code>中，我们从分发集合中删除该连接。  </p><p>所以我们通过分发集合和空闲队列一起管理连接的建立。</p><p>这样就把在外的和在内的连接都回收了就不会出现连接回收的问题。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div class="tabs" id="uniquename11"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename11-1"><i class="icon"></i>源码</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename11-1"><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><h4 id="cpp"><a href="#cpp" class="headerlink" title=".cpp"></a>.cpp</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ConnectionPool.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;rapidjson/document.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;rapidjson/istreamwrapper.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span>  </span></span><br><span class="line"></span><br><span class="line">ConnectionPool::~<span class="built_in">ConnectionPool</span>()</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放队列中的所有连接</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!m_connectionQ.<span class="built_in">empty</span>())&#123;</span><br><span class="line"></span><br><span class="line">        MySqlConn *conn = m_connectionQ.<span class="built_in">front</span>();</span><br><span class="line"></span><br><span class="line">        m_connectionQ.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span> conn;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放在外面的连接</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (MySqlConn* conn : m_memoryS) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span> conn;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="function">ConnectionPool *<span class="title">ConnectionPool::getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> ConnectionPool instance; <span class="comment">// 局部静态变量，线程安全的初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &amp;instance;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用户获取接口(可以用优先级队列优化)</span></span><br><span class="line"></span><br><span class="line">shared_ptr&lt;MySqlConn&gt;ConnectionPool::<span class="built_in">getConnection</span>()</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// std::cerr&lt;&lt;&quot;getConnection()locker(m_mutexQ)&quot;&lt;&lt;std::endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">locker</span><span class="params">(m_mutexQ)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先判断是否有连接可用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m_connectionQ.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// std::cerr&lt;&lt;&quot; getConnection()_while (m_connectionQ.empty()&quot;&lt;&lt;std::endl;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cv_status::timeout == m_cond.<span class="built_in">wait_for</span>(locker, chrono::<span class="built_in">milliseconds</span>(m_timeout))) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果阻塞后仍然为空那么就记入次数，同时再次进入阻塞</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (m_connectionQ.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Unable to acquire connection from pool&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记忆当前的连接</span></span><br><span class="line"></span><br><span class="line">    m_memoryS.<span class="built_in">insert</span>(m_connectionQ.<span class="built_in">front</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//然后直接获取</span></span><br><span class="line"></span><br><span class="line">    shared_ptr&lt;MySqlConn&gt;<span class="built_in">connptr</span>(m_connectionQ.<span class="built_in">front</span>(),[<span class="keyword">this</span>](MySqlConn*conn)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//由于资源是共享的，所以要加锁</span></span><br><span class="line"></span><br><span class="line">        lock_guard&lt;mutex&gt; <span class="built_in">locker</span>(m_mutexQ);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果找到就删除</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (m_memoryS.<span class="built_in">find</span>(conn) != m_memoryS.<span class="built_in">end</span>()) &#123;</span><br><span class="line"></span><br><span class="line">        m_memoryS.<span class="built_in">erase</span>(conn);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        conn-&gt;<span class="built_in">refreshAliveTime</span>();</span><br><span class="line"></span><br><span class="line">        m_connectionQ.<span class="built_in">push</span>(conn);</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    m_connectionQ.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">    m_cond.<span class="built_in">notify_all</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> connptr;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//连接池初始化</span></span><br><span class="line"></span><br><span class="line">ConnectionPool::<span class="built_in">ConnectionPool</span>()</span><br><span class="line"></span><br><span class="line">&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//加载配置文件</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">parseJsonFile</span>())&#123;</span><br><span class="line"></span><br><span class="line">        std::cerr&lt;&lt;<span class="string">&quot;pareseJsonFile is failed&quot;</span>&lt;&lt;std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_CntSize=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建连接个数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m_minSize;i++)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">addConnection</span>();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用两个线程分别生产和消费</span></span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">producer</span><span class="params">(&amp;ConnectionPool::produceConnection,<span class="keyword">this</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">recycler</span><span class="params">(&amp;ConnectionPool::recycleConnection,<span class="keyword">this</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    producer.<span class="built_in">detach</span>();</span><br><span class="line"></span><br><span class="line">    recycler.<span class="built_in">detach</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化数据库数据</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ConnectionPool::parseJsonFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::ifstream <span class="title">ifs</span><span class="params">(<span class="string">&quot;dbconf.json&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">rapidjson::IStreamWrapper <span class="title">isw</span><span class="params">(ifs)</span></span>;</span><br><span class="line"></span><br><span class="line">    rapidjson::Document d;</span><br><span class="line"></span><br><span class="line">    d.<span class="built_in">ParseStream</span>(isw);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (d.<span class="built_in">IsObject</span>()) &#123;</span><br><span class="line"></span><br><span class="line">        m_ip = d[<span class="string">&quot;ip&quot;</span>].<span class="built_in">GetString</span>();</span><br><span class="line"></span><br><span class="line">        m_port = d[<span class="string">&quot;port&quot;</span>].<span class="built_in">GetUint</span>();</span><br><span class="line"></span><br><span class="line">        m_user = d[<span class="string">&quot;userName&quot;</span>].<span class="built_in">GetString</span>();</span><br><span class="line"></span><br><span class="line">        m_passwd = d[<span class="string">&quot;password&quot;</span>].<span class="built_in">GetString</span>();</span><br><span class="line"></span><br><span class="line">        m_dbName = d[<span class="string">&quot;dbName&quot;</span>].<span class="built_in">GetString</span>();</span><br><span class="line"></span><br><span class="line">        m_minSize = d[<span class="string">&quot;minSize&quot;</span>].<span class="built_in">GetInt</span>();</span><br><span class="line"></span><br><span class="line">        m_maxSize = d[<span class="string">&quot;maxSize&quot;</span>].<span class="built_in">GetInt</span>();</span><br><span class="line"></span><br><span class="line">        m_maxIdleTime = d[<span class="string">&quot;maxIdleTime&quot;</span>].<span class="built_in">GetInt</span>();</span><br><span class="line"></span><br><span class="line">        m_timeout = d[<span class="string">&quot;timeout&quot;</span>].<span class="built_in">GetInt</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生产数据库连接</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ConnectionPool::produceConnection</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// std::cerr&lt;&lt;&quot;produceConnection()_while(true)&quot;&lt;&lt;std::endl;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建自动管理锁的对象</span></span><br><span class="line"></span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(m_mutexQ)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果当前还有就阻塞</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!m_connectionQ.<span class="built_in">empty</span>())&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// std::cerr&lt;&lt;&quot;produceConnection()_while(!m_connectionQ.empty())&quot;&lt;&lt;std::endl;</span></span><br><span class="line"></span><br><span class="line">            m_cond.<span class="built_in">wait</span>(locker);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果当前没有就生产</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(m_CntSize&lt;m_maxSize)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// std::cerr&lt;&lt;&quot;produceConnection()_if(m_CntSize&lt;m_maxSize)&quot;&lt;&lt;std::endl;</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">addConnection</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//生产后要去唤醒消费者线程</span></span><br><span class="line"></span><br><span class="line">        m_cond.<span class="built_in">notify_all</span>();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ConnectionPool::recycleConnection</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// std::cerr&lt;&lt;&quot;recycleConnection&quot;&lt;&lt;std::endl;</span></span><br><span class="line"></span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(m_mutexQ)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(m_CntSize&gt;m_minSize)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// std::cerr&lt;&lt;&quot;recycleConnection_while(m_CntSize&gt;m_minSize)&quot;&lt;&lt;std::endl;</span></span><br><span class="line"></span><br><span class="line">            MySqlConn* conn=m_connectionQ.<span class="built_in">front</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//为什么队头的存活时间是最长的？</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(conn-&gt;<span class="built_in">getAliveTime</span>()&gt;=m_maxIdleTime)&#123;</span><br><span class="line"></span><br><span class="line">                m_connectionQ.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                m_CntSize--;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">delete</span> conn;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ConnectionPool::addConnection</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// std::cerr&lt;&lt;&quot;addConnection()&quot;&lt;&lt;std::endl;</span></span><br><span class="line"></span><br><span class="line">    MySqlConn *p = <span class="keyword">new</span> <span class="built_in">MySqlConn</span>();</span><br><span class="line"></span><br><span class="line">    p-&gt;<span class="built_in">connect</span>(m_user, m_passwd, m_dbName, m_ip, m_port);</span><br><span class="line"></span><br><span class="line">    p-&gt;<span class="built_in">refreshAliveTime</span>(); <span class="comment">// 刷新一下开始空闲的起始时间</span></span><br><span class="line"></span><br><span class="line">    m_connectionQ.<span class="built_in">push</span>(p);</span><br><span class="line"></span><br><span class="line">    m_CntSize++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="h"><a href="#h" class="headerlink" title=".h"></a>.h</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MySqlConn.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConnectionPool</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁用拷贝构造函数和赋值操作符</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">ConnectionPool</span>(<span class="type">const</span> ConnectionPool&amp; obj) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    ConnectionPool&amp; <span class="keyword">operator</span>=(<span class="type">const</span> ConnectionPool&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">ConnectionPool</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> ConnectionPool* <span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如何让用户得到链接？(因为要动态管理所以用非静态的接口)</span></span><br><span class="line"></span><br><span class="line">    <span class="function">shared_ptr&lt;MySqlConn&gt; <span class="title">getConnection</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ConnectionPool</span>() ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//json使用文件</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">parseJsonFile</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">produceConnection</span><span class="params">()</span> </span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">recycleConnection</span> <span class="params">()</span> </span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addConnection</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不需要静态指针成员，因为我们使用局部静态变量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据库的ip</span></span><br><span class="line"></span><br><span class="line">    string m_ip;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据库管理用户名</span></span><br><span class="line"></span><br><span class="line">    string m_user;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据库的密码</span></span><br><span class="line"></span><br><span class="line">    string m_passwd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据库的库名</span></span><br><span class="line"></span><br><span class="line">    string m_dbName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//我的端口</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> m_port;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//规定上下界</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m_CntSize=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m_minSize;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m_maxSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最大请求连接重试次数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> maxRetryCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//超时的等待时长</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m_timeout;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最长的sql连接空闲时长</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m_maxIdleTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//链接队列</span></span><br><span class="line"></span><br><span class="line">    std::queue&lt;MySqlConn*&gt; m_connectionQ;</span><br><span class="line"></span><br><span class="line">    std::set&lt;MySqlConn*&gt; m_memoryS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//访问队列的互斥锁</span></span><br><span class="line"></span><br><span class="line">    std::mutex m_mutexQ  ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//消费者线程和生产者线程的条件变量</span></span><br><span class="line"></span><br><span class="line">    std::condition_variable m_cond;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>]]></content>
    
    
    <summary type="html">CMake</summary>
    
    
    
    <category term="MySql" scheme="https://huanxueblog.top/categories/MySql/"/>
    
    
    <category term="MySql" scheme="https://huanxueblog.top/tags/MySql/"/>
    
  </entry>
  
  <entry>
    <title>一文让你理解网络阻塞与非阻塞和多路io复用</title>
    <link href="https://huanxueblog.top/posts/a8fad53.html"/>
    <id>https://huanxueblog.top/posts/a8fad53.html</id>
    <published>2024-04-21T09:55:33.000Z</published>
    <updated>2024-04-21T10:02:54.571Z</updated>
    
    <content type="html"><![CDATA[<div class="tabs" id="uniquename2"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename2-1"><i class="icon"></i>主线是什么</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename2-1"><h3 id="主线是什么"><a href="#主线是什么" class="headerlink" title="主线是什么"></a>主线是什么</h3><p>首先为什么需要我们的网络多路复用，阻塞和非阻塞，因为我们需要考虑效率，而客户端和服务端一对一通信显然是不会陷入效率问题，而真正会产生效率问题是因为我们的多线程处理并发的场景，因此主线就是多线程中的主线程和子线程</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div class="tabs" id="uniquename3"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename3-1"><i class="icon"></i>阻塞在阻塞什么</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename3-1"><h3 id="阻塞在阻塞什么"><a href="#阻塞在阻塞什么" class="headerlink" title="阻塞在阻塞什么"></a>阻塞在阻塞什么</h3><h4 id="函数分析"><a href="#函数分析" class="headerlink" title="函数分析"></a>函数分析</h4><p>我们不妨分析一下所有的 socket 函数，看看什么适合主线程，什么适合子线程。<br>首先 socket 函数创建的是一个 sock 结构体，交给内核管理<br>然后是 bind 函数给 sock 绑定 ip 和端口<br>之后是 listen 函数初始化半连接队列和全连接队列，并且初始化 sock 状态<br>再然后是 accept 函数从全连接队列中获取 sock 的 fd<br>Recv 函数通过这个 fd 获得 sock 中缓冲区的内容，并加以处理<br>Send 函数通过 fd 获得 sock 中缓冲区的位置，并开始写，又由内核发送</p><h4 id="哪些阻塞？"><a href="#哪些阻塞？" class="headerlink" title="哪些阻塞？"></a>哪些阻塞？</h4><ol><li><p><code>socket()</code>：这个函数用于创建一个新的 socket，这个过程通常是非阻塞的。</p></li><li><p><code>bind()</code>：这个函数用于将 socket 绑定到一个特定的 IP 地址和端口号，这个过程也是非阻塞的。</p></li><li><p><code>listen()</code>：这个函数用于将 socket 设置为监听模式，等待客户端的连接请求，这个过程也是非阻塞的。</p></li><li><p><code>accept()</code>：这个函数用于接受客户端的连接请求。如果没有客户端请求连接，这个函数会阻塞，直到有客户端连接为止。</p></li><li><p><code>recv()</code>：这个函数用于从连接的 socket 中接收数据。如果 socket 中没有数据，这个函数会阻塞，直到有数据可读。</p></li><li><p><code>send()</code>：这个函数用于向连接的 socket 发送数据。如果发送缓冲区已满，这个函数会阻塞，直到有足够的空间可以发送新的数据。</p></li></ol><p>三个阻塞，分别为 <code>accept()</code> <code>recv()</code> <code>send()</code></p><h4 id="主线程应该是什么，子线程应该是什么，为什么"><a href="#主线程应该是什么，子线程应该是什么，为什么" class="headerlink" title="主线程应该是什么，子线程应该是什么，为什么"></a>主线程应该是什么，子线程应该是什么，为什么</h4><p>按照上面的解释，我们应该只考虑 <code>accept()</code> <code>recv()</code> <code>send()</code> 中区分从哪里开始是主线程，哪里是子线程，因为如果是非阻塞的话，那么是不需要分主线程还是子线程的，因为如果不阻塞就不存在要创建多个线程来处理，一个线程就可以直接处理完了。或者换一个角度想，如果主线程出现了阻塞很多，那么整个程序就堵住了，所以为了防止主线程被堵住，应该把经常造成阻塞的函数分给子线程，让子线程自个去阻塞，然后不影响整个进程。</p><p><code>accept()</code>： accept 函数从全连接队列中获取 sock 的 fd<br>这个操作相当于是去取 sock，如果没有客户端请求，那么就不会有 sock。</p><p>那么我们来假设一下，如果是放到子线程会怎么样？</p><p>那么主线程此时是没有阻塞状态的对吧？子线程和主线程是相互脱离的，很有可能就是主线程已经结束，而子线程没运行完或者是在阻塞，而<strong>导致子线程没有处理完，主线程提前结束</strong></p><p>那么我们来假设一下，如果是放到主线程会怎么样？</p><p>那么就不会出现上述情况，主线程会一直等待请求（while 循环维持），显示就是主线程正在等待数据对吧。</p><p><strong>所以我们把 accept 归类到主线程，保证主线程正常等待客户端通信，防止主线程提前结束</strong></p><p>由于我们的收发是一个组合操作所以我们一起考虑<br><code>recv()</code>：这个函数用于从连接的 socket 中接收数据。如果 socket 中没有数据，这个函数会阻塞，直到有数据可读。<br><code>send()</code>：这个函数用于向连接的 socket 发送数据。如果发送缓冲区已满，这个函数会阻塞，直到有足够的空间可以发送新的数据。</p><p>那么我们来假设一下，如果是放到子线程会怎么样？</p><p>那么就是从 accept 得到的 fd 都交给子线程处理，相当于一个线程拥有一个 sock，然后我们把剩余的操作全部交给子线程</p><p>那么我们来假设一下，如果是放到主线程会怎么样？</p><p>那么就是从 accept 得到的 fd 都交给主线程处理，相当于主线程一次只能处理一个请求，失去了并发性。</p><p>所以我们知道了，accept 用于持续接收通信所以必须放在主线程，而 recv 和 send 保证并发就必须放到子线程中</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div class="tabs" id="uniquename4"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename4-1"><i class="icon"></i>非阻塞在非阻塞什么</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename4-1"><h3 id="非阻塞在非阻塞什么"><a href="#非阻塞在非阻塞什么" class="headerlink" title="非阻塞在非阻塞什么"></a>非阻塞在非阻塞什么</h3><h4 id="非阻塞理解"><a href="#非阻塞理解" class="headerlink" title="非阻塞理解"></a>非阻塞理解</h4><p>非阻塞的事实上就是对于阻塞 io 的一种改进，虽然阻塞 io 可以通过多线程技术实现一个效果不错的并发，但是也是以消耗大量资源（线程创建销毁）的代价下完成的。</p><p>上面说阻塞是 <code>accept()</code> <code>recv()</code> <code>send()</code> 三个函数导致的，那么非阻塞自然就是使的这是三个函数变成非阻塞的状态。</p><p>很显然通过之前的讨论，accept 假装必须阻塞，保证客户端的请求得以响应，但是这不就矛盾了？我们如果阻塞了 accept，那么怎么执行下面的接收和发送？我们只有一个主线程。</p><p>很简单，我们对于 accept 的返回值进行一个判断，如果小于 0，那么就是没有接收到就去执行 recv 和 send，如果接收到那么就缓存到数组当中。</p><p>然后 recv 和 send 从数组中提取 fd，然后根据返回值，有准备好就发和接收，如果没有就跳过。然后重新进入 accept 循环</p><p>这样就实现了非阻塞同时并发的效果</p><p>所以非阻塞是非阻塞了 <code>accept()</code> <code>recv()</code> <code>send()</code> 三个函数</p><h4 id="非阻塞条件"><a href="#非阻塞条件" class="headerlink" title="非阻塞条件"></a>非阻塞条件</h4><ul><li>设置非阻塞 sock<br>  阻塞：<br>  <code>int lfd=socket(AF_INET,SOCK_STREAM,0);</code><br>  非阻塞：<br>  <code>int lfd = socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK, 0);</code></li><li>初始化 accept接收到 sock 为非阻塞<br>  <code>#include &lt;fcntl.h&gt;</code><br>  <code>fcntl(new_socket_fd, F_SETFL, O_NONBLOCK);</code><h4 id="非阻塞代码"><a href="#非阻塞代码" class="headerlink" title="非阻塞代码"></a>非阻塞代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_CLIENTS 1000</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sockfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM | SOCK_NONBLOCK, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_addr;</span><br><span class="line"></span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line"></span><br><span class="line">    serv_addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    serv_addr.sin_port = <span class="built_in">htons</span>(<span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bind</span>(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;serv_addr, <span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">listen</span>(sockfd, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> client_sockets[MAX_CLIENTS];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;MAX_CLIENTS; i++)</span><br><span class="line"></span><br><span class="line">        client_sockets[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> new_socket = <span class="built_in">accept</span>(sockfd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (new_socket &lt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (errno == EAGAIN || errno == EWOULDBLOCK)</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">                    <span class="built_in">perror</span>(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">fcntl</span>(new_socket, F_SETFL, O_NONBLOCK);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;MAX_CLIENTS; i++) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (client_sockets[i] == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                    client_sockets[i] = new_socket;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;MAX_CLIENTS; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (client_sockets[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">                <span class="type">int</span> valread = <span class="built_in">recv</span>(client_sockets[i], buffer, <span class="built_in">sizeof</span>(buffer), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (valread &lt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (errno != EAGAIN &amp;&amp; errno != EWOULDBLOCK)</span><br><span class="line"></span><br><span class="line">                        <span class="built_in">perror</span>(<span class="string">&quot;recv&quot;</span>);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (valread == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="built_in">close</span>(client_sockets[i]);</span><br><span class="line"></span><br><span class="line">                    client_sockets[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="built_in">send</span>(client_sockets[i], buffer, valread, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div class="tabs" id="uniquename5"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename5-1"><i class="icon"></i>多路 io 复用，多路在哪里</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename5-1"><h3 id="多路-io-复用，多路在哪里"><a href="#多路-io-复用，多路在哪里" class="headerlink" title="多路 io 复用，多路在哪里"></a>多路 io 复用，多路在哪里</h3><p>我们知道目前的多路 io 复用基本上是 epoll ，但是我们还是需要去从 select 开始讲讲从根源触发到底是怎么回事</p><p>多路复用复用在那里？我们不妨看看非阻塞 nio 的实现，其中有一个循环去接收 accept 存到数组当中，这个过程会不断检查是否有准备好的数据，并且 recv 和 send 也会不断去检测是否有准备好的缓冲区。</p><p>Select 是什么，select 是将这种轮询给放到内核中，更具体的说，就是把对缓冲区的访问轮询给放到内核中，让内核自己去判断哪一个 fd 对应的读缓冲区或者写缓冲区出现可用的时候，返回 fd_set 类型的链表会标志为 1。</p><p>也就是说 select 是把我们非阻塞状态中对缓冲区的检测放到了内核，减少了从用户区到内核区的开销，这个开销也提一下，开销有：</p><ol><li><p><strong>上下文切换</strong>：从用户态转到内核态时，操作系统需要保存用户态的状态，并加载内核态的状态，这一过程称为上下文切换。上下文包括程序计数器、寄存器、内存权限等信息。</p></li><li><p><strong>安全性检查</strong>：在执行系统调用之前，操作系统会进行必要的安全性检查，以确保调用是合法的。这包括检查调用参数的有效性、权限验证等，这些检查本身也是一种开销。</p></li><li><p><strong>系统调用的处理</strong>：系统调用的处理通常比普通的函数调用更为复杂和耗时。系统需要在内核中查找相应的服务例程，并执行之，这个过程中可能还会涉及到更多的安全和兼容性检查。</p></li><li><p><strong>中断处理</strong>：在内核态，操作系统可能还需要处理各种中断和异常，这也会增加额外的开销。</p><h4 id="如何使用-select"><a href="#如何使用-select" class="headerlink" title="如何使用 select"></a>如何使用 select</h4><p>那么从 nio 到 select 变迁说完了，说说怎么使用。</p></li></ol><ul><li>Select 的函数<ul><li>有五个参数：<code>最大的 fd 值</code>，<code>读set</code>，<code>写set</code>，<code>异常set</code>，<code>超时结构体</code></li></ul></li><li>Isset 函数<ul><li>传入 <code>fd</code>，<code>fdset</code> 判断是否标志位为 1，如果是则准备好了，可以发送或者接收</li></ul></li><li>Select 的主线<ul><li>主线是通过对 fd 的遍历，用 isset 函数判断已经准备好缓冲区的 sock，随之调用或不调用 recv，send 函数</li></ul></li><li>Fd_Set<ul><li>需要先在 listen 后，通过 <code>fd_zero ()</code> 初始化 set，可以是读可以是写可以是异常, 用 <code>fd_set ()</code> 设置需要检查的内容，对服务器 sock 的 fd 设置标志位为 1</li></ul></li></ul><p>具体实现如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 9999</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">make_socket_non_blocking</span><span class="params">(<span class="type">int</span> fd)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> flags = <span class="built_in">fcntl</span>(fd, F_GETFL, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flags == <span class="number">-1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fcntl&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    flags |= O_NONBLOCK;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fcntl</span>(fd, F_SETFL, flags) == <span class="number">-1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fcntl&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> server_fd, new_socket;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> address;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> addrlen = <span class="built_in">sizeof</span>(address);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buffer[BUFFER_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 socket 文件描述符</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((server_fd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 socket 为非阻塞</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">make_socket_non_blocking</span>(server_fd);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 强制绑定端口</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">setsockopt</span>(server_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &amp;opt, <span class="built_in">sizeof</span>(opt))) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;setsockopt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line"></span><br><span class="line">    address.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    address.sin_port = <span class="built_in">htons</span>(PORT);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定 socket 到端口</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bind</span>(server_fd, (<span class="keyword">struct</span> sockaddr *)&amp;address, <span class="built_in">sizeof</span>(address))&lt;<span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;bind failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">listen</span>(server_fd, <span class="number">3</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    fd_set read_fds, temp_fds;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> max_sd = server_fd;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="built_in">FD_ZERO</span>(&amp;read_fds);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FD_SET</span>(server_fd, &amp;read_fds);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        temp_fds = read_fds;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> activity = <span class="built_in">select</span>(max_sd + <span class="number">1</span>, &amp;temp_fds, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((activity &lt; <span class="number">0</span>) &amp;&amp; (errno != EINTR)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;select error&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查是否有新的连接请求</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">FD_ISSET</span>(server_fd, &amp;temp_fds)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((new_socket = <span class="built_in">accept</span>(server_fd, (<span class="keyword">struct</span> sockaddr *)&amp;address, (<span class="type">socklen_t</span>*)&amp;addrlen))&lt;<span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">perror</span>(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置新 socket 为非阻塞</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">make_socket_non_blocking</span>(new_socket);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">FD_SET</span>(new_socket, &amp;read_fds);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (new_socket &gt; max_sd) &#123;</span><br><span class="line"></span><br><span class="line">                max_sd = new_socket;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 迭代所有的 socket 描述符</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= max_sd; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">FD_ISSET</span>(i, &amp;temp_fds)) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 检查是否是已经连接的客户端发来的数据</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (i != server_fd) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="type">int</span> valread = <span class="built_in">read</span>(i , buffer, BUFFER_SIZE);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (valread == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 客户端断开了连接</span></span><br><span class="line"></span><br><span class="line">                        <span class="built_in">close</span>(i);</span><br><span class="line"></span><br><span class="line">                           <span class="built_in">FD_CLR</span>(i, &amp;read_fds); <span class="comment">// 从文件描述符集合中移除</span></span><br><span class="line"></span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (valread &lt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 发生了读取错误</span></span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (errno != EAGAIN) &#123;</span><br><span class="line"></span><br><span class="line">                            <span class="built_in">perror</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line"></span><br><span class="line">                            <span class="built_in">close</span>(i);</span><br><span class="line"></span><br><span class="line">                            <span class="built_in">FD_CLR</span>(i, &amp;read_fds);</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 从客户端收到了数据，可以在这里处理</span></span><br><span class="line"></span><br><span class="line">                        buffer[valread] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;Received: %s\n&quot;</span>, buffer);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 回写数据到客户端（Echo服务器）</span></span><br><span class="line"></span><br><span class="line">                        <span class="built_in">send</span>(i, buffer, valread, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭监听的 socket 描述符</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(server_fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Poll-的思路"><a href="#Poll-的思路" class="headerlink" title="Poll 的思路"></a>Poll 的思路</h4><p>Poll 思路上和 select 是相近的，由于 select 他设置为 1024 个最大连接数量，这个是设定好的，由于考虑到兼容性以及并发的需要，所以出了 poll 这种理论上无限连接的模式。</p><p>实现：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 9999</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_CLIENTS 256</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">make_socket_non_blocking</span><span class="params">(<span class="type">int</span> fd)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> flags = <span class="built_in">fcntl</span>(fd, F_GETFL, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flags == <span class="number">-1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fcntl&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    flags |= O_NONBLOCK;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fcntl</span>(fd, F_SETFL, flags) == <span class="number">-1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fcntl&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> server_fd, new_socket;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> address;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> addrlen = <span class="built_in">sizeof</span>(address);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buffer[BUFFER_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((server_fd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="built_in">make_socket_non_blocking</span>(server_fd);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">setsockopt</span>(server_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &amp;opt, <span class="built_in">sizeof</span>(opt))) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;setsockopt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line"></span><br><span class="line">    address.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    address.sin_port = <span class="built_in">htons</span>(PORT);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bind</span>(server_fd, (<span class="keyword">struct</span> sockaddr *)&amp;address, <span class="built_in">sizeof</span>(address)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;bind failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">listen</span>(server_fd, <span class="number">3</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">pollfd</span> fds[MAX_CLIENTS];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> nfds = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    fds[<span class="number">0</span>].fd = server_fd;</span><br><span class="line"></span><br><span class="line">    fds[<span class="number">0</span>].events = POLLIN;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> poll_count = <span class="built_in">poll</span>(fds, nfds, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (poll_count &lt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;poll&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nfds; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (fds[i].revents &amp; POLLIN) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (fds[i].fd == server_fd) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> ((new_socket = <span class="built_in">accept</span>(server_fd, (<span class="keyword">struct</span> sockaddr *)&amp;address, (<span class="type">socklen_t</span>*)&amp;addrlen)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="built_in">perror</span>(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="built_in">make_socket_non_blocking</span>(new_socket);</span><br><span class="line"></span><br><span class="line">                    fds[nfds].fd = new_socket;</span><br><span class="line"></span><br><span class="line">                    fds[nfds].events = POLLIN;</span><br><span class="line"></span><br><span class="line">                    nfds++;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="type">int</span> valread = <span class="built_in">read</span>(fds[i].fd, buffer, BUFFER_SIZE);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (valread == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="built_in">close</span>(fds[i].fd);</span><br><span class="line"></span><br><span class="line">                        fds[i].fd = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (valread &lt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (errno != EAGAIN) &#123;</span><br><span class="line"></span><br><span class="line">                            <span class="built_in">perror</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line"></span><br><span class="line">                            <span class="built_in">close</span>(fds[i].fd);</span><br><span class="line"></span><br><span class="line">                            fds[i].fd = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                        buffer[valread] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;Received: %s\n&quot;</span>, buffer);</span><br><span class="line"></span><br><span class="line">                        <span class="built_in">send</span>(fds[i].fd, buffer, valread, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nfds; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (fds[i].fd == <span class="number">-1</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; nfds - <span class="number">1</span>; j++) &#123;</span><br><span class="line"></span><br><span class="line">                    fds[j] = fds[j + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                nfds--;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(server_fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Epoll-的思路"><a href="#Epoll-的思路" class="headerlink" title="Epoll 的思路"></a>Epoll 的思路</h4><p>Epoll 的思路是想要解决掉上述的 select/poll 的轮训，因为 isset 在辅助我们判断缓冲区是否好的前提是内核已经帮我们处理了对每一个缓冲区是否有数据进行一个判断，而这个操作也是十分消耗资源的，特别是连接一多的情况下，那么我们需要在内核轮询的也就更多了。</p><p>那么有没有一种不需要轮询的操作呢，那么就是我们直接对我们的每一个 fd 进行一个单一的监听，然后如果这个监听监听到数据就把 fd 放到就绪的空间内，然后我们需要的时候直接从这个区域中取出来就可以了，就不需要去轮询是否有数据。</p><p>而 <code>epoll</code> 通过以下步骤优化了这一过程：</p><ol><li>使用 <code>epoll_create</code> 创建一个 <code>epoll</code> 实例，这个实例将被用来存储和跟踪各个文件描述符的状态。</li><li>通过 <code>epoll_ctl</code> 添加或修改文件描述符的监听事件。这个调用使得内核得以知道哪些文件描述符被监控以及监控哪种类型的事件。</li><li>当调用 <code>epoll_wait</code> 时，此函数会阻塞直到至少有一个监控的文件描述符发生了事件。与 <code>select</code> 或 <code>poll</code> 不同的是，<code>epoll_wait</code> 已经不需要遍历所有文件描述符，而是直接返回那些已经触发事件的文件描述符。这样大大减少了不必要的检查和等待时间。</li></ol><p>也就是使用 epollcreate 创建一个代理对象，这个相当于是 select 的 select 函数的调用，拥有等待，就绪的队列，用于存放 sock，如果此时执行 epoll_wait 就会把当前的 sock 添加到等待队列当中，如果是网卡接受到数据的时候会向 cpu 发出中断，这个中断执行指令，把对应的 sock 索引从等待队列添加到就绪队列，此时会重新唤起我们的进程，此时 epoll_wait 就会解除阻塞，同时返回我们的就绪队列，我们可以根据就绪队列来获得所有已经就绪的 sock，之后随便我们来 read，或者 send</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 9999</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_EVENTS 256</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">make_socket_non_blocking</span><span class="params">(<span class="type">int</span> fd)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> flags = <span class="built_in">fcntl</span>(fd, F_GETFL, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (flags == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fcntl&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    flags |= O_NONBLOCK;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fcntl</span>(fd, F_SETFL, flags) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fcntl&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> server_fd, new_socket;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> address;</span><br><span class="line">    <span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> addrlen = <span class="built_in">sizeof</span>(address);</span><br><span class="line">    <span class="type">char</span> buffer[BUFFER_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    server_fd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (server_fd == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">make_socket_non_blocking</span>(server_fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">setsockopt</span>(server_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &amp;opt, <span class="built_in">sizeof</span>(opt))) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;setsockopt&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    address.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    address.sin_port = <span class="built_in">htons</span>(PORT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bind</span>(server_fd, (<span class="keyword">struct</span> sockaddr *)&amp;address, <span class="built_in">sizeof</span>(address)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;bind failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">listen</span>(server_fd, <span class="number">3</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> epoll_fd = <span class="built_in">epoll_create1</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (epoll_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;epoll_create1&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> event;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> events[MAX_EVENTS];</span><br><span class="line"></span><br><span class="line">    event.events = EPOLLIN;</span><br><span class="line">    event.data.fd = server_fd;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">epoll_ctl</span>(epoll_fd, EPOLL_CTL_ADD, server_fd, &amp;event) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;epoll_ctl: server_fd&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> n = <span class="built_in">epoll_wait</span>(epoll_fd, events, MAX_EVENTS, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;epoll_wait&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (events[i].data.fd == server_fd) &#123;</span><br><span class="line">                <span class="keyword">while</span> ((new_socket = <span class="built_in">accept</span>(server_fd, (<span class="keyword">struct</span> sockaddr *)&amp;address, (<span class="type">socklen_t</span>*)&amp;addrlen)) != <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="built_in">make_socket_non_blocking</span>(new_socket);</span><br><span class="line">                    event.events = EPOLLIN | EPOLLET;</span><br><span class="line">                    event.data.fd = new_socket;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">epoll_ctl</span>(epoll_fd, EPOLL_CTL_ADD, new_socket, &amp;event) == <span class="number">-1</span>) &#123;</span><br><span class="line">                        <span class="built_in">perror</span>(<span class="string">&quot;epoll_ctl: add&quot;</span>);</span><br><span class="line">                        <span class="built_in">close</span>(new_socket);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (errno != EAGAIN &amp;&amp; errno != EWOULDBLOCK) &#123;</span><br><span class="line">                    <span class="built_in">perror</span>(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> done = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="type">ssize_t</span> count = <span class="built_in">read</span>(events[i].data.fd, buffer, BUFFER_SIZE - <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span> (count == <span class="number">-1</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (errno != EAGAIN) &#123;</span><br><span class="line">                            <span class="built_in">perror</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                            done = <span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                        done = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    buffer[count] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Received: %s\n&quot;</span>, buffer);</span><br><span class="line">                    <span class="built_in">send</span>(events[i].data.fd, buffer, count, <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (done) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Closed connection on descriptor %d\n&quot;</span>, events[i].data.fd);</span><br><span class="line">                    <span class="built_in">close</span>(events[i].data.fd);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(server_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div class="tabs" id="uniquename6"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename6-1"><i class="icon"></i>总结</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename6-1"><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>事实上，上面的 io 复用都是基于单线程的情况下处理大量并发，但是为缓解线程压力也可以引入多线程来分担线程压力。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>]]></content>
    
    
    <summary type="html">Socket</summary>
    
    
    
    <category term="Socket" scheme="https://huanxueblog.top/categories/Socket/"/>
    
    
    <category term="Socket" scheme="https://huanxueblog.top/tags/Socket/"/>
    
  </entry>
  
  <entry>
    <title>2023年度总结</title>
    <link href="https://huanxueblog.top/posts/62c6c373.html"/>
    <id>https://huanxueblog.top/posts/62c6c373.html</id>
    <published>2024-01-10T10:26:39.000Z</published>
    <updated>2024-01-10T15:31:16.782Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><div class="tabs" id="uniquename1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename1-1"><i class="icon"></i>前言</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename1-1"><p>本文记录关于我这一年的学习情况，大多数以obsidian的笔记作为主线，希望通过这条主线快速地回顾这一年的进程。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h3 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h3><div class="tabs" id="uniquename2"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename2-1"><i class="icon"></i>回顾</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename2-1"><div class="timeline undefined"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>2023</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>04-10</p></div></div><div class='timeline-item-content'><p>CSAPP</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>05-7</p></div></div><div class='timeline-item-content'><p>数据结构</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>08-10</p></div></div><div class='timeline-item-content'><p>侯捷面向对象</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>09-18</p></div></div><div class='timeline-item-content'><p>c++ Primer</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>09-25</p></div></div><div class='timeline-item-content'><p>侯捷STL源码剖析</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>10-1</p></div></div><div class='timeline-item-content'><p>Effective modern C++</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>10-20</p></div></div><div class='timeline-item-content'><p>Effective C++</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>11-10</p></div></div><div class='timeline-item-content'><p>计算机网络</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>11-25</p></div></div><div class='timeline-item-content'><p>More effective c++</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>12-05</p></div></div><div class='timeline-item-content'><p>拥有第一个博客</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>12-13</p></div></div><div class='timeline-item-content'><p>拥有第二个博客</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>12-23</p></div></div><div class='timeline-item-content'><p>CS144</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>12-30</p></div></div><div class='timeline-item-content'><p>git学习</p></div></div></div><div class="timeline undefined"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>2024</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>1-7</p></div></div><div class='timeline-item-content'><p>CMake学习</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>1-7</p></div></div><div class='timeline-item-content'><p>图论</p></div></div></div></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><p><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/动画-min.gif" alt=""></p><h3 id="心里话"><a href="#心里话" class="headerlink" title="心里话"></a>心里话</h3><div class="tabs" id="uniquename3"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename3-1"><i class="icon"></i>心里话</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename3-1"><p>回顾这一年我感觉学得是挺多的，但是很多的书籍仍然需要去沉淀，慢慢挖掘其中的深邃。然后对于平时，个人感觉也是挺水的，如果多努力一点可能能对知识掌握更深更广。希望24年能更好的努力吧，项目是一个没做，太卢瑟了，加油加油！</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>]]></content>
    
    
    <summary type="html">CMake</summary>
    
    
    
    <category term="年度" scheme="https://huanxueblog.top/categories/%E5%B9%B4%E5%BA%A6/"/>
    
    
    <category term="总结" scheme="https://huanxueblog.top/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>CMake_opencv</title>
    <link href="https://huanxueblog.top/posts/undefined.html"/>
    <id>https://huanxueblog.top/posts/undefined.html</id>
    <published>2024-01-08T12:24:53.000Z</published>
    <updated>2024-01-08T12:39:24.315Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><div class="tabs" id="uniquename1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename1-1"><i class="icon"></i>前言</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename1-1"><p>这部分是关于如何入门地通过cmake使用opencv</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><div class="tabs" id="uniquename2"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename2-1"><i class="icon"></i>实践</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename2-1"><p>首先你需要在文件下创建：<br><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/adffgsgdsg.png" alt="[Pasted image 20231223114216.png]"><br><code>main.cpp</code> 的源码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    Mat srcImg = <span class="built_in">imread</span>(<span class="string">&quot;.jpg&quot;</span>); <span class="comment">// 尝试读取图片</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (srcImg.<span class="built_in">empty</span>()) &#123; <span class="comment">// 检查图片是否正确载入</span></span><br><span class="line"></span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Error: Image cannot be loaded!&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    string windowName = <span class="string">&quot;Image Display&quot;</span>; <span class="comment">// 明确窗口名</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">namedWindow</span>(windowName, WINDOW_KEEPRATIO); <span class="comment">// 创建窗口</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">imshow</span>(windowName, srcImg); <span class="comment">// 在窗口里显示图像</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="built_in">waitKey</span>(<span class="number">0</span>); <span class="comment">// 等待按键</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你需要的就是编写 <code>CMakeLists.txt</code> 的代码 </p><p>通过头文件可以知道我们需要找到我们的头文件：<code>opencv.hpp</code>，它在：<code>opencv\opencv\build\include\opencv2</code><br>然后需要用到 lib 文件，它在：<br><code>/opencv/build/x64/vc16/lib/opencv_world480d.lib</code></p><p>然后后面的你可以自己写下 <code>CMakeLists.txt</code> 的代码，自己运行和加入对应的 dll 文件就可以运行了<br>想自己写的可以暂停了</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include_directories</span>(D:/Users/<span class="number">27599</span>/Desktop/software/opencv/opencv/build/<span class="keyword">include</span>)<span class="comment">#找头文件的位置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(lesson2_opencv main.cpp)<span class="comment">#构建项目</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(lesson2_opencv D:/Users/<span class="number">27599</span>/Desktop/software/opencv/opencv/build/x64/vc16/lib/opencv_world480d.lib)<span class="comment">#连接静态库</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/sadasfasfs.png" alt="[Pasted image 20231223115014.png]"><br><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/WP`TR8BMWYHT.png" alt="[Pasted image 20231223115111.png]"></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>]]></content>
    
    
    <summary type="html">CMake</summary>
    
    
    
    <category term="CMake" scheme="https://huanxueblog.top/categories/CMake/"/>
    
    
    <category term="CMake" scheme="https://huanxueblog.top/tags/CMake/"/>
    
  </entry>
  
  <entry>
    <title>CMake优雅地使用环境变量</title>
    <link href="https://huanxueblog.top/posts/6f6925cb.html"/>
    <id>https://huanxueblog.top/posts/6f6925cb.html</id>
    <published>2024-01-08T12:23:27.000Z</published>
    <updated>2024-01-08T12:39:06.057Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><div class="tabs" id="uniquename1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename1-1"><i class="icon"></i>前言</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename1-1"><p>本文只是关于如何配置他人已经包装好的软件配置路径。<br>由于每一个电脑的安装路径都不一样，所以如果为了保证 <code>CMakelists.txt</code> 可以在其他电脑上复用，需要用到环境变量，代替曾经用绝对路径的情况</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><div class="tabs" id="uniquename2"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename2-1"><i class="icon"></i>配置</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename2-1"><p>配置需要通过 <code>find_package(OpenCV REQUIRED)</code> 到环境变量中从上到下依次寻找路径，找到便退出。</p><p>在我们的 <code>xxx.cmake</code> 中会有关于如何设置 <code>CMakelists.txt</code> 的配置<br>例如 <code>OpenCV</code> 的 <code>OpenCVConfig.cmake</code> ：<img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/adfawfaw.png" alt="[Pasted image 20231228102620.png]"></p><p>将他们找到，然后注意三个部分，<code>find_package</code> 找到路径 <code>add_executable</code> 写可执行文件 <code>target_include_directories</code> 链接头  <code>target_link_libraries</code> 链接库</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(OpenCV REQUIRED)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(lesson4_opencv main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_include_directories</span>(lesson4_opencv PRIVATE <span class="variable">$&#123;OpenCV_INCLUDE_DIRS&#125;</span>)</span><br><span class="line"><span class="comment">#`$` + `&#123;&#125;` 是 cmake 里的变量</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(lesson4_opencv <span class="variable">$&#123;OpenCV_LIBS&#125;</span>)</span><br></pre></td></tr></table></figure><p>就可以了</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>]]></content>
    
    
    <summary type="html">CMake</summary>
    
    
    
    <category term="CMake" scheme="https://huanxueblog.top/categories/CMake/"/>
    
    
    <category term="CMake" scheme="https://huanxueblog.top/tags/CMake/"/>
    
  </entry>
  
  <entry>
    <title>CMake常用指令推荐</title>
    <link href="https://huanxueblog.top/posts/a767a042.html"/>
    <id>https://huanxueblog.top/posts/a767a042.html</id>
    <published>2024-01-08T12:18:35.000Z</published>
    <updated>2024-01-08T12:39:12.522Z</updated>
    
    <content type="html"><![CDATA[<div class="table-container"><table><thead><tr><th>指令</th><th>描述</th><th>推荐</th><th>备注</th></tr></thead><tbody><tr><td><code>include_directories</code></td><td>在构建目标之前，为所有的目标添加头文件搜索路径。</td><td></td><td>非 target-specific，会影响整个 CMake 项目的所有目标。</td></tr><tr><td><code>target_include_directories</code></td><td>为特定的构建目标添加头文件搜索路径。</td><td>✅</td><td>target-specific，只影响指定的目标。</td></tr><tr><td><code>link_directories</code></td><td>在构建目标之前，添加库文件搜索路径。</td><td></td><td>非 target-specific，会影响之后定义的所有目标。但通常不推荐使用，因为它不提供精确的依赖关系。</td></tr><tr><td><code>target_link_libraries</code></td><td>为特定的构建目标链接一个或多个库。</td><td>✅</td><td>target-specific，只影响指定的目标，并且可以指定私有（<code>PRIVATE</code>）、接口（<code>INTERFACE</code>）或公共（<code>PUBLIC</code>）链接。</td></tr><tr><td><code>add_definitions</code></td><td>添加编译器定义（如预处理器定义）。</td><td></td><td>非 target-specific，会影响整个 CMake 项目的所有目标。</td></tr><tr><td><code>target_compile_definitions</code></td><td>为特定目标添加编译器定义。</td><td>✅</td><td>target-specific，允许为不同的 target 添加不同的编译器定义。</td></tr><tr><td><code>add_compile_options</code></td><td>添加编译器选项。</td><td></td><td>非 target-specific，会影响整个 CMake 项目的所有目标。</td></tr><tr><td><code>target_compile_options</code></td><td>为特定目标添加编译器选项。</td><td>✅</td><td>target-specific，允许为不同的 target 定制编译选项。</td></tr></tbody></table></div>]]></content>
    
    
    <summary type="html">CMake</summary>
    
    
    
    <category term="CMake" scheme="https://huanxueblog.top/categories/CMake/"/>
    
    
    <category term="CMake" scheme="https://huanxueblog.top/tags/CMake/"/>
    
  </entry>
  
  <entry>
    <title>CMake降低耦合</title>
    <link href="https://huanxueblog.top/posts/439c322c.html"/>
    <id>https://huanxueblog.top/posts/439c322c.html</id>
    <published>2024-01-08T12:09:51.000Z</published>
    <updated>2024-01-08T12:39:10.007Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><div class="tabs" id="uniquename1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename1-1"><i class="icon"></i>前言</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename1-1"><p>这节课中的依赖是狭义的认为不需要提供的库不链接，换一句话说只有当前库中有调用另一个库的函数那么构成依赖。</p><h4 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h4><p>做法是将源代码文件（在这个案例中是 <code>.cpp</code> 文件，对于 C 项目将是 <code>.c</code> 文件）编译并打包成库文件。然后添加访问权级，让库可以被其他部分的项目代码链接和使用。<br>Cmake 权级如下：</p><div class="table-container"><table><thead><tr><th>范围</th><th>目标构建时</th><th>链接目标时</th><th>描述</th></tr></thead><tbody><tr><td>PRIVATE</td><td>是</td><td>否</td><td>目标私有，库或路径仅用于构建当前目标，在当前目标的外部不可见。</td></tr><tr><td>INTERFACE</td><td>否</td><td>是</td><td>目标接口，用于目标接口的库或路径不直接用于构建目标，但会传递给链接此目标的其他目标。</td></tr><tr><td>PUBLIC</td><td>是</td><td>是</td><td>两者兼而有之，库或路径用于构建当前目标，且会传递给任何链接了该目标的其他目标。</td></tr><tr><td></td><td></td><td></td></tr></tbody></table></div><p><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/7AUU.png" alt="[Pasted image 20231227225906.png]"></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h3 id="课程文件"><a href="#课程文件" class="headerlink" title="课程文件"></a>课程文件</h3><div class="tabs" id="uniquename2"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename2-1"><i class="icon"></i>课程文件</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename2-1"><p>以下是（比飞鸟贵重的多_HKL）up 教程里的各个文件代码<br><code>add.hh</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">int add(int a, int b);</span><br></pre></td></tr></table></figure><p><code>add.cpp</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printResult</span>(x + y);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>calculator.h</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Calculator</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    int calcAdd(int x, int y);</span><br><span class="line"></span><br><span class="line">    int calcSub(int x, int y);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>calculator.cpp</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;calculator.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;add.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sub.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Calculator::calcAdd</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">add</span>(x, y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Calculator::calcSub</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sub</span>(x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>common.h</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">void printResult(int a);</span><br></pre></td></tr></table></figure><p><code>common.cpp</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printResult</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;result is: &quot;</span> &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sub.h</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">int sub(int a, int b);</span><br></pre></td></tr></table></figure><p><code>sub.cpp</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printResult</span>(a - b);</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h3 id="文件关系处理"><a href="#文件关系处理" class="headerlink" title="文件关系处理"></a>文件关系处理</h3><div class="tabs" id="uniquename3"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename3-1"><i class="icon"></i>文件关系处理</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename3-1"><p><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/MIUP.png" alt="[Pasted image 20231227231456.png]"><br>我们希望的是每一个库只取自己需要的部分来减轻依赖，而不是<br><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/CF`U~REL.png" alt="[Pasted image 20231227231627.png]"><br>这就要求我们对 cmakelists 进行配置</p><p>这是 add 的 <code>CMakelists.txt</code> 配置+解释</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># add_library(add STATIC add.cpp)</span><br><span class="line"></span><br><span class="line">#[[这行代码创建了一个名为 add 的静态库。静态库与动态库（共享库）不同，是将代码直接嵌入到最终可执行文件中。由于这个静态库在链接时会全部复制到最终的可执行文件，它不会在运行时引入额外的依赖性。]]</span><br><span class="line"></span><br><span class="line"># target_link_libraries(add PRIVATE common)</span><br><span class="line"></span><br><span class="line">#[[这行代码指定了库 add 链接了另一个库，这里假设为 common。使用 PRIVATE 关键字表示 common 库的链接仅仅对 add 库内部实现是必需的，而不会影响那些链接了 add 库的上层目标（比如可执行文件或其他库）。也就是说，对于链接了 add 的上层目标来说，common 这个依赖是看不见的，降低了这个依赖的传播。]]</span><br><span class="line"></span><br><span class="line"># target_include_directories(add PUBLIC ./)</span><br><span class="line"></span><br><span class="line">#[[这行代码设置了 add 库的公开头文件路径。使用 PUBLIC 关键字意味着如果一个目标链接了 add 库，那么这个目标也会自动具有对 add 公开头文件的访问权。这里 ./ 指的可能是库源代码的根目录。这样使得任何链接了 add 的上层目标都会正确地找到这个库的头文件，而不需要这些上层目标自己再去指定包含路径。这减少了使用 add 库的上层目标的配置负担，因为它们不需要知道 add 库头文件的具体位置。]]</span><br></pre></td></tr></table></figure><p>一共三句话，构建库，指出依赖对象和权级，提供头文件路径。<br><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/X04XCF.png" alt="[Pasted image 20231227232305.png]"></p><p>依次配置四个文件的 <code>CMakelists.txt</code> 即可减小依赖。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h3 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h3><div class="tabs" id="uniquename4"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename4-1"><i class="icon"></i>后续</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename4-1"><p><code>main.cpp</code> 的同级下配置以下，以提供 cmake 路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># add_subdirectory(common)</span><br><span class="line"># add_subdirectory(add)</span><br><span class="line"># add_subdirectory(sub)</span><br><span class="line"># add_subdirectory(calculator)</span><br></pre></td></tr></table></figure><p>构建可执行文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># add_executable(lesson3_1 main.cpp)</span><br><span class="line"></span><br><span class="line"># target_link_libraries(lesson3_1 calculator)</span><br></pre></td></tr></table></figure><p>Q 1：<br>为什么 main 函数不需要构建静态库<br>A 1：<br>由于 <code>main</code> 函数是程序的起始点，它不是用于被其他函数或程序调用的，并不需要作为库中的一部分。库（无论是静态的还是动态的）是一组代码，其目的在于提供给其他程序调用，以实现代码复用或分离等目的。一个静态库或动态库包含了可以被各种不同程序重用的函数和数据。</p><p>最后顶级 <code>CMakelists.txt</code> 加上即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_subdirectory(lesson3_1)#去寻找cmake文件</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>]]></content>
    
    
    <summary type="html">CMake</summary>
    
    
    
    <category term="CMake" scheme="https://huanxueblog.top/categories/CMake/"/>
    
    
    <category term="CMake" scheme="https://huanxueblog.top/tags/CMake/"/>
    
  </entry>
  
  <entry>
    <title>CMake在linux和win的运行执行文件不同之处</title>
    <link href="https://huanxueblog.top/posts/aaea630f.html"/>
    <id>https://huanxueblog.top/posts/aaea630f.html</id>
    <published>2024-01-08T12:06:06.000Z</published>
    <updated>2024-01-08T12:07:56.218Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言-："><a href="#前言-：" class="headerlink" title="前言 ："></a>前言 ：</h3><div class="tabs" id="uniquename1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename1-1"><i class="icon"></i>前言 ：</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename1-1"><p>通过之前的文章应该了解到 linux 系统和 win 系统对于构建 cpp 文件的差别也是很大的。<br>这里补充一下执行文件的不同之处：</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h3 id="CMake在linux和win的运行执行文件不同之处"><a href="#CMake在linux和win的运行执行文件不同之处" class="headerlink" title="CMake在linux和win的运行执行文件不同之处"></a>CMake在linux和win的运行执行文件不同之处</h3><div class="tabs" id="uniquename2"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename2-1"><i class="icon"></i>CMake在linux和win的运行执行文件不同之处</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename2-1"><h4 id="Linux-的优点"><a href="#Linux-的优点" class="headerlink" title="Linux 的优点"></a>Linux 的优点</h4><p>Linux 下是有保存同级 <code>CMakelists.txt</code> 的 target_link_libraries 路径<br><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/asdfafsefdhf.png" alt="[Pasted image 20231226152958.png]"><br>而 windows 是没有保存路径的 <code>.exe</code> 必须要配合 <code>.dll</code> 文件，linux 的可执行文件是可以自寻路径的</p><h4 id="Windows-搜索路径"><a href="#Windows-搜索路径" class="headerlink" title="Windows 搜索路径"></a>Windows 搜索路径</h4><p>通过隐式和显式链接，Windows 首先搜索“已知 DLL”，如 Kernel 32. Dll 和 User 32. Dll。Windows 然后按下列顺序搜索 DLL：</p><ol><li>当前进程的可执行模块所在的目录。</li><li>当前目录。 </li><li>Windows 系统目录。GetSystemDirectory 函数检索此目录的路径。</li><li>Windows 目录。GetWindowsDirectory 函数检索此目录的路径。 </li><li>PATH 环境变量中列出的目录。</li></ol></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h3 id="Linux-搜索路径"><a href="#Linux-搜索路径" class="headerlink" title="Linux 搜索路径"></a>Linux 搜索路径</h3><div class="tabs" id="uniquename3"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename3-1"><i class="icon"></i>Linux 搜索路径</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename3-1"><p>Linux 搜索的先后顺序是： </p><ol><li>编译目标代码时指定的动态库搜索路径</li><li>环境变量 LD_LIBRARY_PATH 指定的动态库搜索路径</li><li>配置文件/etc/ld. So. Conf 中指定的动态库搜索路径</li><li>默认的动态库搜索路径/lib</li></ol></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>]]></content>
    
    
    <summary type="html">CMake</summary>
    
    
    
    <category term="CMake" scheme="https://huanxueblog.top/categories/CMake/"/>
    
    
    <category term="CMake" scheme="https://huanxueblog.top/tags/CMake/"/>
    
  </entry>
  
  <entry>
    <title>CMake动态库</title>
    <link href="https://huanxueblog.top/posts/cawdawda5465745.html"/>
    <id>https://huanxueblog.top/posts/cawdawda5465745.html</id>
    <published>2024-01-08T11:45:53.000Z</published>
    <updated>2024-01-08T12:39:18.907Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><div class="tabs" id="uniquename1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename1-1"><i class="icon"></i>前言</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename1-1"><p>相比较于静态库，动态库需要的是得到一些运行时的量，这是和静态库本质的区别</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h3 id="实现动态库"><a href="#实现动态库" class="headerlink" title="实现动态库"></a>实现动态库</h3><div class="tabs" id="uniquename2"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename2-1"><i class="icon"></i>实现动态库</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename2-1"><ul><li>确认平台<ul><li>我们配置动态库要注意是在什么平台下，如果是在 win 下需要有静态库作为帮手，把动态库导入</li><li>Windows 和 Linux 在处理静态库和动态库（也称为共享库）时有一些差异，这主要归因于它们的链接和加载机制的不同。这些差异影响了在各自平台上构建和运行程序的方式。</li></ul></li></ul></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h3 id="Windows-平台："><a href="#Windows-平台：" class="headerlink" title="Windows 平台："></a>Windows 平台：</h3><div class="tabs" id="uniquename3"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename3-1"><i class="icon"></i>Windows 平台：</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename3-1"><ol><li><p><strong>静态库（. Lib）：</strong></p><ul><li>在 Windows 上，静态库通常以 <code>.lib</code> 文件形式出现。</li><li>当程序编译时，静态库的内容被复制到最终的可执行文件（<code>.exe</code>）中。</li><li>因此，部署时不需要静态库文件，因为所有必需的代码都包含在 <code>.exe</code> 文件内。</li></ul></li><li><p><strong>动态链接库（DLL，. Dll）：</strong></p><ul><li>动态链接库（Dynamic Link Libraries, DLLs）是 Windows 上的共享库。</li><li>程序在运行时动态地链接到这些库，而不是在编译时。</li><li>这意味着，为了运行程序，必须有相应的 <code>.dll</code> 文件在可访问的路径上，例如程序所在目录或系统目录。</li></ul></li></ol><p>在 Windows 上，有时即使使用动态库，也需要一个小型的静态库（通常称为导入库），它包含了定位和链接到动态库的指令。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h3 id="Linux-平台："><a href="#Linux-平台：" class="headerlink" title="Linux 平台："></a>Linux 平台：</h3><div class="tabs" id="uniquename4"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename4-1"><i class="icon"></i>Linux 平台：</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename4-1"><ol><li><p><strong>静态库（. A）：</strong></p><ul><li>Linux 上的静态库通常以 <code>.a</code> 文件形式存在。</li><li>与 Windows 类似，静态库的内容在编译时被包含到最终的可执行文件中。</li><li>运行程序时不需要静态库文件。</li></ul></li><li><p><strong>共享库（. So）：</strong></p><ul><li>Linux 上的共享库通常是 <code>.so</code>（shared object）文件。</li><li>Linux 上的动态链接处理比 Windows 更灵活。程序可以直接链接到共享库，不需要额外的静态导入库。</li><li>运行时需要能够访问这些共享库，但不需要编译时的静态库。</li></ul></li></ol></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><div class="tabs" id="uniquename5"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename5-1"><i class="icon"></i>总结：</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename5-1"><ul><li>Windows 平台上，静态库（. Lib）通常是必需的，即使是对于动态链接的情况（通过导入库）。而动态库（. Dll）在运行时必须可用。</li><li>Linux 平台上，静态库（. A）用于完全静态链接的情况，共享库（. So）用于动态链接。动态链接在 Linux 上不依赖于编译时的静态库。</li></ul><p>这些差异反映了不同操作系统平台的底层架构和设计哲学。</p><ul><li>Win 下如何导入动态库<ul><li>当我们需要 dll 时，在 <code>.cpp</code> 文件的同级 cmakelists 下添加 SHARED 如下</li><li><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/adawjdoiawjodia.png" alt="[Pasted image 20231223100002.png]"></li><li>就可以生成 dll 文件</li><li><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/adawjdoiawjodia2.png" alt="[YXOPng]"></li><li>但是问题在于，构建 exe 的时候会发生损坏</li><li><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/adawjdoiawjodia3.png" alt="[ZKN 6OL~XG 9 B 1. Png]"></li><li></li><li>原因上面讲过，所以在 win 平台下我们需要加上 <code>__declspec(dllexport)</code> 到 <code>.cpp·</code> 文件以生成静态库帮助导入动态库</li><li><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/adawjdoiawjodia4.png" alt="[Pasted image 20231223094956.png]"></li><li>如果没有加上就会出现文件损毁</li><li><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/2342354234.png" alt="[ZKN ng]"></li><li>当我们加上后，在 cmakelists 中添加静态位置，再次进行构建就可以出现 exe 可执行文件 <img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/adawjdoiawjodia3.png" alt="[Pasted image 20231223095724.png]"></li></ul></li></ul></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h3 id="Win-下如何优雅地导入动态库"><a href="#Win-下如何优雅地导入动态库" class="headerlink" title="Win 下如何优雅地导入动态库"></a>Win 下如何优雅地导入动态库</h3><div class="tabs" id="uniquename6"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename6-1"><i class="icon"></i>Win 下如何优雅地导入动态库</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename6-1"><ol><li>为了优雅地引入 <code>__declspec(dllexport)</code>，需要去通过宏定义的方式去实现 <code>#define CMAKE_STUDY_API __declspec(dllimport)</code> 这样我们就可以通添加 CMAKE_STUDY_API 来使得程序更加易读</li><li>如果在编译 DLL 的时候定义了，那么会被定义为，这意味着随后所有标记了这个宏的类和函数都是要被导出的。<code>EXPORT``EXPORT``CMAKE_STUDY_API``__declspec(dllexport)</code></li><li>如果没有定义，意味着当前你可能在编译使用 DLL 的应用程序而非 DLL 本身。此时会被定义为，标记的类和函数表示从 DLL 中导入。<code>EXPORT``CMAKE_STUDY_API``__declspec(dllimport)</code></li></ol><p>例如，在 DLL 的项目中你可能会这样写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Define EXPORT when compiling the DLL</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXPORT  <span class="comment">// This is typically done in the project settings not in the code directly</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;your_header.h&quot;</span>  <span class="comment">// The header file containing the CMAKE_STUDY_API macro</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">CMAKE_STUDY_API <span class="type">void</span> <span class="title">SomeFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Function implementation that is to be exported from the DLL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，在使用这个 DLL 的其他项目中，你不定义，则会变成用于导入的宏：<code>EXPORT``CMAKE_STUDY_API</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// No EXPORT defined here, as we&#x27;re using the DLL</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;your_header.h&quot;</span>  <span class="comment">// The header file containing the CMAKE_STUDY_API macro</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UseSomeFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">SomeFunction</span>();  <span class="comment">// Call the function imported from the DLL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h3 id="Win-下如何表示导出导入-dll"><a href="#Win-下如何表示导出导入-dll" class="headerlink" title="Win 下如何表示导出导入 dll"></a>Win 下如何表示导出导入 dll</h3><div class="tabs" id="uniquename7"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename7-1"><i class="icon"></i>Win 下如何表示导出导入 dll</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename7-1"><p>在 Windows 操作系统中，有两种特殊的程序文件叫做 DLL（动态链接库）文件：</p><ol><li><p><strong>导出（Export）</strong>：想象一个工厂，它生产各种零件。这个工厂希望其他工厂或商店能够买到它的零件，所以它需要告诉大家：“这些是我制作的零件，欢迎购买！” 在程序中，如果你制作了一个 DLL，并且你希望其他程序能使用 DLL 里面的功能（函数、变量等），你需要“导出”这些功能。</p></li><li><p><strong>导入（Import）</strong>：现在想象你运营着另外一个工厂，你需要购买之前那个工厂的零件来制造你的产品。那么你就需要“导入”那些零件。在程序中，如果你的程序想要使用其他 DLL 文件里的功能，你就需要“导入”这些功能。</p></li></ol><p>在 C++中，为了告诉电脑哪些功能是要被导出的，哪些是要被导入的，我们需要使用一些特殊的关键字。在 Windows 中，我们用 <code>__declspec(dllexport)</code> 来标识要导出的功能，用 <code>__declspec(dllimport)</code> 来标识要导入的功能。</p><p>所以当我们结合上面通过宏的=来优化，我们可以写下 <code>export.h</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> EXPORT</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMAKE_STUDY_API __declspec(dllexport)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMAKE_STUDY_API __declspec(dllimport)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>代码段：</p><ul><li>当在制作 DLL 文件时，你会在你的代码中定义一个叫 <code>EXPORT</code> 的宏。这个宏只在制作 DLL 文件时使用。</li><li><code>CMAKE_STUDY_API</code> 这个宏将会根据是否定义了 <code>EXPORT</code> 来改变它的行为：<ul><li>如果定义了 <code>EXPORT</code>（意味着你正在制作 DLL），<code>CMAKE_STUDY_API</code> 就代表 <code>__declspec(dllexport)</code>，标识功能为“出售”状态。</li><li>如果没有定义 <code>EXPORT</code>（意味着你在使用别人的 DLL），<code>CMAKE_STUDY_API</code> 就代表 <code>__declspec(dllimport)</code>，标识功能为“购买”状态。</li></ul></li></ul><p>所以，<code>CMAKE_STUDY_API</code> 是一个切换开关，它可以根据你是正在制作还是使用 DLL，来切换为相应的状态。以上都是作为开发者需要知道的，而用户无需知道的，导入导出的作用就是为了运行的时候 dll 可以连接找到我们的函数。</p><p>经过以上，我们就可以放把 dll 到 bin 当中，以及头文件, 以提供给用户：<br><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/adawjdoiawjodia5.png" alt="[B%X7EMLUX0`OHH{X1SB_U8S 1.png]"><br><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/adawjdoiawjodia6.png" alt="[Pasted image 20231223102728.png]"><br>如此也可以生成 exe 文件用于执行</p><p>另外需要注意的是，我们生成的 <code>.exe</code> 文件需要去加上 <code>.dll</code> 文件，否则会找不到文件错误<br>曾经在游玩游戏的时候是否有出现过类似如下，找不到 <code>.dll</code><br><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/adawjdoiawjodia7.png" alt="[Pasted image 20231223095407.png]"><br>事实上需要保证 <code>.dll</code> 在 <code>.exe</code>   同级目录下或者在环境变量下就可以运行</p><h2 id="注意事项-："><a href="#注意事项-：" class="headerlink" title="注意事项 ："></a>注意事项 ：</h2><p>由于在 win 系统下我们的动态库也是出于不确定的情况，所以需要依赖 lib，而不只是 bin，所以你需要在 <code>.cpp</code> 类文件加入 <code>__declspec(dllexport)</code> <img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/adawjdoiawjodia8.png" alt="[Pasted image 20231223022548.png]"><br>同时还有 cmake 文件要加上 shared<br><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/adawjdoiawjodia9.png" alt="[Pasted image 20231223022659.png]"></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>]]></content>
    
    
    <summary type="html">CMake</summary>
    
    
    
    <category term="CMake" scheme="https://huanxueblog.top/categories/CMake/"/>
    
    
    <category term="CMake" scheme="https://huanxueblog.top/tags/CMake/"/>
    
  </entry>
  
  <entry>
    <title>CMake静态库</title>
    <link href="https://huanxueblog.top/posts/cawdawda.html"/>
    <id>https://huanxueblog.top/posts/cawdawda.html</id>
    <published>2024-01-08T11:29:33.000Z</published>
    <updated>2024-01-08T12:39:17.799Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><div class="tabs" id="uniquename1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename1-1"><i class="icon"></i>前言</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename1-1"><p>我们知道 c.cpp c. hh 两个文件会经过编译，然后生成机器码文件，<br>而静态库的作用就是保存机器码，一方面是保证了安全性，另一方面是不用再次编译（但是跨平台肯定是不行的）</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h3 id="如何生成静态库"><a href="#如何生成静态库" class="headerlink" title="如何生成静态库"></a>如何生成静态库</h3><div class="tabs" id="uniquename2"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename2-1"><i class="icon"></i>如何生成静态库</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename2-1"><p><code>add_library(静态库名字 STATIC 静态库.cpp文件)</code><br><code>add_library(add_static STATIC add.cpp)</code></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h3 id="静态库的完整过程"><a href="#静态库的完整过程" class="headerlink" title="静态库的完整过程"></a>静态库的完整过程</h3><div class="tabs" id="uniquename3"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename3-1"><i class="icon"></i>静态库的完整过程</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename3-1"><ol><li><p><strong>编译 <code>add.cpp</code> 生成静态库：</strong> 当通过命令添加一个库时，CMake 会为适用的源文件生成一个编译指令 <code>add_library(add_static STATIC add.cpp)</code>。在这种情况下，它将 <code>add.cpp</code> 编译文件并创建一个名为 <code>add_static</code> 的静态库（在 Windows 上通常是 <code>add_static.lib</code>，在 Unix-like 系统中是 <code>libadd_static.a</code>）。</p></li><li><p><strong>编译 <code>main.cpp</code> 生成对象文件：</strong> <code>add_executable(main main.cpp)</code> 命令告诉 CMake 对 <code>main.cpp</code> 文件进行编译，生成一个对象文件 <code>main.o</code>（ 或 <code>main.obj</code>）。</p></li><li><p><strong>将静态库 <code>add_static</code> 链接到最终的可执行文件 <code>main</code>：</strong> 确保在 CMake 创建最终的可执行文件时，它会链接之前编译的静态库 <code>add_static.lib</code>。这其中包括了查找和解析函数调用，比如 <code>add()</code> 函数，因为它在静态库 <code>add_static.lib</code> 中定义。这个链接过程涉及到把的 <code>main.cpp</code> 文件编译成可执行文件</p></li></ol><p>这样，生成的可执行文件 <code>main</code> 就包含了 <code>add_static</code> 库中所有必需的代码，这意味着在调用函数 <code>add()</code> 时不需要再有任何其它的库依赖。</p><p>编译和链接的具体命令取决于使用的编译器和平台。如果正在使用 GCC，则它可能会类似于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">g++ -c add.cpp -o add.o                    # 编译生成add.o</span><br><span class="line">ar rcs libadd_static.a add.o                # 通过静态库归档器创建静态库</span><br><span class="line">g++ -c main.cpp -o main.o                   # 编译生成main.o</span><br><span class="line">g++ main.o -L. -ladd_static -o main         # 链接生成main可执行文件</span><br></pre></td></tr></table></figure><p>这里，<code>-L.</code> 告诉编译器在当前目录下查找库（<code>-L</code> 指定库的搜索路径），而 <code>-ladd_static</code> 指定静态库名称（<code>lib</code> 不包括前缀和后缀 <code>.a</code> 或 <code>.lib</code>）。</p><p>正确建立的 CMake 项目会让这个过程自动化，所以通常不需要手动运行编译和链接命令。只需要在构建目录中运行以下 CMake 命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmake ..</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>或使用 CMake 生成适用于选择的 IDE 的工程。</p><p>CMake 后台进行的具体编译和链接命令对于最终用户通常是透明的，除非有错误发生或者需要调试 CMake 本身的问题。如果想看到 CMake 执行 <code>make</code> 的具体命令，可以在命令行中增加的选项，如：<code>VERBOSE=1</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make VERBOSE=1</span><br></pre></td></tr></table></figure><p>这将打印出每个编译和链接阶段的具体命令。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h3 id="静态库结构"><a href="#静态库结构" class="headerlink" title="静态库结构"></a>静态库结构</h3><div class="tabs" id="uniquename4"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename4-1"><i class="icon"></i>静态库结构</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename4-1"><p><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/asjdijaowidjiwa.png" alt="[Pasted image 20231223002434.png]"></p><p><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/awodjaowidjiowafa.png" alt="[Pasted image 20231223004758.png]"><br>以下是一个简单的示意，说明了这些组件是如何集成在静态库中的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[静态库 libadd_static.a 或 add_static.lib]</span><br><span class="line">    |</span><br><span class="line">    |-- [对象文件 add1.o]</span><br><span class="line">    |       |-- 函数 add1 的机器代码</span><br><span class="line">    |       |-- 符号表（包含函数 add1 的信息）</span><br><span class="line">    |</span><br><span class="line">    |-- [对象文件 add2.o]</span><br><span class="line">    |       |-- 函数 add2 的机器代码</span><br><span class="line">    |       |-- 符号表（包含函数 add2 的信息）</span><br><span class="line">    |</span><br><span class="line">    |-- ... (其他对象文件和它们的代码)</span><br><span class="line">    |</span><br><span class="line">    |-- [符号索引] (可选，用于快速查找符号)</span><br></pre></td></tr></table></figure><p>当链接器创建最终的可执行文件或另一个库时，如果需要使用静态库中的函数或变量，链接器会在静态库的符号表中查找相应的符号，并将对应的机器代码链接到最终的产物中。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>]]></content>
    
    
    <summary type="html">CMake</summary>
    
    
    
    <category term="CMake" scheme="https://huanxueblog.top/categories/CMake/"/>
    
    
    <category term="CMake" scheme="https://huanxueblog.top/tags/CMake/"/>
    
  </entry>
  
  <entry>
    <title>CMake如何统一编译管理多个.cpp文件</title>
    <link href="https://huanxueblog.top/posts/63b0d074.html"/>
    <id>https://huanxueblog.top/posts/63b0d074.html</id>
    <published>2024-01-08T11:20:45.000Z</published>
    <updated>2024-01-08T12:42:54.575Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><div class="tabs" id="uniquename1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename1-1"><i class="icon"></i>前言</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename1-1"><p>首先，可以思考一下，如果我们要去管理一堆文件，那么我们需要以何种关系结构去处理呢？如果这个问题换做是管理员工，管理学生呢？</p><p>其实这就是 CMake 文件的联系关系的思想，通过分层管理来间接获取到每一个文件，类似于框架图</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><div class="tabs" id="uniquename2"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename2-1"><i class="icon"></i>介绍</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename2-1"><p>所以我们首先需要定义一个最顶层的 CMakelist，管理版本号，以及多个</p><p>类似于</p><ul><li><p>一层</p></li><li><p>CMakelist</p><ul><li><p>二层</p></li><li><p>项目 1</p></li><li><p>CMakelist</p><ul><li>项目 1_1</li><li>CMakelist</li><li>项目 1_2</li><li>CMakelist</li></ul></li><li><p>项目 2</p></li><li><p>CMakelist</p></li><li><p>项目 3</p></li><li><p>CMakelist</p></li><li><p>项目 4</p></li><li><p>CMakelist<br>其中通过 <code>add_subdirectory</code> 让上层知道下层的目录位置<br>例如在寻找库的过程 (只是举个例子先不要在意库是什么)：</p><p><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/awd546w5a4d64aw.png" alt="[G%52CA~TNB.png]"></p></li></ul></li></ul></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h3 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h3><div class="tabs" id="uniquename3"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename3-1"><i class="icon"></i>实操</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename3-1"><p>对于第一次编译 <code>add. cpp</code> 文件的过程进行扩展，结构如下<br><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/dad21a5d1aw54d6wa.png" alt="[Pasted image 20240107234142.png]"><br>其中最底下的 <code>CMakelists.txt</code> 是顶层，sub 实现的是减法，mul 乘法在 add 子目录，和之前的加法实现就基本上一样，这里给出 <code>CMakelists.txt</code> 的配置<br>顶层 <code>CMakelists.txt</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">project(cmake_study)#定义一个项目名</span><br><span class="line"></span><br><span class="line">add_subdirectory(sub)</span><br><span class="line"></span><br><span class="line">add_subdirectory(add)</span><br><span class="line"></span><br><span class="line">cmake_minimum_required(VERSION 3.15)</span><br></pre></td></tr></table></figure><p><code>sub\CMakelists.txt</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.15)</span><br><span class="line"></span><br><span class="line">add_executable(lesson1_2 main.cpp sub.hh sub.cpp)#把需要的文件交给cmake进行编译</span><br></pre></td></tr></table></figure><p><code>add\CMakelists.txt</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.15)</span><br><span class="line"></span><br><span class="line">add_executable(lesson1_1 main.cpp add.hh add.cpp)#把需要的文件交给cmake进行编译</span><br><span class="line"></span><br><span class="line">add_subdirectory(mul)</span><br></pre></td></tr></table></figure><p><code>mul\CMakelists.txt</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.15)</span><br><span class="line"></span><br><span class="line">add_executable(lesson1_3 main.cpp mul.hh mul.cpp)#把需要的文件交给cmake进行编译</span><br></pre></td></tr></table></figure><p>然后我们分别去执行 <code>.exe</code><br><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/asdfacesfsg4122.png" alt="[Pasted image 20240107235306.png]"><br>说明我们多层管理成功</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>]]></content>
    
    
    <summary type="html">CMake</summary>
    
    
    
    <category term="CMake" scheme="https://huanxueblog.top/categories/CMake/"/>
    
    
    <category term="CMake" scheme="https://huanxueblog.top/tags/CMake/"/>
    
  </entry>
  
  <entry>
    <title>CMake_message，set，list的用法</title>
    <link href="https://huanxueblog.top/posts/4cec0d6e.html"/>
    <id>https://huanxueblog.top/posts/4cec0d6e.html</id>
    <published>2024-01-08T10:59:03.000Z</published>
    <updated>2024-01-08T12:39:13.694Z</updated>
    
    <content type="html"><![CDATA[<h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><div class="tabs" id="uniquename1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename1-1"><i class="icon"></i>格式</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename1-1"><p>Message（模式+“${自定义/系统变量} hello world” …）<br>其中空格也可以用 <code>；</code> ，我会比较习惯用空格</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h3 id="普通模式"><a href="#普通模式" class="headerlink" title="普通模式"></a>普通模式</h3><div class="tabs" id="uniquename2"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename2-1"><i class="icon"></i>普通模式</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename2-1"><p>模式默认空，放着不写就行</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h3 id="特殊模式"><a href="#特殊模式" class="headerlink" title="特殊模式"></a>特殊模式</h3><div class="tabs" id="uniquename3"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename3-1"><i class="icon"></i>特殊模式</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename3-1"><p>STATUS<br>输出状态信息<br>WARNING<br>当用户错误运行时的错误信息<br>AUTHOR_WARNING<br>开发的时候当日志来用<br>SEND_ERROR<br>发送一个错误信息，但是不终止<br>FATAL_ERROR<br>发送一个错误信息，并且终止</p><h4 id="STATUS"><a href="#STATUS" class="headerlink" title="STATUS"></a>STATUS</h4><p><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/adgjksgajk.png" alt="[Pasted image 20240107130937.png]"><br><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/adhahjchkhxz.png" alt="[Pasted image 20240107130801.png]"><br>可以看到前面多加了两个 <code>-</code> 和下面的配置和生成构建文件消息提示是一样的状态信息</p><h4 id="WARNING"><a href="#WARNING" class="headerlink" title="WARNING"></a>WARNING</h4><p><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/uahduhawudhuihxzdjhkwa.png" alt="[Pasted image 20240107131729.png]"><br><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/auihduhksjhdcxkajhkdjwq.png" alt="[Pasted image 20240107131707.png]"><br>此消息会提示报错行：104 行<br>报错信息是：HELLO WORLD</p><h4 id="AUTHOR-WARNING"><a href="#AUTHOR-WARNING" class="headerlink" title="AUTHOR_WARNING"></a>AUTHOR_WARNING</h4><p><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/haowdhoiahdiojopxzdopwqa.png" alt="[Pasted image 20240107140201.png]"><br><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/auhsdidcoiowjd.png" alt="[Pasted image 20240107140220.png]"><br>和 WARNING 不同的是多了一行只能由开发者去解决的报错提示 <code>此警告适用于项目开发人员。 使用 -Wno-dev 来抑制它。</code></p><h4 id="SEND-ERROR"><a href="#SEND-ERROR" class="headerlink" title="SEND_ERROR"></a>SEND_ERROR</h4><p><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/sdhaksdhchwqdh.png" alt="[Pasted image 20240107132328.png]"><br><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/dahajkdhjwhkdh.png" alt="[Pasted image 20240107142211.png]"><br>和上面的 <code>WARNING</code> 的差别在于输出的报错信息是和 WARNING 相似的但是下面的配置，生成，构建均不成功</p><h4 id="FATAL-ERROR"><a href="#FATAL-ERROR" class="headerlink" title="FATAL_ERROR"></a>FATAL_ERROR</h4><p><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/aiduhiashciopwidjiwqh.png" alt="[Pasted image 20240107141333.png]"><br><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/gagssshgjhgawjdhgwj.png" alt="[Pasted image 20240107141837.png]"><br>和 SEND_ERROR 类似，但是会直接终止下面的构建，可以看到本一个出现的分割线没有输出了</p><p>以上是各个模式下出现的情况</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><div class="tabs" id="uniquename4"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename4-1"><i class="icon"></i>变量</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename4-1"><p>变量有分为用户定义的变量和我们 CMake 定义好的变量<br>输出的形式是 Message（模式+“${自定义/系统变量} …）</p><h4 id="系统自带的变量"><a href="#系统自带的变量" class="headerlink" title="系统自带的变量"></a>系统自带的变量</h4><ol><li><p><strong>项目信息</strong></p><ul><li><code>CMAKE_PROJECT_NAME</code>: 当前项目的名称。</li><li><code>PROJECT_SOURCE_DIR</code> / <code>CMAKE_SOURCE_DIR</code>: 顶层源代码目录。</li><li><code>PROJECT_BINARY_DIR</code> / <code>CMAKE_BINARY_DIR</code>: 顶层二进制或编译目录。</li></ul></li><li><p><strong>编译器和工具设置</strong></p><ul><li><code>CMAKE_C_COMPILER</code>: C编译器的全路径。</li><li><code>CMAKE_CXX_COMPILER</code>: C++编译器的全路径。</li><li><code>CMAKE_COMPILER_IS_GNUCC</code>: 如果是GNU的C编译器则为真。</li><li><code>CMAKE_COMPILER_IS_GNUCXX</code>: 如果是GNU的C++编译器则为真。</li></ul></li><li><p><strong>编译标志</strong></p><ul><li><code>CMAKE_C_FLAGS</code>: C编译器的命令行选项。</li><li><code>CMAKE_CXX_FLAGS</code>: C++编译器的命令行选项。</li></ul></li><li><p><strong>构建类型</strong></p><ul><li><code>CMAKE_BUILD_TYPE</code>: 当前的构建类型，如Release或Debug。</li></ul></li><li><p><strong>安装路径</strong></p><ul><li><code>CMAKE_INSTALL_PREFIX</code>: 安装目录的前缀。</li></ul></li><li><p><strong>系统信息</strong></p><ul><li><code>CMAKE_SYSTEM</code>: 宿主系统的名称。</li><li><code>CMAKE_SYSTEM_NAME</code>: 不包含版本的宿主系统名称。</li><li><code>CMAKE_SYSTEM_PROCESSOR</code>: 目标处理器的名称。</li></ul></li><li><p><strong>库和执行文件</strong></p><ul><li><code>CMAKE_ARCHIVE_OUTPUT_DIRECTORY</code>: 静态库的输出目录。</li><li><code>CMAKE_LIBRARY_OUTPUT_DIRECTORY</code>: 共享库的输出目录。</li><li><code>CMAKE_RUNTIME_OUTPUT_DIRECTORY</code>: 可执行文件的输出目录。</li></ul></li><li><p><strong>查找到的库和程序</strong></p><ul><li><code>CMAKE_PREFIX_PATH</code>: 系统查找包（libraries/packages）的路径。</li><li><code>CMAKE_INCLUDE_PATH</code>: 系统头文件查找路径。</li><li>变量例如<code>Boost_FOUND</code>，<code>Boost_INCLUDE_DIRS</code>，<code>Boost_LIBRARIES</code>等，通过<code>find_package(Boost)</code>自动生成。</li></ul></li><li><p><strong>版本信息</strong></p><ul><li><code>CMAKE_MAJOR_VERSION</code>, <code>CMAKE_MINOR_VERSION</code>, <code>CMAKE_PATCH_VERSION</code>: 分别代表 CMake 的主版本、次版本和补丁级别版本号。</li></ul></li></ol></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h3 id="用户定义变量"><a href="#用户定义变量" class="headerlink" title="用户定义变量"></a>用户定义变量</h3><div class="tabs" id="uniquename5"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename5-1"><i class="icon"></i>用户定义变量</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename5-1"><p>我们需要通过 set（变量名 “变量值”）<br>例如<br><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/awoidoiasdoijwo.png" alt="[Pasted image 20240107143812.png]"><br><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/ahwduhisauhdw.png" alt="[Pasted image 20240107143829.png]"><br>要注意的是如果用户定义的变量和系统的变量是同名的那么就会覆盖，作用的范围仅仅是当前的文件目录下</p><h4 id="设置带空格的变量"><a href="#设置带空格的变量" class="headerlink" title="设置带空格的变量"></a>设置带空格的变量</h4><p><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/aiodiaswjhdoiqw.png" alt="[Pasted image 20240107155414.png]"><br><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/aidhiauwhiduhaiw.png" alt="[Pasted image 20240107155430.png]"></p><h4 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h4><p><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/aduwhakhdcwhadhuiwa.png" alt="[Pasted image 20240107160219.png]"></p><p>通过以上就大致了解了 message 的格式对应的含义</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h3 id="输出文本方式"><a href="#输出文本方式" class="headerlink" title="输出文本方式"></a>输出文本方式</h3><div class="tabs" id="uniquename6"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename6-1"><i class="icon"></i>输出文本方式</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename6-1"><p><code>message([[   ]])</code> 和 <code>message(&quot;   &quot;)</code> 以及直接使用 <code>message( )</code> 均可以输出文本，区别是 <code>[[]]</code> 不会展开变量不会对其中诸如${A}的形式进行解析，而 <code>&quot;&quot;</code> 是会去解析变量，而直接（）是不推荐的，因为容易误导，我认为需要清晰地表达意图那么最好还是使用””<br><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/waouidoiahsoidhoiw.png" alt="[Pasted image 20240107154416.png]"><br><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/haoidhawoidijaj.png" alt="[Pasted image 20240107154425.png]"><br><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/ahdiuahsudhciowoiado.png" alt="[Pasted image 20240107154502.png]"><br><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/agdisughiduiuwgau.png" alt="[Pasted image 20240107154448.png]"></p><h4 id="LIST-创建多个变量（列表）"><a href="#LIST-创建多个变量（列表）" class="headerlink" title="LIST 创建多个变量（列表）"></a>LIST 创建多个变量（列表）</h4><p><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/dajciojadijwiajodija.png" alt="[Pasted image 20240107155046.png]"><br><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/jakdkasjhdkjhwkja.png" alt="[Pasted image 20240107155114.png]"><br>LIST 这个名字可以随便取，只要形式如上就算创建多个变量</p><p>关于列表的更多用法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"># 创建多个变量</span><br><span class="line"></span><br><span class="line">message(&quot;-------创建多个变量--------&quot;)</span><br><span class="line"></span><br><span class="line">set(LISTVALUE b2 b3 b4) # 设置变量 LISTVALUE 为 b2 b3 b4</span><br><span class="line"></span><br><span class="line">message($&#123;LISTVALUE&#125;) # 打印变量 LISTVALUE 的值</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"># 添加元素到变量</span><br><span class="line"></span><br><span class="line">list(APPEND port p1 p2 p3) # 将 p1 p2 p3 添加到变量 port 中</span><br><span class="line"></span><br><span class="line">message($&#123;port&#125;) # 打印 port 变量</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"># 获取长度</span><br><span class="line"></span><br><span class="line">message(&quot;-------获取长度--------&quot;)</span><br><span class="line"></span><br><span class="line">list(LENGTH LISTVALUE len) # 获取 LISTVALUE 的长度并存储到变量 len</span><br><span class="line"></span><br><span class="line">message($&#123;len&#125;) # 打印列表长度</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"># 查找变量并获取索引</span><br><span class="line"></span><br><span class="line">list(FIND LISTVALUE b2 index) # 寻找 LISTVALUE 中的 b2 并获取其索引</span><br><span class="line"></span><br><span class="line">message($&#123;index&#125;) # 输出找到的索引值</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"># 删除列表中的元素</span><br><span class="line"></span><br><span class="line">list(REMOVE_ITEM port p1) # 从 port 列表中删除元素 p1</span><br><span class="line"></span><br><span class="line">message($&#123;port&#125;) # 输出修改后的 port 列表</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"># 添加数据</span><br><span class="line"></span><br><span class="line">message(&quot;-------添加数据--------&quot;)</span><br><span class="line"></span><br><span class="line">list(APPEND LISTVALUE a5) # 向 LISTVALUE 列表中添加元素 a5</span><br><span class="line"></span><br><span class="line">message($&#123;LISTVALUE&#125;) # 输出添加 a5 后的 LISTVALUE 列表</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"># 在特定位置插入数据</span><br><span class="line"></span><br><span class="line">list(INSERT LISTVALUE 3 a4) # 在 LISTVALUE 列表的索引 3 位置插入 a4</span><br><span class="line"></span><br><span class="line">message($&#123;LISTVALUE&#125;) # 输出插入 a4 后的 LISTVALUE 列表</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"># 反转列表</span><br><span class="line"></span><br><span class="line">list(REVERSE LISTVALUE) # 反转 LISTVALUE 列表</span><br><span class="line"></span><br><span class="line">message($&#123;LISTVALUE&#125;) # 输出反转后的 LISTVALUE 列表</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"># 排序列表</span><br><span class="line"></span><br><span class="line">list(SORT LISTVALUE) # 对 LISTVALUE 列表进行排序</span><br><span class="line"></span><br><span class="line">message($&#123;LISTVALUE&#125;) # 输出排序后的 LISTVALUE 列表</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>]]></content>
    
    
    <summary type="html">CMake</summary>
    
    
    
    <category term="CMake" scheme="https://huanxueblog.top/categories/CMake/"/>
    
    
    <category term="CMake" scheme="https://huanxueblog.top/tags/CMake/"/>
    
  </entry>
  
  <entry>
    <title>CMake_流程控制，函数和宏</title>
    <link href="https://huanxueblog.top/posts/7dccf0e3.html"/>
    <id>https://huanxueblog.top/posts/7dccf0e3.html</id>
    <published>2024-01-08T10:49:08.000Z</published>
    <updated>2024-01-08T12:39:14.668Z</updated>
    
    <content type="html"><![CDATA[<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><div class="tabs" id="uniquename1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename1-1"><i class="icon"></i>条件语句</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename1-1"><p>在 CMake 中，你可以使用 <code>if</code>、<code>elseif</code>、<code>else</code> 和 <code>endif</code> 来进行条件控制:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if(  )   # 执行当条件为真时的命令</span><br><span class="line">elseif(  )   # 执行当第一个条件为假而这个条件为真时的命令 </span><br><span class="line">else()   # 执行当所有条件都为假时的命令 </span><br><span class="line">endif()</span><br></pre></td></tr></table></figure><p>条件可以基于变量的值、是否定义了变量、文件是否存在等条件。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><div class="tabs" id="uniquename2"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename2-1"><i class="icon"></i>循环</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename2-1"><p>CMake 支持 <code>foreach</code> 循环和 <code>while</code> 循环。</p><p>其中 CMake 3.0以及更高版本中，你可以使用 <code>IN LISTS</code> 或 <code>IN ITEMS</code> 语法来明确指示 <code>foreach</code> 循环应该遍历的是列表变量或者是后面直接指定的项，使得 CMake 脚本更易读、写和维护。</p><p>使用 <code>foreach</code> 循环遍历列表中的每个项:<br>如果有需要遍历自己定义的变量那么</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foreach(loop_var IN [LISTS &lt;list...&gt;] [ITEMS &lt;items...&gt;]...)   # 对列表中的每个项执行命令 注意ITEMS项要在LISTS后面 </span><br><span class="line">endforeach()</span><br></pre></td></tr></table></figure><p>例如：<br><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/dsafasfhdththb.png" alt="[Pasted image 20240107175849.png]"><br><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/dsafszshyfgukmjgfh.png" alt="[Pasted image 20240107180148.png]"><br>混用的时候作用是挨个解析读取，注意一定要在 IN 后面指定是什么类型（LISTS or ITEMS)<br>如果想进行更细的操作可以使用定义的局部变量来进行操作，例如<br>上面图片中是 file，我们可以通过 file_0，或者 file_1 来分别操作 sources 和 headers<br><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/X31ZUXGEOOVXX.png" alt="[Pasted image 20240107182731.png]"><br><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/MLNA5sdfsdfd2.png" alt="[Pasted image 20240107182805.png]"><br>注：如果是低版本没有 IN 那么需要以${A}的形式去指定自定义变量<br>如果只是想在循环中指定项目元素</p><p>疑问：ITEMS 和 LISTS 的区别是什么？<br>答：区别是 ITEMS 是输出名字而 LISTS 是会去解析变量名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foreach(loop_var item1 item2 ... itemN)   # 对列表中的每个项执行命令</span><br><span class="line">endforeach()</span><br></pre></td></tr></table></figure><p>例如：<br><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/YJ1XDSCEZAQYEXEVYYIAE.png" alt="[Pasted image 20240107173220.png]"><br><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/asdasdgkjashkjd.png" alt="[Pasted image 20240107173156.png]"></p><p>或者是遍历数字</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foreach(loop_var RANGE total)    # 命令</span><br><span class="line">... </span><br><span class="line">ndforeach()</span><br></pre></td></tr></table></figure><p>使用 <code>while</code> 循环，直到条件为假:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">while(  )   # 执行命令直到条件变为假 </span><br><span class="line">endwhile()</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h3 id="函数和宏"><a href="#函数和宏" class="headerlink" title="函数和宏"></a>函数和宏</h3><div class="tabs" id="uniquename3"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename3-1"><i class="icon"></i>函数和宏</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename3-1"><p>函数和宏允许你定义代码块，并在需要的地方调用。</p><p>定义和调用函数:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function(my_func_name param1 param2)   # 函数体 </span><br><span class="line">endfunction()  </span><br><span class="line">my_func_name(arg1 arg2)</span><br></pre></td></tr></table></figure><p>定义和调用宏:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">macro(my_macro param1 param2)   # 宏体 </span><br><span class="line">endmacro()  </span><br><span class="line">my_macro(arg1 arg2)</span><br></pre></td></tr></table></figure><p>函数和宏之间的主要区别在于它们如何处理变量的作用域。宏不会产生新的作用域，而函数会。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><div class="tabs" id="uniquename4"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename4-1"><i class="icon"></i>用途</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename4-1"><p>If：<br>对于不同的操作系统进行适配需要用到判断语句：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(WIN32)</span><br><span class="line">    <span class="keyword">add_definitions</span>(-DWINDOWS)</span><br><span class="line"><span class="keyword">elseif</span>(UNIX)</span><br><span class="line">    <span class="keyword">add_definitions</span>(-DLINUX)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure><p>While：<br>可以构想一个场景，比如说，你需要在一列文件中搜索某个特定的文件，并将它的路径设置为变量：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(files <span class="string">&quot;file1.txt&quot;</span> <span class="string">&quot;file2.txt&quot;</span> <span class="string">&quot;file3.txt&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(found <span class="keyword">FALSE</span>)</span><br><span class="line"><span class="keyword">set</span>(i <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">NOT</span> found <span class="keyword">AND</span> i <span class="keyword">LESS</span> <span class="keyword">list</span>(LENGTH files))</span><br><span class="line">    <span class="keyword">list</span>(GET files <span class="variable">$&#123;i&#125;</span> current_file)</span><br><span class="line">    <span class="keyword">if</span>(current_file <span class="keyword">STREQUAL</span> <span class="string">&quot;file2.txt&quot;</span>)</span><br><span class="line">        <span class="keyword">set</span>(found <span class="keyword">TRUE</span>)</span><br><span class="line">        <span class="keyword">set</span>(special_file_path <span class="variable">$&#123;current_file&#125;</span>)</span><br><span class="line">    <span class="keyword">endif</span>()</span><br><span class="line">    <span class="keyword">math</span>(EXPR i <span class="string">&quot;$&#123;i&#125; + 1&quot;</span>)</span><br><span class="line"><span class="keyword">endwhile</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;Special file found at: $&#123;special_file_path&#125;&quot;</span>)</span><br></pre></td></tr></table></figure><p>foreach：<br>用来存储源文件名，便于后期的管理</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(src_files <span class="string">&quot;main.cpp&quot;</span> <span class="string">&quot;utils.cpp&quot;</span> <span class="string">&quot;widget.cpp&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span>(src_file IN LISTS src_files)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;Source file: $&#123;src_file&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">endforeach</span>()</span><br></pre></td></tr></table></figure><p>Function：<br>用来封装命令<br>如上面的命令就可以封装</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>(print_source_files)</span><br><span class="line">    <span class="keyword">foreach</span>(src_file IN LISTS ARGN)<span class="comment">#使用`ARGN`关键字来接收传递给函数的所有未命名参数。`ARGN`在函数中代表所有未处理的参数列表。</span></span><br><span class="line">        <span class="keyword">message</span>(STATUS <span class="string">&quot;Source file: $&#123;src_file&#125;&quot;</span>)</span><br><span class="line">    <span class="keyword">endforeach</span>()</span><br><span class="line"><span class="keyword">endfunction</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(src_files <span class="string">&quot;main.cpp&quot;</span> <span class="string">&quot;utils.cpp&quot;</span> <span class="string">&quot;widget.cpp&quot;</span>) print_source_files(<span class="variable">$&#123;src_files&#125;</span>)</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">macro</span>(print_source_files)</span><br><span class="line">    <span class="keyword">foreach</span>(src_file IN LISTS ARGN)</span><br><span class="line">        <span class="keyword">message</span>(STATUS <span class="string">&quot;Source file: $&#123;src_file&#125;&quot;</span>)</span><br><span class="line">    <span class="keyword">endforeach</span>()</span><br><span class="line"><span class="keyword">endmacro</span>()</span><br><span class="line"><span class="keyword">set</span>(src_files <span class="string">&quot;main.cpp&quot;</span> <span class="string">&quot;utils.cpp&quot;</span> <span class="string">&quot;widget.cpp&quot;</span>) print_source_files(<span class="variable">$&#123;src_files&#125;</span>)</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>]]></content>
    
    
    <summary type="html">CMake</summary>
    
    
    
    <category term="CMake" scheme="https://huanxueblog.top/categories/CMake/"/>
    
    
    <category term="CMake" scheme="https://huanxueblog.top/tags/CMake/"/>
    
  </entry>
  
  <entry>
    <title>CMake处理项目流程（处理项目时究竟干了些什么事情）</title>
    <link href="https://huanxueblog.top/posts/caf7ca08.html"/>
    <id>https://huanxueblog.top/posts/caf7ca08.html</id>
    <published>2024-01-08T10:45:39.000Z</published>
    <updated>2024-01-08T12:39:22.992Z</updated>
    
    <content type="html"><![CDATA[<h3 id="总体流程"><a href="#总体流程" class="headerlink" title="总体流程"></a>总体流程</h3><div class="tabs" id="uniquename1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename1-1"><i class="icon"></i>总体流程</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename1-1"><p>CMake 的流程有以下的步骤<br><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/adcafcassefsevrbyhbdrt.png" alt="[Pasted image 20240107134748.png]"><br>了解过程会更好地帮助我们去理解整个 cmake 在干什么，debug 的时候更容易去定位错误</p><p>例如当对于任意合法的 <code>CMakelist.txt</code> 执行 <code>cmake --build .</code><br>Configuring done 配置完成<br>Generating done 生成完成<br>Build files have been written to… 构建文件已写入…（说明构建成功）<br><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/gvbseryhntuyjij.png" alt="[Pasted image 20240107134926.png]"><br>如果构建不合法则会出现<br><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/evtgrbdhuyjwraeftgbrhe.png" alt="[Pasted image 20240107160422.png]"><br>如果是配置和生成出现错误，那么就一定是 CMake 配置或 CMakelist 配置没有配置好</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h3 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h3><div class="tabs" id="uniquename2"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename2-1"><i class="icon"></i>编译过程</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename2-1"><p>事实上，CMake 只是处理配置和生成两个阶段，换一句话说 CMake 的配置和生成都是 cmake 自己的事情，而到了编译阶段则是调用其他的工具来进行编译 CMake 可以通过特定的命令（如 <code>cmake --build .</code>）来调用这些工具，但本质上它是在为这些工具提供参数，实际的编译工作是由那些如 <code>make</code>, <code>ninja</code> 工具完成的。（区分好各司什么职很重要）</p><h4 id="以下是编译过程："><a href="#以下是编译过程：" class="headerlink" title="以下是编译过程："></a>以下是编译过程：</h4><p><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/textgif.gif" alt="[textgif 1.gif]"></p><p><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/gsdrghdthrtdjhftuty.png" alt="[Pasted image 20231223205158.png]"><br><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/dafrgtfjhnmyrtdthsthstrth.png" alt="[Pasted image 20231223205452.png]"><br><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/awdfvsfgvsgvsregvrse.png" alt="[Pasted image 20231223205647.png]"><br>接下来我们通过 g++来来看看具体是怎么样处理的</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><div class="tabs" id="uniquename3"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename3-1"><i class="icon"></i>预处理</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename3-1"><p><code>g++ -E main.cpp -o main.i</code> 预处理<br><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/faefwefewagvwe.png" alt="[Pasted image 20231223211045.png]"><br><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/dfsefgvshtuufjj.png" alt="[Pasted image 20231223211312.png]"></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><div class="tabs" id="uniquename4"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename4-1"><i class="icon"></i>编译</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename4-1"><p><code>g++ -S main.i -o main.s</code> 编译<br><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/awdiuguikluogiou.png" alt="[Pasted image 20231223211523.png]"><br><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/asdfegsrghrthtfghrt.png" alt="[Pasted image 20231223211601.png]"></p><p>经过预处理和编译我们得到如下文件<br><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/adfsefgvrsgbrtgbehrgbszrsgb.png" alt="[Pasted image 20231223211751.png]"><br>这些也不必去全部一步一步进行，可以直接走最后一步从而走完全部过程<br>如下，但是只会得到最后的 <code>.o</code> 文件<br><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/sadasfsgbreertgserg.png" alt="[Pasted image 20231223212517.png]"><br><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/adjwjojoawjocikjkwdla.png" alt="[Pasted image 20231223212456.png]"></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h3 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h3><div class="tabs" id="uniquename5"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename5-1"><i class="icon"></i>汇编</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename5-1"><p><code>g++ -c add.s -o add.o</code><br><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/adhwhakjhkjzhnjdkajsdk.png" alt="[Pasted image 20231223213434.png]"><br>汇编成机器码文件</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><div class="tabs" id="uniquename6"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename6-1"><i class="icon"></i>链接</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename6-1"><p><code>g++ main.o add.o -o main</code><br><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/sajdoiiojijdoijwoijdoiajwoid.png" alt="[Pasted image 20231223213737.png]"></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><div class="tabs" id="uniquename7"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename7-1"><i class="icon"></i>总结</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename7-1"><p>CMake <code>.c</code> 或 <code>.cpp</code> 文件，在预处理阶段会引入 <code>.h</code> 文件生成包含所有需要的代码 <code>.i</code> 文件，经过编译生成汇编语言构成的 <code>.s</code> 文件，再汇编成目标所需的机器码 <code>.o</code> 文件，将 <code>.o</code> 文件集体打包就是 <code>.a</code> 静态库文件/ <code>. So</code> 动态库文件，最后链接成 <code>无后缀/.out</code> 的可执行文件</p><div class="table-container"><table><thead><tr><th>描述</th><th>Linux 后缀</th><th>Windows 后缀</th></tr></thead><tbody><tr><td>汇编源文件</td><td>. S 或 .S</td><td>. Asm</td></tr><tr><td>C/C++ 源文件</td><td>. C / .cpp</td><td>. C / .cpp 或 .cc</td></tr><tr><td>C/C++ 头文件</td><td>. H</td><td>. H</td></tr><tr><td>目标文件</td><td>. O</td><td>. Obj</td></tr><tr><td>静态库文件</td><td>. A</td><td>. Lib 或 .a</td></tr><tr><td>动态库/共享库文件</td><td>. So</td><td>. Dll</td></tr><tr><td>可执行文件</td><td>*(无后缀) 或 .out</td><td>. Exe</td></tr><tr><td>脚本文件</td><td>*(无后缀) 或 .sh</td><td>. Bat 或 .ps 1</td></tr><tr><td>CMake 配置文件</td><td>CMakeLists. Txt</td><td>CMakeLists. Txt</td></tr><tr><td>CMake 缓存文件</td><td>CMakeCache. Txt</td><td>CMakeCache. Txt</td></tr></tbody></table></div></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>]]></content>
    
    
    <summary type="html">CMake</summary>
    
    
    
    <category term="CMake" scheme="https://huanxueblog.top/categories/CMake/"/>
    
    
    <category term="CMake" scheme="https://huanxueblog.top/tags/CMake/"/>
    
  </entry>
  
  <entry>
    <title>CMake如何编译一个.cpp文件</title>
    <link href="https://huanxueblog.top/posts/ed2a79d8.html"/>
    <id>https://huanxueblog.top/posts/ed2a79d8.html</id>
    <published>2024-01-08T10:26:44.000Z</published>
    <updated>2024-01-08T12:39:16.718Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><div class="tabs" id="uniquename1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename1-1"><i class="icon"></i>前言</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename1-1"><p>本文分享的是关于如何去最简单地通过 CMake 去编译一个文件。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h3 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h3><div class="tabs" id="uniquename2"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename2-1"><i class="icon"></i>准备阶段</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename2-1"><p>首先先编写一个 <code>.cpp</code> 文件和 <code>.hh</code> 头文件<br><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/sdfgcgjkghhjg.png" alt="[Pasted image 20240107212230.png]"><br>内容如下<br><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/adsgghkyuyerwrwdcxdv.png" alt="[Pasted image 20240107212204.png]"><br><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/fhjhsdfsdytgf.png" alt="[Pasted image 20240107212454.png]"><br><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/shjgkujtrgarty.png" alt="[Pasted image 20240107212601.png]"><br>和可执行文件 <code>.main</code><br><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/dwatgdyjedfvgh.png" alt="[Pasted image 20240107212534.png]"><br><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/sdffckjrfcdsgvbtgewfgv.png" alt="[Pasted image 20240107212411.png]"></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h3 id="编写-CMakelists"><a href="#编写-CMakelists" class="headerlink" title="编写 CMakelists"></a>编写 CMakelists</h3><div class="tabs" id="uniquename3"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename3-1"><i class="icon"></i>编写 CMakelists</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename3-1"><p>在 main 的同级目录下创建一个 <code>CMakelist.txt</code> 的文件<br>编译如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">project(cmake_study)#定义一个项目名</span><br><span class="line">add_executable(lesson1_1 main.cpp add.hh add.cpp)#把需要的文件交给cmake进行编译</span><br></pre></td></tr></table></figure><p>然后我们就可以看到构建出来的文件<br><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/fgdykgujhtrgvfcwfgerrtyy.png" alt="[Pasted image 20240107213517.png]"><br>然后我们 cd 到 build 目录下运行 <code>.\lesson1_1.exe</code>（在 win 下的指令，如果是在 linux 系统下要用 <code>./lesson1_1.exe</code>）然后我们就得到输出的结果 <img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/fsfgtfjukiukyukyu.png" alt="[Pasted image 20240107215230.png]"></p><p>这就是已经可以最简单去编译一个 <code>.cpp</code> 文件了</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h3 id="一些优化"><a href="#一些优化" class="headerlink" title="一些优化"></a>一些优化</h3><div class="tabs" id="uniquename4"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename4-1"><i class="icon"></i>一些优化</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename4-1"><p>然后我们也可以把头文件通过 <code>include_directories(头文件绝对路径)</code> 的形式引入，或者更好的方式是 <code>target_include_directories（）</code> 这样我们就可以只 <code>add_executable(lesson2 main.cpp sub.cpp)</code> 而不需要再把头文件一并放进去，如果头文件在其他地方，那么这个优化可以隐藏一长串路径</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>]]></content>
    
    
    <summary type="html">CMake</summary>
    
    
    
    <category term="CMake" scheme="https://huanxueblog.top/categories/CMake/"/>
    
    
    <category term="CMake" scheme="https://huanxueblog.top/tags/CMake/"/>
    
  </entry>
  
  <entry>
    <title>从Makefile到CMake</title>
    <link href="https://huanxueblog.top/posts/caf7ca09.html"/>
    <id>https://huanxueblog.top/posts/caf7ca09.html</id>
    <published>2024-01-08T10:12:39.000Z</published>
    <updated>2024-01-25T10:30:09.827Z</updated>
    
    <content type="html"><![CDATA[<h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><div class="tabs" id="uniquename1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename1-1"><i class="icon"></i>开始</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename1-1"><p>原始的文件如下 ：</p><p><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/V7897987.png" alt=""></p><p>我们新建一个 Makefile</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">main: main.cpp add.cpp</span></span><br><span class="line"></span><br><span class="line">    g++ main.cpp add.cpp -o main</span><br></pre></td></tr></table></figure><p>然后再同级目录下就可以调用 make 文件来生成可执行文件了，<code>cs 144</code> 中 <code>lab 0</code> 也是如此，其中 make 的动作用处就是制作可执行文件 webget，然后传入两个参数的同时调用程序</p><p><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/I_]P3~K]62342342.png" alt=""></p><p>回到我们刚刚的代码，这里我们同级目录下 make<br><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/vagrfseggset.png" alt=""><br>出现可执行文件：<br><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/snhtsretbdrtbhrdtydrbhybhdrgtf.png" alt=""></p><p>那么怎么方便的 Makefile 为什么我们还需要使用 CMake？</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h3 id="统一了编译流程"><a href="#统一了编译流程" class="headerlink" title="统一了编译流程"></a>统一了编译流程</h3><div class="tabs" id="uniquename2"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename2-1"><i class="icon"></i>统一了编译流程</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename2-1"><p>虽然 Makefile 直接通过 make 就可以编译，似乎很简单，但是遇到的问题就是在于无法跨平台使用（假设只能在 win 上使用 visualstudio)<br>所以 CMake 就起到了统一的作用</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h3 id="如何通过-CMake-来编译可执行文件"><a href="#如何通过-CMake-来编译可执行文件" class="headerlink" title="如何通过 CMake 来编译可执行文件"></a>如何通过 CMake 来编译可执行文件</h3><div class="tabs" id="uniquename3"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename3-1"><i class="icon"></i>如何通过 CMake 来编译可执行文件</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename3-1"><h4 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h4><p>由于我们的编译文件都在同级所以要先移动到 build 文件下<br><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/dawdfafsbzrfnhfmgu.png" alt=""><br><code>cmake ..</code> 后面一个参数-B 的作用是指定 <code>Makelists.txt</code> 的位置<br>可以看到 build 文件夹下就有我们编译好的文件了<br><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/fsdghgikjfhfdr.png" alt=""><br>而这个过程在 win 平台下也是统一的，十分的方便</p><h4 id="生成可执行文件"><a href="#生成可执行文件" class="headerlink" title="生成可执行文件"></a>生成可执行文件</h4><p>然后我们通过最后的 <code>cmake --build .</code> 也是各个平台通用的<br><img src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/cfaetfgvbtfbXDsrbhy.png" alt=""></p><p>然后我们还可以通过 <code>cmake ../lesson1_1 -DCMAKE_ ERBOSE_MAKEFILE=ON</code> 添加一个开关来输出生成可执行文件的详细的信息，做到对编译工具的打印信息进行自定义管理</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>]]></content>
    
    
    <summary type="html">CMake</summary>
    
    
    
    <category term="CMake" scheme="https://huanxueblog.top/categories/CMake/"/>
    
    
    <category term="CMake" scheme="https://huanxueblog.top/tags/CMake/"/>
    
  </entry>
  
  <entry>
    <title>CMake是一个怎么样的工具</title>
    <link href="https://huanxueblog.top/posts/7e66a467.html"/>
    <id>https://huanxueblog.top/posts/7e66a467.html</id>
    <published>2024-01-08T08:45:39.742Z</published>
    <updated>2024-01-08T12:39:11.273Z</updated>
    
    <content type="html"><![CDATA[<h3 id="CMake-是什么"><a href="#CMake-是什么" class="headerlink" title="CMake 是什么"></a>CMake 是什么</h3><div class="tabs" id="uniquename1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename1-1"><i class="icon"></i>CMake 是什么</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename1-1"><p>是一个工具集，用来生成构建工具脚本，例如 ninja（跨平台），make（linux），visual studio（win），xcode（mac）<br>就像一个厨师，你把菜递给他，他选择用什么样的工具帮您编译。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h3 id="CMake-的作用"><a href="#CMake-的作用" class="headerlink" title="CMake 的作用"></a>CMake 的作用</h3><div class="tabs" id="uniquename2"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename2-1"><i class="icon"></i>CMake 的作用</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename2-1"><p>总得来说</p><ul><li>作用是：编译+测试+打包</li></ul><ol><li>生成构建工具，构建源码</li><li>单元测试</li><li>打包（编译构建工具，或者是源码）比如说做成 rpm 包之类的，就是给人的印象很好，因为是适配平台的直接安装的过程，而则需要用到打包</li></ol></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h3 id="为什么需要-CMake"><a href="#为什么需要-CMake" class="headerlink" title="为什么需要 CMake"></a>为什么需要 CMake</h3><div class="tabs" id="uniquename3"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename3-1"><i class="icon"></i>为什么需要 CMake</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename3-1"><h4 id="使用便利"><a href="#使用便利" class="headerlink" title="使用便利"></a>使用便利</h4><p>其实从最大的用处上来说，他们就是提供了一个平台，实现编译期大部分跨平台的功能（如果调用了系统的 API 可能跨不了）。如果你学会 CMake，那么就无需纠结你是在什么平台下去编译，而额外学习一门新的工具，真正做到了一站式通用。<br>例如可以看这一篇： <a class="btn-anzhiyu " href="https://blog.anheyu.com/"   title="从Makefile到CMake"><i class="anzhiyufont anzhiyu-icon-circle-arrow-right"></i><span>从Makefile到CMake</span></a></p><h4 id="历史原因"><a href="#历史原因" class="headerlink" title="历史原因"></a>历史原因</h4><p>CMake 的产生可以追溯到20世纪90年代末期。当时，为了提高软件跨平台的构建效率，Kitware的团队开始开发一个名为CMake（Cross-platform Make）的工具。CMake 最初是为了简化 ITK（Insight Segmentation and Registration Toolkit）项目在不同平台上的编译而开发的。后来，开发团队意识到这样一个工具对于广大开发者来说将是非常有用的，所以他们决定将其开源。随后，CMake 很快成为了开源社区中广泛接受的构建系统之一，特别是它的简洁和扩展性得到了很多大型项目的青睐，例如 KDE，OpenCV 等。</p><h4 id="帮助理解编译流程"><a href="#帮助理解编译流程" class="headerlink" title="帮助理解编译流程"></a>帮助理解编译流程</h4><p>我在第一去学习 c++使用是使用的 Visual Studio ，而没有经常性去接触到关于项目构建的问题，有时候会出现链接问题，而去查看相关 blog 的时候也是一知半解，但是结果 CMake 的学习之后才是真正理解了编译流程</p><h4 id="方便项目的管理"><a href="#方便项目的管理" class="headerlink" title="方便项目的管理"></a>方便项目的管理</h4><p>由于每一个文件都有 CMakelist 的 txt 文件，所以只要是出现编译相关的错误我们可以很快速的定位到 CMakelist 是错误配置，而写成类似文档的形式，排除起来也比命令行简单。</p><h4 id="其他高级功能"><a href="#其他高级功能" class="headerlink" title="其他高级功能"></a>其他高级功能</h4><p><strong>自动化侦测</strong>：CMake 可以自动检测系统环境，寻找编译器、库和其他工具，自动化处理许多编译时需要的设置。<br><strong>高级功能</strong>：CMake 提供了丰富的指令集合，用于实现诸如编译选项管理、依赖关系追踪、测试自动化、安装和打包等高级构建功能。<br><strong>多配置生成</strong>：CMake 能够为多种构建类型生成配置（如 Debug、Release），便于开发者在不同的构建类型之间切换。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>]]></content>
    
    
    <summary type="html">CMake</summary>
    
    
    
    <category term="CMake" scheme="https://huanxueblog.top/categories/CMake/"/>
    
    
    <category term="CMake" scheme="https://huanxueblog.top/tags/CMake/"/>
    
  </entry>
  
  <entry>
    <title>CMake学习分享-前言</title>
    <link href="https://huanxueblog.top/posts/e1539f30.html"/>
    <id>https://huanxueblog.top/posts/e1539f30.html</id>
    <published>2024-01-08T07:01:05.000Z</published>
    <updated>2024-01-08T12:39:06.998Z</updated>
    
    <content type="html"><![CDATA[<h3 id="主体思路"><a href="#主体思路" class="headerlink" title="主体思路"></a>主体思路</h3><div class="tabs" id="unique-name"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="unique-name-1"><i class="icon"></i></button></ul><div class="tab-contents"><div class="tab-item-content active" id="unique-name-1"><p>本系列会采用自顶向下的想法来给大家分享学习的 CMake<br>过程中会举简单的例子，例子会通过图片的形式，或是理清楚结构，或是给于相对应的代码-打印给一个直观的表现。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h2 id="CMake-章节"><a href="#CMake-章节" class="headerlink" title="CMake 章节"></a>CMake 章节</h2><div class="tabs" id="myuniquetabs"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="myuniquetabs-1"><i class="icon" style="text-align: center;"></i></button></ul><div class="tab-contents"><div class="tab-item-content active" id="myuniquetabs-1"><ul><li>引入<ul><li>CMake学习分享-前言</li><li>CMake是一个怎么样的工具<ul><li>从Makefile到CMake</li></ul></li></ul></li><li>开始·<ul><li>如何编译一个.cpp文件</li><li>CMake 处理项目流程（处理项目时究竟干了些什么事情）</li></ul></li><li>CMake 语法<ul><li>CMake_流程控制，函数和宏</li><li>CMake_message，set，list的用法</li></ul></li><li>进一步<ul><li>如何统一编译管理多个.cpp文件</li></ul></li><li>CMake 库<ul><li>CMake 静态库</li><li>CMake 动态库</li><li>CMake 平台差异</li></ul></li><li>优化<ul><li>CMake 降低耦合</li><li>CMake常用指令推荐</li><li>CMake优雅地使用环境变量</li></ul></li><li>更进一步<ul><li>通过CMake使用opencv-lesson 2_CMake</li></ul></li></ul></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h2 id="心路历程"><a href="#心路历程" class="headerlink" title="心路历程"></a>心路历程</h2><div class="tabs" id="myuniquetabs"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="myuniquetabs-1"><i class="icon"></i></button></ul><div class="tab-contents"><div class="tab-item-content active" id="myuniquetabs-1"><p>学习 CMake 我也是学习不久，很多方面都是在 b 站看“简明教程“和“比飞鸟贵重的多_HKL”两位 up 主的教学，我想做到的是能够把这两位 up 主讲的汇总在一起，并且通过我的理解，告诉大家。从项目接触看来，我其实能力十分有限，只能为大家尽力带来我的视角下对于 CMake 的理解，如果能帮助到大家就好。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>]]></content>
    
    
    <summary type="html">CMake</summary>
    
    
    
    <category term="CMake" scheme="https://huanxueblog.top/categories/CMake/"/>
    
    
    <category term="CMake" scheme="https://huanxueblog.top/tags/CMake/"/>
    
  </entry>
  
  <entry>
    <title>CS144-5</title>
    <link href="https://huanxueblog.top/posts/d466e783.html"/>
    <id>https://huanxueblog.top/posts/d466e783.html</id>
    <published>2023-12-15T13:08:12.000Z</published>
    <updated>2023-12-16T05:59:39.307Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CS144-5"><a href="#CS144-5" class="headerlink" title="CS144-5"></a>CS144-5</h1><div class="tabs" id="test1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="test1-1">test1 1</button></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>前言</strong><br><code>cmake --build build --target check4</code>如下就可以开始代码了</p><p><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/屏幕截图-2023-12-05-195315.png"/></div>&lt;/div&gt;<br>这一次是要实现一个路由表的功能，你需要去做一个存储路由的功能。</p><p>我使用的结构体加vector的组合来实现这一部分，当然你可以自己想一个合适的，我选择这种组合的原因是，用map来实现的话那么用什么来映射呢，又如何知道哪一个是最优的匹配路径，只能通过遍历，然后再通过算法去实现查询，我目前的思路是这样的，所以选择能支持快速增删的简单结构</p><p>其中实现的重点在于寻求最优匹配，这一部分涉及到网络掩码的内容，如果不懂这一部分的友友，可以去b站搜搜看，大概的意思就是多少位是一样的，剩下的这可变化的区域作为子网段，掩码的作用就是规定了这个范围，同时也告诉我们匹配的长度，用于后续求最优的依据。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div class="tabs" id="test1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="test1-1">test1 1</button></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>实验开始</strong><br>我阅读完文档可以罗列出的思路是这样的</p><p><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/GFWB8XA@@CY2JIZ73BH-1024x847.png"/></div>&lt;/div&gt;<br>实现完代码后的思路是这样的</p><p><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/NVVVN3M4OYNJKUOVPU-842x1024.png"/></div>&lt;/div&gt;<br>以上就是我整体的思路</p><p>难的是匹配路由表的函数，这个函数是需要通过提供的匹配长度，然后推算出当前是否是匹配的路由，后面我们可以通过这个匹配长度来判断是否是最优的</p><p>判断最优的过程是找到优的就复制，这和新手村求一组数max是一样的，很简单。</p><p>然后就是如何匹配，我们知道ip也是0和1的世界，所以我们匹配0和1的时候只要与一下不就可以了？思路是不是一下子就出来了。</p><p>那就去实现吧，我代码放在文末</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div class="tabs" id="test1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="test1-1">test1 1</button><button type="button" class="tab " data-href="test1-2">test1 2</button></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>router.cc</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;router.hh&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// route_prefix: The &quot;up-to-32-bit&quot; IPv4 address prefix to match the datagram&#x27;s destination address against</span></span><br><span class="line"><span class="comment">// prefix_length: For this route to be applicable, how many high-order (most-significant) bits of</span></span><br><span class="line"><span class="comment">//    the route_prefix will need to match the corresponding bits of the datagram&#x27;s destination address?</span></span><br><span class="line"><span class="comment">// next_hop: The IP address of the next hop. Will be empty if the network is directly attached to the router (in</span></span><br><span class="line"><span class="comment">//    which case, the next hop address should be the datagram&#x27;s final destination).</span></span><br><span class="line"><span class="comment">// interface_num: The index of the interface to send the datagram out on.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// route_prefix: 要与数据报目的地址匹配的“最多32位”的IPv4地址前缀</span></span><br><span class="line"><span class="comment">// prefix_length: 此路由适用所需的条件，即数据报目的地址的高阶（最重要）位中有多少位需要与路由前缀对应的位匹配？</span></span><br><span class="line"><span class="comment">// next_hop: 下一跳的IP地址。如果网络直接连接到路由器，则为空（在这种情况下，下一跳地址应该是数据报的最终目的地）。</span></span><br><span class="line"><span class="comment">// interface_num: 发送数据报的接口索引。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Router::add_route</span><span class="params">( <span class="type">const</span> <span class="type">uint32_t</span> route_prefix,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="type">const</span> <span class="type">uint8_t</span> prefix_length,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="type">const</span> optional&lt;Address&gt; next_hop,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="type">const</span> <span class="type">size_t</span> interface_num )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cerr &lt;&lt; <span class="string">&quot;DEBUG: adding route &quot;</span> &lt;&lt; Address::<span class="built_in">from_ipv4_numeric</span>( route_prefix ).<span class="built_in">ip</span>() &lt;&lt; <span class="string">&quot;/&quot;</span></span><br><span class="line">       &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;( prefix_length ) &lt;&lt; <span class="string">&quot; =&gt; &quot;</span> &lt;&lt; ( next_hop.<span class="built_in">has_value</span>() ? next_hop-&gt;<span class="built_in">ip</span>() : <span class="string">&quot;(direct)&quot;</span> )</span><br><span class="line">       &lt;&lt; <span class="string">&quot; on interface &quot;</span> &lt;&lt; interface_num &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="comment">//什么样的消息我们不要更新路由表？</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置一下路由信息</span></span><br><span class="line">  Route_Message route_message;</span><br><span class="line">  route_message.interface_num=interface_num;</span><br><span class="line">  route_message.next_hop=next_hop;</span><br><span class="line">  route_message.prefix_length=prefix_length;</span><br><span class="line">  route_message.route_prefix=route_prefix;</span><br><span class="line"><span class="comment">//存储路由信息</span></span><br><span class="line">  route_map.<span class="built_in">push_back</span>(route_message);</span><br><span class="line">  (<span class="type">void</span>)route_prefix;</span><br><span class="line">  (<span class="type">void</span>)prefix_length;</span><br><span class="line">  (<span class="type">void</span>)next_hop;</span><br><span class="line">  (<span class="type">void</span>)interface_num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ip_matches_route</span><span class="params">(<span class="type">uint32_t</span> ip_address, <span class="type">uint32_t</span> route_prefix, <span class="type">uint8_t</span> prefix_length)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(prefix_length&gt;<span class="number">32</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">uint32_t</span> subnet_mask = prefix_length == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">0xFFFFFFFF</span> &lt;&lt; (<span class="number">32</span> - prefix_length);</span><br><span class="line"><span class="type">uint32_t</span> masked_ip = ip_address &amp; subnet_mask;</span><br><span class="line"><span class="type">uint32_t</span> masked_route_prefix = route_prefix &amp; subnet_mask;</span><br><span class="line"><span class="keyword">return</span> masked_ip == masked_route_prefix;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Router::route</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//当前是否有接口传输数据</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;it:interfaces_)&#123;</span><br><span class="line">  <span class="keyword">auto</span> datagram=it.<span class="built_in">maybe_receive</span>();</span><br><span class="line">  <span class="keyword">if</span>(!datagram.<span class="built_in">has_value</span>())&#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">auto</span>&amp; dgram=datagram.<span class="built_in">value</span>();</span><br><span class="line">  <span class="comment">//是否已经有已经不存在的路由</span></span><br><span class="line">  <span class="keyword">if</span>(dgram.header.ttl&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//否者计算校验和，更新ttl</span></span><br><span class="line">  dgram.header.ttl--;</span><br><span class="line">  dgram.header.<span class="built_in">compute_checksum</span>();</span><br><span class="line">  <span class="comment">//是否找得到匹配一个段?</span></span><br><span class="line">  <span class="comment">//获取ip地址</span></span><br><span class="line">  <span class="type">uint32_t</span> IP=dgram.header.dst;</span><br><span class="line">  <span class="comment">//设置最匹配地址</span></span><br><span class="line">  Route_Message bestMatchRoute&#123;&#125;;</span><br><span class="line">  <span class="type">bool</span> hasBestMatch = <span class="literal">false</span>; <span class="comment">// 新增变量来跟踪是否找到有效匹配</span></span><br><span class="line">  <span class="type">size_t</span> i=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(i&lt;route_map.<span class="built_in">size</span>())&#123;</span><br><span class="line">    <span class="comment">// cout&lt;&lt;&quot;发送之前&quot;&lt;&lt;endl;</span></span><br><span class="line">    <span class="comment">// cout&lt;&lt;&quot;bestMatchRoute.prefix_length:&quot;&lt;&lt;to_string(bestMatchRoute.prefix_length)&lt;&lt;endl;</span></span><br><span class="line">    <span class="comment">// cout&lt;&lt;&quot;route_map[i].prefix_length:&quot;&lt;&lt;to_string(route_map[i].prefix_length)&lt;&lt;endl;</span></span><br><span class="line">    <span class="comment">// cout&lt;&lt;&quot;hasBestMatch:&quot;&lt;&lt;hasBestMatch&lt;&lt;endl;</span></span><br><span class="line">    <span class="comment">// cout&lt;&lt;&quot;IP:&quot;&lt;&lt;IP&lt;&lt;endl;</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">ip_matches_route</span>(IP,route_map[i].route_prefix,route_map[i].prefix_length))&#123;</span><br><span class="line">      i++;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当前的是否需要更新，如果没有赋值先赋值，如果已经初始化了就看看是不是需要更新</span></span><br><span class="line">    <span class="keyword">if</span>(hasBestMatch&amp;&amp;bestMatchRoute.prefix_length&gt;=route_map[i].prefix_length)&#123;</span><br><span class="line">      i++;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    bestMatchRoute=route_map[i];</span><br><span class="line">    hasBestMatch=<span class="literal">true</span>;</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//有合适下一跳？</span></span><br><span class="line">  <span class="keyword">if</span>(!hasBestMatch)&#123;</span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">auto</span> &amp;async_NetworkInterface=<span class="built_in">interface</span>(bestMatchRoute.interface_num);</span><br><span class="line">async_NetworkInterface.<span class="built_in">send_datagram</span>(dgram, </span><br><span class="line">            bestMatchRoute.next_hop.<span class="built_in">value_or</span>(Address::<span class="built_in">from_ipv4_numeric</span>(IP)));</span><br><span class="line">    <span class="comment">// cout&lt;&lt;&quot;发送之后&quot;&lt;&lt;endl;</span></span><br><span class="line">    <span class="comment">// cout&lt;&lt;&quot;bestMatchRoute.prefix_length:&quot;&lt;&lt;to_string(bestMatchRoute.prefix_length)&lt;&lt;endl;</span></span><br><span class="line">    <span class="comment">// cout&lt;&lt;&quot;route_map[i].prefix_length:&quot;&lt;&lt;to_string(route_map[i].prefix_length)&lt;&lt;endl;</span></span><br><span class="line">    <span class="comment">// cout&lt;&lt;&quot;hasBestMatch:&quot;&lt;&lt;hasBestMatch&lt;&lt;endl;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></div><div class="tab-item-content" id="test1-2"><p><strong>router.hh</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;network_interface.hh&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;optional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// A wrapper for NetworkInterface that makes the host-side</span></span><br><span class="line"><span class="comment">// interface asynchronous: instead of returning received datagrams</span></span><br><span class="line"><span class="comment">// immediately (from the `recv_frame` method), it stores them for</span></span><br><span class="line"><span class="comment">// later retrieval. Otherwise, behaves identically to the underlying</span></span><br><span class="line"><span class="comment">// implementation of NetworkInterface.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对NetworkInterface的包装，使得主机侧的接口变为异步：不是立即返回收到的数据报</span></span><br><span class="line"><span class="comment">//（来自`recv_frame`方法），而是将它们存储起来以供稍后检索。除此之外，</span></span><br><span class="line"><span class="comment">// 其行为与底层实现的NetworkInterface相同。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AsyncNetworkInterface</span> : <span class="keyword">public</span> NetworkInterface</span><br><span class="line">&#123;</span><br><span class="line">  std::queue&lt;InternetDatagram&gt; datagrams_in_ &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> NetworkInterface::NetworkInterface;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Construct from a NetworkInterface</span></span><br><span class="line">  <span class="comment">// 从NetworkInterface构造</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">AsyncNetworkInterface</span><span class="params">( NetworkInterface&amp;&amp; interface )</span> : NetworkInterface( interface ) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// \brief Receives and Ethernet frame and responds appropriately.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// - If type is IPv4, pushes to the `datagrams_out` queue for later retrieval by the owner.</span></span><br><span class="line">  <span class="comment">// - If type is ARP request, learn a mapping from the &quot;sender&quot; fields, and send an ARP reply.</span></span><br><span class="line">  <span class="comment">// - If type is ARP reply, learn a mapping from the &quot;target&quot; fields.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// \param[in] frame the incoming Ethernet frame</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// \brief 接收Ethernet帧并做出相应的响应。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// - 如果类型是IPv4，则将其推入`datagrams_out`队列，以供所有者稍后检索。</span></span><br><span class="line">  <span class="comment">// - 如果类型是ARP请求，则学习“发送者”字段中的映射，并发送ARP回复。</span></span><br><span class="line">  <span class="comment">// - 如果类型是ARP回复，则学习“目标”字段中的映射。</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// \param[in] frame 进来的Ethernet帧</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">recv_frame</span><span class="params">( <span class="type">const</span> EthernetFrame&amp; frame )</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> optional_dgram = NetworkInterface::<span class="built_in">recv_frame</span>( frame );</span><br><span class="line">    <span class="keyword">if</span> ( optional_dgram.<span class="built_in">has_value</span>() ) &#123;</span><br><span class="line">      datagrams_in_.<span class="built_in">push</span>( std::<span class="built_in">move</span>( optional_dgram.<span class="built_in">value</span>() ) );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Access queue of Internet datagrams that have been received</span></span><br><span class="line">  <span class="comment">// 访问已收到的Internet数据报队列</span></span><br><span class="line"></span><br><span class="line">  <span class="function">std::optional&lt;InternetDatagram&gt; <span class="title">maybe_receive</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( datagrams_in_.<span class="built_in">empty</span>() ) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    InternetDatagram datagram = std::<span class="built_in">move</span>( datagrams_in_.<span class="built_in">front</span>() );</span><br><span class="line">    datagrams_in_.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">return</span> datagram;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构建路由信息</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Route_Message</span>&#123;</span><br><span class="line">  <span class="type">uint32_t</span> route_prefix&#123;&#125;;</span><br><span class="line">  <span class="type">uint8_t</span> prefix_length&#123;&#125;;</span><br><span class="line">  std::optional&lt;Address&gt; next_hop&#123;&#125;;</span><br><span class="line">  <span class="type">size_t</span> interface_num&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// A router that has multiple network interfaces and</span></span><br><span class="line"><span class="comment">// performs longest-prefix-match routing between them.</span></span><br><span class="line"><span class="comment">// 一个拥有多个网络接口并在它们之间进行最长前缀匹配路由的路由器。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Router</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// The router&#x27;s collection of network interfaces</span></span><br><span class="line">    <span class="comment">// 路由器的网络接口集合</span></span><br><span class="line">  std::vector&lt;AsyncNetworkInterface&gt; interfaces_ &#123;&#125;;</span><br><span class="line">   <span class="comment">//构建路由映射</span></span><br><span class="line">  std::vector&lt;Route_Message&gt; route_map &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//设置辅助函数</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add an interface to the router</span></span><br><span class="line">  <span class="comment">// interface: an already-constructed network interface</span></span><br><span class="line">  <span class="comment">// returns the index of the interface after it has been added to the router</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向路由器添加一个接口</span></span><br><span class="line">  <span class="comment">// interface: 一个已经构造好的网络接口</span></span><br><span class="line">  <span class="comment">// 返回添加到路由器后的接口索引 </span></span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">add_interface</span><span class="params">( AsyncNetworkInterface&amp;&amp; interface )</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    interfaces_.<span class="built_in">push_back</span>( std::<span class="built_in">move</span>( interface ) );</span><br><span class="line">    <span class="keyword">return</span> interfaces_.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Access an interface by index</span></span><br><span class="line">  <span class="comment">// 通过索引访问接口</span></span><br><span class="line">  <span class="function">AsyncNetworkInterface&amp; <span class="title">interface</span><span class="params">( <span class="type">size_t</span> N )</span> </span>&#123; <span class="keyword">return</span> interfaces_.<span class="built_in">at</span>( N ); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add a route (a forwarding rule)</span></span><br><span class="line">  <span class="comment">// 添加一条路由（一条转发规则）</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">add_route</span><span class="params">( <span class="type">uint32_t</span> route_prefix,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">uint8_t</span> prefix_length,</span></span></span><br><span class="line"><span class="params"><span class="function">                  std::optional&lt;Address&gt; next_hop,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">size_t</span> interface_num )</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Route packets between the interfaces. For each interface, use the</span></span><br><span class="line">  <span class="comment">// maybe_receive() method to consume every incoming datagram and</span></span><br><span class="line">  <span class="comment">// send it on one of interfaces to the correct next hop. The router</span></span><br><span class="line">  <span class="comment">// chooses the outbound interface and next-hop as specified by the</span></span><br><span class="line">  <span class="comment">// route with the longest prefix_length that matches the datagram&#x27;s</span></span><br><span class="line">  <span class="comment">// destination address.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在接口之间路由数据报。对于每个接口，使用</span></span><br><span class="line">  <span class="comment">// maybe_receive() 方法消费每个进入的数据报，</span></span><br><span class="line">  <span class="comment">// 并根据路由选择正确的下一跳发送到其中一个接口。路由器</span></span><br><span class="line">  <span class="comment">// 根据与数据报目的地址匹配最长前缀长度的路由规则指定出站接口和下一跳。</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">route</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div class="tabs" id="test1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="test1-1">test1 1</button></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>为什么没有lab6,7的文章</strong><br>后面的lab6和lab7都不需要写代码仅仅是一些应用的方面，感兴趣的可以自己去做一下</p><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/屏幕截图-2023-12-05-202543-1024x874.png"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/屏幕截图-2023-12-05-202614-1024x691.png"/></div></div></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>]]></content>
    
    
    <summary type="html">c++实验</summary>
    
    
    
    <category term="C++" scheme="https://huanxueblog.top/categories/C/"/>
    
    
    <category term="CS144" scheme="https://huanxueblog.top/tags/CS144/"/>
    
  </entry>
  
</feed>
