<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CS144-5</title>
      <link href="/posts/d466e783.html"/>
      <url>/posts/d466e783.html</url>
      
        <content type="html"><![CDATA[<h1 id="CS144-5"><a href="#CS144-5" class="headerlink" title="CS144-5"></a>CS144-5</h1><div class="tabs" id="test1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="test1-1">test1 1</button></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>前言</strong><br><code>cmake --build build --target check4</code>如下就可以开始代码了</p><p><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/屏幕截图-2023-12-05-195315.png"/></div>&lt;/div&gt;<br>这一次是要实现一个路由表的功能，你需要去做一个存储路由的功能。</p><p>我使用的结构体加vector的组合来实现这一部分，当然你可以自己想一个合适的，我选择这种组合的原因是，用map来实现的话那么用什么来映射呢，又如何知道哪一个是最优的匹配路径，只能通过遍历，然后再通过算法去实现查询，我目前的思路是这样的，所以选择能支持快速增删的简单结构</p><p>其中实现的重点在于寻求最优匹配，这一部分涉及到网络掩码的内容，如果不懂这一部分的友友，可以去b站搜搜看，大概的意思就是多少位是一样的，剩下的这可变化的区域作为子网段，掩码的作用就是规定了这个范围，同时也告诉我们匹配的长度，用于后续求最优的依据。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div class="tabs" id="test1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="test1-1">test1 1</button></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>实验开始</strong><br>我阅读完文档可以罗列出的思路是这样的</p><p><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/GFWB8XA@@CY2JIZ73BH-1024x847.png"/></div>&lt;/div&gt;<br>实现完代码后的思路是这样的</p><p><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/NVVVN3M4OYNJKUOVPU-842x1024.png"/></div>&lt;/div&gt;<br>以上就是我整体的思路</p><p>难的是匹配路由表的函数，这个函数是需要通过提供的匹配长度，然后推算出当前是否是匹配的路由，后面我们可以通过这个匹配长度来判断是否是最优的</p><p>判断最优的过程是找到优的就复制，这和新手村求一组数max是一样的，很简单。</p><p>然后就是如何匹配，我们知道ip也是0和1的世界，所以我们匹配0和1的时候只要与一下不就可以了？思路是不是一下子就出来了。</p><p>那就去实现吧，我代码放在文末</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div class="tabs" id="test1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="test1-1">test1 1</button><button type="button" class="tab " data-href="test1-2">test1 2</button></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>router.cc</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;router.hh&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// route_prefix: The &quot;up-to-32-bit&quot; IPv4 address prefix to match the datagram&#x27;s destination address against</span></span><br><span class="line"><span class="comment">// prefix_length: For this route to be applicable, how many high-order (most-significant) bits of</span></span><br><span class="line"><span class="comment">//    the route_prefix will need to match the corresponding bits of the datagram&#x27;s destination address?</span></span><br><span class="line"><span class="comment">// next_hop: The IP address of the next hop. Will be empty if the network is directly attached to the router (in</span></span><br><span class="line"><span class="comment">//    which case, the next hop address should be the datagram&#x27;s final destination).</span></span><br><span class="line"><span class="comment">// interface_num: The index of the interface to send the datagram out on.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// route_prefix: 要与数据报目的地址匹配的“最多32位”的IPv4地址前缀</span></span><br><span class="line"><span class="comment">// prefix_length: 此路由适用所需的条件，即数据报目的地址的高阶（最重要）位中有多少位需要与路由前缀对应的位匹配？</span></span><br><span class="line"><span class="comment">// next_hop: 下一跳的IP地址。如果网络直接连接到路由器，则为空（在这种情况下，下一跳地址应该是数据报的最终目的地）。</span></span><br><span class="line"><span class="comment">// interface_num: 发送数据报的接口索引。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Router::add_route</span><span class="params">( <span class="type">const</span> <span class="type">uint32_t</span> route_prefix,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="type">const</span> <span class="type">uint8_t</span> prefix_length,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="type">const</span> optional&lt;Address&gt; next_hop,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="type">const</span> <span class="type">size_t</span> interface_num )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cerr &lt;&lt; <span class="string">&quot;DEBUG: adding route &quot;</span> &lt;&lt; Address::<span class="built_in">from_ipv4_numeric</span>( route_prefix ).<span class="built_in">ip</span>() &lt;&lt; <span class="string">&quot;/&quot;</span></span><br><span class="line">       &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;( prefix_length ) &lt;&lt; <span class="string">&quot; =&gt; &quot;</span> &lt;&lt; ( next_hop.<span class="built_in">has_value</span>() ? next_hop-&gt;<span class="built_in">ip</span>() : <span class="string">&quot;(direct)&quot;</span> )</span><br><span class="line">       &lt;&lt; <span class="string">&quot; on interface &quot;</span> &lt;&lt; interface_num &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="comment">//什么样的消息我们不要更新路由表？</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置一下路由信息</span></span><br><span class="line">  Route_Message route_message;</span><br><span class="line">  route_message.interface_num=interface_num;</span><br><span class="line">  route_message.next_hop=next_hop;</span><br><span class="line">  route_message.prefix_length=prefix_length;</span><br><span class="line">  route_message.route_prefix=route_prefix;</span><br><span class="line"><span class="comment">//存储路由信息</span></span><br><span class="line">  route_map.<span class="built_in">push_back</span>(route_message);</span><br><span class="line">  (<span class="type">void</span>)route_prefix;</span><br><span class="line">  (<span class="type">void</span>)prefix_length;</span><br><span class="line">  (<span class="type">void</span>)next_hop;</span><br><span class="line">  (<span class="type">void</span>)interface_num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ip_matches_route</span><span class="params">(<span class="type">uint32_t</span> ip_address, <span class="type">uint32_t</span> route_prefix, <span class="type">uint8_t</span> prefix_length)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(prefix_length&gt;<span class="number">32</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">uint32_t</span> subnet_mask = prefix_length == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">0xFFFFFFFF</span> &lt;&lt; (<span class="number">32</span> - prefix_length);</span><br><span class="line"><span class="type">uint32_t</span> masked_ip = ip_address &amp; subnet_mask;</span><br><span class="line"><span class="type">uint32_t</span> masked_route_prefix = route_prefix &amp; subnet_mask;</span><br><span class="line"><span class="keyword">return</span> masked_ip == masked_route_prefix;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Router::route</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//当前是否有接口传输数据</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;it:interfaces_)&#123;</span><br><span class="line">  <span class="keyword">auto</span> datagram=it.<span class="built_in">maybe_receive</span>();</span><br><span class="line">  <span class="keyword">if</span>(!datagram.<span class="built_in">has_value</span>())&#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">auto</span>&amp; dgram=datagram.<span class="built_in">value</span>();</span><br><span class="line">  <span class="comment">//是否已经有已经不存在的路由</span></span><br><span class="line">  <span class="keyword">if</span>(dgram.header.ttl&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//否者计算校验和，更新ttl</span></span><br><span class="line">  dgram.header.ttl--;</span><br><span class="line">  dgram.header.<span class="built_in">compute_checksum</span>();</span><br><span class="line">  <span class="comment">//是否找得到匹配一个段?</span></span><br><span class="line">  <span class="comment">//获取ip地址</span></span><br><span class="line">  <span class="type">uint32_t</span> IP=dgram.header.dst;</span><br><span class="line">  <span class="comment">//设置最匹配地址</span></span><br><span class="line">  Route_Message bestMatchRoute&#123;&#125;;</span><br><span class="line">  <span class="type">bool</span> hasBestMatch = <span class="literal">false</span>; <span class="comment">// 新增变量来跟踪是否找到有效匹配</span></span><br><span class="line">  <span class="type">size_t</span> i=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(i&lt;route_map.<span class="built_in">size</span>())&#123;</span><br><span class="line">    <span class="comment">// cout&lt;&lt;&quot;发送之前&quot;&lt;&lt;endl;</span></span><br><span class="line">    <span class="comment">// cout&lt;&lt;&quot;bestMatchRoute.prefix_length:&quot;&lt;&lt;to_string(bestMatchRoute.prefix_length)&lt;&lt;endl;</span></span><br><span class="line">    <span class="comment">// cout&lt;&lt;&quot;route_map[i].prefix_length:&quot;&lt;&lt;to_string(route_map[i].prefix_length)&lt;&lt;endl;</span></span><br><span class="line">    <span class="comment">// cout&lt;&lt;&quot;hasBestMatch:&quot;&lt;&lt;hasBestMatch&lt;&lt;endl;</span></span><br><span class="line">    <span class="comment">// cout&lt;&lt;&quot;IP:&quot;&lt;&lt;IP&lt;&lt;endl;</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">ip_matches_route</span>(IP,route_map[i].route_prefix,route_map[i].prefix_length))&#123;</span><br><span class="line">      i++;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当前的是否需要更新，如果没有赋值先赋值，如果已经初始化了就看看是不是需要更新</span></span><br><span class="line">    <span class="keyword">if</span>(hasBestMatch&amp;&amp;bestMatchRoute.prefix_length&gt;=route_map[i].prefix_length)&#123;</span><br><span class="line">      i++;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    bestMatchRoute=route_map[i];</span><br><span class="line">    hasBestMatch=<span class="literal">true</span>;</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//有合适下一跳？</span></span><br><span class="line">  <span class="keyword">if</span>(!hasBestMatch)&#123;</span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">auto</span> &amp;async_NetworkInterface=<span class="built_in">interface</span>(bestMatchRoute.interface_num);</span><br><span class="line">async_NetworkInterface.<span class="built_in">send_datagram</span>(dgram, </span><br><span class="line">            bestMatchRoute.next_hop.<span class="built_in">value_or</span>(Address::<span class="built_in">from_ipv4_numeric</span>(IP)));</span><br><span class="line">    <span class="comment">// cout&lt;&lt;&quot;发送之后&quot;&lt;&lt;endl;</span></span><br><span class="line">    <span class="comment">// cout&lt;&lt;&quot;bestMatchRoute.prefix_length:&quot;&lt;&lt;to_string(bestMatchRoute.prefix_length)&lt;&lt;endl;</span></span><br><span class="line">    <span class="comment">// cout&lt;&lt;&quot;route_map[i].prefix_length:&quot;&lt;&lt;to_string(route_map[i].prefix_length)&lt;&lt;endl;</span></span><br><span class="line">    <span class="comment">// cout&lt;&lt;&quot;hasBestMatch:&quot;&lt;&lt;hasBestMatch&lt;&lt;endl;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></div><div class="tab-item-content" id="test1-2"><p><strong>router.hh</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;network_interface.hh&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;optional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// A wrapper for NetworkInterface that makes the host-side</span></span><br><span class="line"><span class="comment">// interface asynchronous: instead of returning received datagrams</span></span><br><span class="line"><span class="comment">// immediately (from the `recv_frame` method), it stores them for</span></span><br><span class="line"><span class="comment">// later retrieval. Otherwise, behaves identically to the underlying</span></span><br><span class="line"><span class="comment">// implementation of NetworkInterface.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对NetworkInterface的包装，使得主机侧的接口变为异步：不是立即返回收到的数据报</span></span><br><span class="line"><span class="comment">//（来自`recv_frame`方法），而是将它们存储起来以供稍后检索。除此之外，</span></span><br><span class="line"><span class="comment">// 其行为与底层实现的NetworkInterface相同。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AsyncNetworkInterface</span> : <span class="keyword">public</span> NetworkInterface</span><br><span class="line">&#123;</span><br><span class="line">  std::queue&lt;InternetDatagram&gt; datagrams_in_ &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> NetworkInterface::NetworkInterface;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Construct from a NetworkInterface</span></span><br><span class="line">  <span class="comment">// 从NetworkInterface构造</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">AsyncNetworkInterface</span><span class="params">( NetworkInterface&amp;&amp; interface )</span> : NetworkInterface( interface ) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// \brief Receives and Ethernet frame and responds appropriately.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// - If type is IPv4, pushes to the `datagrams_out` queue for later retrieval by the owner.</span></span><br><span class="line">  <span class="comment">// - If type is ARP request, learn a mapping from the &quot;sender&quot; fields, and send an ARP reply.</span></span><br><span class="line">  <span class="comment">// - If type is ARP reply, learn a mapping from the &quot;target&quot; fields.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// \param[in] frame the incoming Ethernet frame</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// \brief 接收Ethernet帧并做出相应的响应。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// - 如果类型是IPv4，则将其推入`datagrams_out`队列，以供所有者稍后检索。</span></span><br><span class="line">  <span class="comment">// - 如果类型是ARP请求，则学习“发送者”字段中的映射，并发送ARP回复。</span></span><br><span class="line">  <span class="comment">// - 如果类型是ARP回复，则学习“目标”字段中的映射。</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// \param[in] frame 进来的Ethernet帧</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">recv_frame</span><span class="params">( <span class="type">const</span> EthernetFrame&amp; frame )</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> optional_dgram = NetworkInterface::<span class="built_in">recv_frame</span>( frame );</span><br><span class="line">    <span class="keyword">if</span> ( optional_dgram.<span class="built_in">has_value</span>() ) &#123;</span><br><span class="line">      datagrams_in_.<span class="built_in">push</span>( std::<span class="built_in">move</span>( optional_dgram.<span class="built_in">value</span>() ) );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Access queue of Internet datagrams that have been received</span></span><br><span class="line">  <span class="comment">// 访问已收到的Internet数据报队列</span></span><br><span class="line"></span><br><span class="line">  <span class="function">std::optional&lt;InternetDatagram&gt; <span class="title">maybe_receive</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( datagrams_in_.<span class="built_in">empty</span>() ) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    InternetDatagram datagram = std::<span class="built_in">move</span>( datagrams_in_.<span class="built_in">front</span>() );</span><br><span class="line">    datagrams_in_.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">return</span> datagram;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构建路由信息</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Route_Message</span>&#123;</span><br><span class="line">  <span class="type">uint32_t</span> route_prefix&#123;&#125;;</span><br><span class="line">  <span class="type">uint8_t</span> prefix_length&#123;&#125;;</span><br><span class="line">  std::optional&lt;Address&gt; next_hop&#123;&#125;;</span><br><span class="line">  <span class="type">size_t</span> interface_num&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// A router that has multiple network interfaces and</span></span><br><span class="line"><span class="comment">// performs longest-prefix-match routing between them.</span></span><br><span class="line"><span class="comment">// 一个拥有多个网络接口并在它们之间进行最长前缀匹配路由的路由器。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Router</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// The router&#x27;s collection of network interfaces</span></span><br><span class="line">    <span class="comment">// 路由器的网络接口集合</span></span><br><span class="line">  std::vector&lt;AsyncNetworkInterface&gt; interfaces_ &#123;&#125;;</span><br><span class="line">   <span class="comment">//构建路由映射</span></span><br><span class="line">  std::vector&lt;Route_Message&gt; route_map &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//设置辅助函数</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add an interface to the router</span></span><br><span class="line">  <span class="comment">// interface: an already-constructed network interface</span></span><br><span class="line">  <span class="comment">// returns the index of the interface after it has been added to the router</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向路由器添加一个接口</span></span><br><span class="line">  <span class="comment">// interface: 一个已经构造好的网络接口</span></span><br><span class="line">  <span class="comment">// 返回添加到路由器后的接口索引 </span></span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">add_interface</span><span class="params">( AsyncNetworkInterface&amp;&amp; interface )</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    interfaces_.<span class="built_in">push_back</span>( std::<span class="built_in">move</span>( interface ) );</span><br><span class="line">    <span class="keyword">return</span> interfaces_.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Access an interface by index</span></span><br><span class="line">  <span class="comment">// 通过索引访问接口</span></span><br><span class="line">  <span class="function">AsyncNetworkInterface&amp; <span class="title">interface</span><span class="params">( <span class="type">size_t</span> N )</span> </span>&#123; <span class="keyword">return</span> interfaces_.<span class="built_in">at</span>( N ); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add a route (a forwarding rule)</span></span><br><span class="line">  <span class="comment">// 添加一条路由（一条转发规则）</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">add_route</span><span class="params">( <span class="type">uint32_t</span> route_prefix,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">uint8_t</span> prefix_length,</span></span></span><br><span class="line"><span class="params"><span class="function">                  std::optional&lt;Address&gt; next_hop,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">size_t</span> interface_num )</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Route packets between the interfaces. For each interface, use the</span></span><br><span class="line">  <span class="comment">// maybe_receive() method to consume every incoming datagram and</span></span><br><span class="line">  <span class="comment">// send it on one of interfaces to the correct next hop. The router</span></span><br><span class="line">  <span class="comment">// chooses the outbound interface and next-hop as specified by the</span></span><br><span class="line">  <span class="comment">// route with the longest prefix_length that matches the datagram&#x27;s</span></span><br><span class="line">  <span class="comment">// destination address.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在接口之间路由数据报。对于每个接口，使用</span></span><br><span class="line">  <span class="comment">// maybe_receive() 方法消费每个进入的数据报，</span></span><br><span class="line">  <span class="comment">// 并根据路由选择正确的下一跳发送到其中一个接口。路由器</span></span><br><span class="line">  <span class="comment">// 根据与数据报目的地址匹配最长前缀长度的路由规则指定出站接口和下一跳。</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">route</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div class="tabs" id="test1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="test1-1">test1 1</button></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>为什么没有lab6,7的文章</strong><br>后面的lab6和lab7都不需要写代码仅仅是一些应用的方面，感兴趣的可以自己去做一下</p><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/屏幕截图-2023-12-05-202543-1024x874.png"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/屏幕截图-2023-12-05-202614-1024x691.png"/></div></div></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CS144 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS144-4</title>
      <link href="/posts/a361d715.html"/>
      <url>/posts/a361d715.html</url>
      
        <content type="html"><![CDATA[<h1 id="CS144-4"><a href="#CS144-4" class="headerlink" title="CS144-4"></a>CS144-4</h1><div class="tabs" id="test1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="test1-1">test1 1</button><button type="button" class="tab " data-href="test1-2">test1 2</button></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>前言</strong><br><code>cmake - - build build - - target check3</code>如下就可以开始lab4了</p><p><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/屏幕截图-2023-12-05-190720.png"/></div>&lt;/div&gt;<br>做着这部分最好的就是了解一下报文的类型，和结构关系。我当时做的时候在里面绕了很多弯，比如说误以为ARP以太网包是带普通数据报的，当时想是ARP顺便发过去，后面发现不是，ARP以太网包只含ARP，普通数据以太网包只含普通数据报文（IPV4）。</p></div><div class="tab-item-content" id="test1-2"><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/LIXKOFMFBV2K8B8K0IVF6.png"/></div></div>其中的我整理的以太网头部对应的数据类型信息如下<div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/SF@97VSHFP3_3LWO6.png"/></div></div></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div class="tabs" id="test1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="test1-1">test1 1</button><button type="button" class="tab " data-href="test1-2">test1 2</button><button type="button" class="tab " data-href="test1-3">test1 3</button><button type="button" class="tab " data-href="test1-4">test1 4</button></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>实验开始</strong><br>鉴于之前我思路不清晰导致一个lab就在调试方面浪费太多太多时间，我后面使用一些图的关系来表示当时的思路</p><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/UM3QZ6WIP90695R0L9-944x1024.png"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/VA7EWKM7ZLWJAIKRXXT-882x1024.png"/></div></div></div><div class="tab-item-content" id="test1-2"><p><strong>如何去广播？</strong></p><h1 id="其中会遇到的问题1："><a href="#其中会遇到的问题1：" class="headerlink" title="其中会遇到的问题1："></a>其中会遇到的问题1：</h1><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/屏幕截图-2023-12-05-192515-1024x85.png"/></div></div></div><div class="tab-item-content" id="test1-3"><p><strong>包有两种那么他们的一个关系是如何的？</strong><br>ARP 包和 ipv 4 包，最大的不同其实也就是以太网包的东西不同，以太网有一个以太网头部和以太网主体部分，以太网头部存储的只有 mac 地址（发送和接收，Ip 的部分分析是由主体部分进行一个拆包实现的，对其包涵的东西进行一个拆包，但是主体仍然存在 mac 地址，这个 mac 地址才是真正需要去注意的，他们只是套着以太网帧的头套干着不同的事情</p></div><div class="tab-item-content" id="test1-4"><p><strong>为什么以太网头和ip头都要有mac地址？</strong><br>传递数据就像是间谍换马甲一样，进入一个国家就穿上一个马甲，也就是 mac 地址只有关于这两个交互国家的，而其中的真正目的 mac 是在主体部分，最后传递到对方手上的时候，以太网帧帧只是从对方的网关的 mac 到对方设备的 mac，mac 地址仅对于当前的局域网或链路是有意义的，并且它们在数据包通过网络传输的过程中会一直变化，直到到达最终的目标设备。而跨越多个网络（国家）的长途传输过程中涉及到的比如 IP 地址等信息则藏于以太网帧的负载（Payload）之内。好处显而易见的实现了一个隐藏 mac 和 ip 的功能保证安全性，同时只关注下一跳实现起来也简单。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div class="tabs" id="test1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="test1-1">test1 1</button><button type="button" class="tab " data-href="test1-2">test1 2</button><button type="button" class="tab " data-href="test1-3">test1 3</button></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>代码</strong><br>在实验过程中要注意实现recv_frame( const EthernetFrame&amp; frame )的时候就算是可以接受的信息也不代表ARP就一定是要你发，也就是说确认是否属于可接收的信息，和检测是否需要你发送是并不包含的，例外就是ARP你可能作为中间进行传递，但并不是一定让你发送你的ARP。而检查是否是你的ARP需要mac地址和ip的双重检测</p><p>以下是我实现的代码，需要自己思考的小伙伴就可以停下了</p></div><div class="tab-item-content" id="test1-2"><p><strong>network_interface.cc</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;network_interface.hh&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;arp_message.hh&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ethernet_frame.hh&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ethernet_address: Ethernet (what ARP calls &quot;hardware&quot;) address of the interface</span></span><br><span class="line"><span class="comment">// ip_address: IP (what ARP calls &quot;protocol&quot;) address of the interface</span></span><br><span class="line"><span class="comment">// ethernet_address: 以太网（ARP协议中称为“硬件”）接口的地址</span></span><br><span class="line"><span class="comment">// ip_address: IP（ARP协议中称为“协议”）接口的地址</span></span><br><span class="line">NetworkInterface::<span class="built_in">NetworkInterface</span>( <span class="type">const</span> EthernetAddress&amp; ethernet_address, <span class="type">const</span> Address&amp; ip_address )</span><br><span class="line">  : <span class="built_in">ethernet_address_</span>( ethernet_address ), <span class="built_in">ip_address_</span>( ip_address )</span><br><span class="line">&#123;</span><br><span class="line">  cerr &lt;&lt; <span class="string">&quot;DEBUG: Network interface has Ethernet address &quot;</span> &lt;&lt; <span class="built_in">to_string</span>( ethernet_address_ ) &lt;&lt; <span class="string">&quot; and IP address &quot;</span></span><br><span class="line">       &lt;&lt; ip_address.<span class="built_in">ip</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dgram: the IPv4 datagram to be sent</span></span><br><span class="line"><span class="comment">// next_hop: the IP address of the interface to send it to (typically a router or default gateway, but</span></span><br><span class="line"><span class="comment">// may also be another host if directly connected to the same network as the destination)</span></span><br><span class="line"><span class="comment">// dgram: 要发送的IPv4数据报</span></span><br><span class="line"><span class="comment">// next_hop: 要将数据报发送到的接口的IP地址（通常是路由器或默认网关，但如果与目的地在同一网络上直接连接，</span></span><br><span class="line"><span class="comment">// 也可能是另一台主机）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Note: the Address type can be converted to a uint32_t (raw 32-bit IP address) by using the</span></span><br><span class="line"><span class="comment">// Address::ipv4_numeric() method.</span></span><br><span class="line"><span class="comment">// 注意：Address类型可以通过使用Address::ipv4_numeric()方法转换为uint32_t（原始的32位IP地址）。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">NetworkInterface::send_datagram</span><span class="params">( <span class="type">const</span> InternetDatagram&amp; dgram, <span class="type">const</span> Address&amp; next_hop )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  EthernetHeader ethernet_header_;</span><br><span class="line">  EthernetFrame ethernet_Frame_;</span><br><span class="line">  <span class="comment">//目的地已知</span></span><br><span class="line">  <span class="keyword">auto</span> mac_address= arp_map_.<span class="built_in">find</span>(next_hop.<span class="built_in">ipv4_numeric</span>());</span><br><span class="line">  <span class="keyword">if</span>(mac_address!=arp_map_.<span class="built_in">end</span>())&#123;</span><br><span class="line">    <span class="comment">// cout&lt;&lt;&quot;目的地已知&quot;&lt;&lt;endl;</span></span><br><span class="line">    ethernet_header_.dst=mac_address-&gt;second.macAddress;</span><br><span class="line">    ethernet_header_.src=ethernet_address_;</span><br><span class="line">    ethernet_header_.type=ethernet_header_.TYPE_IPv4;</span><br><span class="line">    ethernet_Frame_.header=ethernet_header_;</span><br><span class="line">    ethernet_Frame_.payload=<span class="built_in">serialize</span>(dgram);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//目的地未知,发送ARP帧来取得对应的ip地址与mac映射</span></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// cout&lt;&lt;&quot;目的地未知&quot;&lt;&lt;endl;</span></span><br><span class="line">  <span class="comment">//判断是否需要发送（是否找得到记录）</span></span><br><span class="line">  <span class="keyword">if</span>(ethernet_frame_ARPMessage_map_.<span class="built_in">find</span>(next_hop.<span class="built_in">ipv4_numeric</span>())!=</span><br><span class="line">  ethernet_frame_ARPMessage_map_.<span class="built_in">end</span>())&#123;</span><br><span class="line">  <span class="comment">// cout&lt;&lt;&quot;ARP请求缓冲中&quot;&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// cout&lt;&lt;&quot;执行ARP请求&quot;&lt;&lt;endl;</span></span><br><span class="line">  ARPMessage new_arp_msg;</span><br><span class="line">  <span class="comment">//设置状态码为请求</span></span><br><span class="line">  new_arp_msg.opcode=ARPMessage::OPCODE_REQUEST;</span><br><span class="line">  new_arp_msg.sender_ethernet_address=ethernet_address_;</span><br><span class="line">  new_arp_msg.sender_ip_address=ip_address_.<span class="built_in">ipv4_numeric</span>();</span><br><span class="line">  <span class="comment">//将发送地址设置成广播地址，但是此处出现了地址错误，说明广播地址是只在以太网帧当中的</span></span><br><span class="line">  new_arp_msg.target_ip_address=next_hop.<span class="built_in">ipv4_numeric</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//添加以太网头部信息</span></span><br><span class="line">  ethernet_header_.dst=ETHERNET_BROADCAST;</span><br><span class="line">  ethernet_header_.src=ethernet_address_;</span><br><span class="line">  ethernet_header_.type=ethernet_header_.TYPE_ARP;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//封装以太网帧</span></span><br><span class="line">  ethernet_Frame_.header=ethernet_header_;</span><br><span class="line">  ethernet_Frame_.payload= std::<span class="built_in">move</span>( <span class="built_in">serialize</span>( new_arp_msg ) );</span><br><span class="line">  <span class="comment">//放入arp网络优化表，起始行时间是5000ms</span></span><br><span class="line">  ethernet_frame_ARPMessage_map_[next_hop.<span class="built_in">ipv4_numeric</span>()]=<span class="number">5000</span>;</span><br><span class="line">  <span class="comment">//那么这次是数据也要保存的，因为有可能不知道mac地址，但是仍然存在想要发送消息的愿望</span></span><br><span class="line">  InternetDatagram_buffer[next_hop.<span class="built_in">ipv4_numeric</span>()].<span class="built_in">push_back</span>(dgram);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//存入到以太网的处理队列之中</span></span><br><span class="line">  ethernet_frame_buffer_deque.<span class="built_in">push_back</span>(ethernet_Frame_);</span><br><span class="line">  (<span class="type">void</span>)dgram;</span><br><span class="line">  (<span class="type">void</span>)next_hop;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// frame: the incoming Ethernet frame</span></span><br><span class="line"><span class="comment">// frame: 进来的以太网帧</span></span><br><span class="line"><span class="function">optional&lt;InternetDatagram&gt; <span class="title">NetworkInterface::recv_frame</span><span class="params">( <span class="type">const</span> EthernetFrame&amp; frame )</span></span>&#123;</span><br><span class="line">  <span class="comment">//判断如果mac不是广播或者本地的就直接返回(不是给你的信息)</span></span><br><span class="line">  <span class="keyword">if</span>(frame.header.dst!=ethernet_address_&amp;&amp;frame.header.dst!=ETHERNET_BROADCAST)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullopt</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// cout&lt;&lt;&quot;----------------NetworkInterface::recv_frame-----------------&quot;&lt;&lt;endl;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//传入的是IPV4包</span></span><br><span class="line">  InternetDatagram internet_datagram;</span><br><span class="line">  <span class="keyword">if</span>(frame.header.type==EthernetHeader::TYPE_IPv4)&#123;</span><br><span class="line">    <span class="comment">// cout&lt;&lt;&quot;----------------EthernetHeader::TYPE_IPv4-----------------&quot;&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">parse</span>(internet_datagram,frame.payload))&#123;</span><br><span class="line">      <span class="keyword">return</span> internet_datagram;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullopt</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//传入的是ARP帧</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(frame.header.type==EthernetHeader::TYPE_ARP)&#123;</span><br><span class="line">    ARPMessage arp_msg;</span><br><span class="line">    <span class="type">bool</span> is_effective_arp=<span class="built_in">parse</span>(arp_msg,frame.payload);</span><br><span class="line">    <span class="comment">//需要去判断一下是不是要你发的arp包，即使是发给你的包也有可能是广播的形式，所以也就是要做到mac和ip的双重验证</span></span><br><span class="line">    <span class="keyword">if</span> ( arp_msg.target_ip_address != ip_address_.<span class="built_in">ipv4_numeric</span>() )&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullopt</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(is_effective_arp)&#123;</span><br><span class="line">      <span class="comment">//设置缓存</span></span><br><span class="line">      DeviceInfo device_info&#123;arp_msg.sender_ethernet_address,<span class="number">30000</span>&#125;;</span><br><span class="line">      <span class="comment">//如果有值直接覆盖，如果没有创建(更新)</span></span><br><span class="line">      arp_map_[arp_msg.sender_ip_address]=&#123;device_info&#125;;</span><br><span class="line">      <span class="comment">//应该回复什么？</span></span><br><span class="line">      <span class="comment">//如果是对方发的是ARP包,我们需要把之前未说的种种发送给对方</span></span><br><span class="line">      <span class="keyword">if</span>(arp_msg.opcode==ARPMessage::OPCODE_REPLY)&#123;</span><br><span class="line">        <span class="comment">//把之前没说过的话，都倾述出来</span></span><br><span class="line">        <span class="comment">//转换一下地址</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;正在发送未处理的数据包的循环前arp_msg.opcode:&quot;</span>&lt;&lt;arp_msg.opcode&lt;&lt;endl;</span><br><span class="line">        Address send_ip_address=Address::<span class="built_in">from_ipv4_numeric</span>(arp_msg.sender_ip_address);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;it : InternetDatagram_buffer[arp_msg.sender_ip_address])&#123;</span><br><span class="line">            <span class="built_in">send_datagram</span>(it,send_ip_address);</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;正在发送未处理的数据包的循环中,arp_msg.opcode:&quot;</span>&lt;&lt;arp_msg.opcode&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        InternetDatagram_buffer[arp_msg.sender_ip_address].<span class="built_in">clear</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//如果对方发的是请求，要我们回复arp包</span></span><br><span class="line">      <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//建立arp包</span></span><br><span class="line">       ARPMessage new_arp_msg;</span><br><span class="line">       <span class="comment">//建立包装</span></span><br><span class="line">       EthernetHeader ethernet_header_;</span><br><span class="line">       EthernetFrame ethernet_Frame_;</span><br><span class="line">       <span class="comment">//设置状态码为响应</span></span><br><span class="line">       new_arp_msg.opcode=ARPMessage::OPCODE_REPLY;</span><br><span class="line">       new_arp_msg.sender_ethernet_address=ethernet_address_;</span><br><span class="line">       new_arp_msg.sender_ip_address=ip_address_.<span class="built_in">ipv4_numeric</span>();<span class="comment">//这里只是处理了ipv4说明有可能出现ipv6需要过滤</span></span><br><span class="line">       <span class="comment">//交换源发送端mac和ip</span></span><br><span class="line">       new_arp_msg.target_ethernet_address=arp_msg.sender_ethernet_address;</span><br><span class="line">       new_arp_msg.target_ip_address=arp_msg.sender_ip_address;</span><br><span class="line">       ethernet_Frame_.payload=<span class="built_in">serialize</span>(new_arp_msg);</span><br><span class="line">       <span class="comment">//设置类型</span></span><br><span class="line">       ethernet_header_.type=ethernet_header_.TYPE_ARP;</span><br><span class="line">       <span class="comment">//目标地址和源地址交换</span></span><br><span class="line">       ethernet_header_.dst=frame.header.src;</span><br><span class="line">       ethernet_header_.src=ethernet_address_;</span><br><span class="line">       <span class="comment">//替换以太网头</span></span><br><span class="line">       ethernet_Frame_.header=ethernet_header_;</span><br><span class="line">       <span class="comment">//放入准备队列</span></span><br><span class="line">       ethernet_frame_buffer_deque.<span class="built_in">push_back</span>(ethernet_Frame_);     </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullopt</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  (<span class="type">void</span>)frame;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nullopt</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ms_since_last_tick: the number of milliseconds since the last call to this method</span></span><br><span class="line"><span class="comment">// ms_since_last_tick: 自上次调用此方法以来的毫秒数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">NetworkInterface::tick</span><span class="params">( <span class="type">const</span> <span class="type">size_t</span> ms_since_last_tick )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//更新映射，遍历一遍全部更新就是了</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> it = arp_map_.<span class="built_in">begin</span>(); it != arp_map_.<span class="built_in">end</span>(); ) &#123;</span><br><span class="line">    it-&gt;second.existenceTime=it-&gt;second.existenceTime&gt;ms_since_last_tick?</span><br><span class="line">    it-&gt;second.existenceTime-ms_since_last_tick:</span><br><span class="line">    <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (it-&gt;second.existenceTime==<span class="number">0</span>) &#123; </span><br><span class="line">        it = arp_map_.<span class="built_in">erase</span>(it); </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ++it; </span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="comment">//更新ARP请求时间</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> it =ethernet_frame_ARPMessage_map_.<span class="built_in">begin</span>(); it != ethernet_frame_ARPMessage_map_.<span class="built_in">end</span>(); ) &#123;</span><br><span class="line">    it-&gt;second=it-&gt;second&gt;ms_since_last_tick?</span><br><span class="line">    it-&gt;second-ms_since_last_tick:</span><br><span class="line">    <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (it-&gt;second==<span class="number">0</span>) &#123; </span><br><span class="line">        it = ethernet_frame_ARPMessage_map_.<span class="built_in">erase</span>(it); </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ++it; </span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  (<span class="type">void</span>)ms_since_last_tick;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">optional&lt;EthernetFrame&gt; <span class="title">NetworkInterface::maybe_send</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 按照我们实现的相应部分，这一部分的应该只返回一个消息即可</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="comment">//没准备好就发空的</span></span><br><span class="line"> <span class="keyword">if</span>(ethernet_frame_buffer_deque.<span class="built_in">empty</span>())&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullopt</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//准备好了就发过去</span></span><br><span class="line">  EthernetFrame frame=ethernet_frame_buffer_deque.<span class="built_in">front</span>();</span><br><span class="line">  ethernet_frame_buffer_deque.<span class="built_in">pop_front</span>();</span><br><span class="line">  <span class="keyword">return</span> frame;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p></div><div class="tab-item-content" id="test1-3"><p><strong>network_interface.hh</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;address.hh&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ethernet_frame.hh&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ipv4_datagram.hh&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;optional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个结构体来存储MAC地址和存在时间</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DeviceInfo</span> &#123;</span><br><span class="line">    EthernetAddress macAddress;</span><br><span class="line">    <span class="type">uint64_t</span> existenceTime; <span class="comment">// 存在时间，ms为单位</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">send_ARPMessages</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">uint32_t</span> ip_ipv4;</span><br><span class="line">  <span class="type">uint64_t</span> existenceTime;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A &quot;network interface&quot; that connects IP (the internet layer, or network layer)</span></span><br><span class="line"><span class="comment">// with Ethernet (the network access layer, or link layer).</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// This module is the lowest layer of a TCP/IP stack</span></span><br><span class="line"><span class="comment">// (connecting IP with the lower-layer network protocol,</span></span><br><span class="line"><span class="comment">// e.g. Ethernet). But the same module is also used repeatedly</span></span><br><span class="line"><span class="comment">// as part of a router: a router generally has many network</span></span><br><span class="line"><span class="comment">// interfaces, and the router&#x27;s job is to route Internet datagrams</span></span><br><span class="line"><span class="comment">// between the different interfaces.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The network interface translates datagrams (coming from the</span></span><br><span class="line"><span class="comment">// &quot;customer,&quot; e.g. a TCP/IP stack or router) into Ethernet</span></span><br><span class="line"><span class="comment">// frames. To fill in the Ethernet destination address, it looks up</span></span><br><span class="line"><span class="comment">// the Ethernet address of the next IP hop of each datagram, making</span></span><br><span class="line"><span class="comment">// requests with the [Address Resolution Protocol](\ref rfc::rfc826).</span></span><br><span class="line"><span class="comment">// In the opposite direction, the network interface accepts Ethernet</span></span><br><span class="line"><span class="comment">// frames, checks if they are intended for it, and if so, processes</span></span><br><span class="line"><span class="comment">// the the payload depending on its type. If it&#x27;s an IPv4 datagram,</span></span><br><span class="line"><span class="comment">// the network interface passes it up the stack. If it&#x27;s an ARP</span></span><br><span class="line"><span class="comment">// request or reply, the network interface processes the frame</span></span><br><span class="line"><span class="comment">// and learns or replies as necessary.</span></span><br><span class="line"><span class="comment">// “网络接口”连接IP（互联网层或网络层）</span></span><br><span class="line"><span class="comment">// 与以太网（网络接入层或链路层）。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个模块是TCP/IP协议栈的最底层</span></span><br><span class="line"><span class="comment">// （将IP与下层网络协议，例如以太网连接起来）。但是，相同的模块也会在路由器中重复使用：</span></span><br><span class="line"><span class="comment">// 一个路由器通常有多个网络接口，路由器的工作是在不同接口之间路由互联网数据报。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 网络接口将数据报（来自“客户”，例如TCP/IP协议栈或路由器）转换为以太网帧。</span></span><br><span class="line"><span class="comment">// 为了填写以太网目的地址，它会查找每个数据报的下一个IP跳转的以太网地址，</span></span><br><span class="line"><span class="comment">// 使用[地址解析协议](\ref rfc::rfc826)进行请求。</span></span><br><span class="line"><span class="comment">// 在相反的方向上，网络接口接受以太网帧，检查它们是否是为它所设计的，如果是的话，</span></span><br><span class="line"><span class="comment">// 根据其类型处理负载。如果是IPv4数据报，</span></span><br><span class="line"><span class="comment">// 网络接口会将其向上传递。如果是ARP请求或回复，</span></span><br><span class="line"><span class="comment">// 网络接口会处理帧并学习或必要时回复。</span></span><br><span class="line"><span class="comment">// 定义一个结构体来存储MAC地址和存在时间</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NetworkInterface</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// Ethernet (known as hardware, network-access, or link-layer) address of the interface</span></span><br><span class="line">  <span class="comment">// 以太网（又称硬件、网络接入层或链路层）接口的地址mac地址</span></span><br><span class="line">  EthernetAddress ethernet_address_;</span><br><span class="line">  <span class="comment">// IP (known as Internet-layer or network-layer) address of the interface</span></span><br><span class="line">  <span class="comment">// IP（又称互联网层或网络层）接口的地址</span></span><br><span class="line">  Address ip_address_;</span><br><span class="line">  <span class="comment">// uint64_t NI_cur_time_;//当前的接口时间</span></span><br><span class="line">  <span class="comment">// uint64_t NI_pre_time_;//之前的接口时间</span></span><br><span class="line">  <span class="type">uint64_t</span> max_arp_map_existenceTime_=<span class="number">30000</span>;<span class="comment">//30秒的最大时间映射</span></span><br><span class="line">  std::unordered_map&lt;<span class="type">uint32_t</span>, DeviceInfo&gt; arp_map_&#123;&#125;; <span class="comment">// ARP映射表，键为IP地址字符串</span></span><br><span class="line">  std::unordered_map&lt;<span class="type">uint32_t</span>,<span class="type">uint64_t</span>&gt; ethernet_frame_ARPMessage_map_&#123;&#125;;<span class="comment">//缓解网络堵塞，减少arp风暴</span></span><br><span class="line">  std::deque&lt;EthernetFrame&gt; ethernet_frame_buffer_deque&#123;&#125;;<span class="comment">//以太网队列</span></span><br><span class="line">  std::unordered_map&lt;<span class="type">uint32_t</span>,std::list&lt;InternetDatagram&gt;&gt; InternetDatagram_buffer&#123;&#125;;<span class="comment">//缓存期待发送的消息</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Construct a network interface with given Ethernet (network-access-layer) and IP (internet-layer)</span></span><br><span class="line">  <span class="comment">// addresses</span></span><br><span class="line">  <span class="comment">// 使用给定的以太网（网络接入层）和IP（互联网层）地址构造一个网络接口</span></span><br><span class="line">  <span class="built_in">NetworkInterface</span>( <span class="type">const</span> EthernetAddress&amp; ethernet_address, <span class="type">const</span> Address&amp; ip_address );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Access queue of Ethernet frames awaiting transmission</span></span><br><span class="line">  <span class="comment">// 访问等待传输的以太网帧队列</span></span><br><span class="line">  <span class="function">std::optional&lt;EthernetFrame&gt; <span class="title">maybe_send</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Sends an IPv4 datagram, encapsulated in an Ethernet frame (if it knows the Ethernet destination</span></span><br><span class="line">  <span class="comment">// address). Will need to use [ARP](\ref rfc::rfc826) to look up the Ethernet destination address</span></span><br><span class="line">  <span class="comment">// for the next hop.</span></span><br><span class="line">  <span class="comment">// (&quot;Sending&quot; is accomplished by making sure maybe_send() will release the frame when next called,</span></span><br><span class="line">  <span class="comment">// but please consider the frame sent as soon as it is generated.)</span></span><br><span class="line">  <span class="comment">// 发送一个IPv4数据报，封装在一个以太网帧中（如果它知道以太网目的地址）。</span></span><br><span class="line">  <span class="comment">// 将需要使用[ARP](\ref rfc::rfc826)来查找下一个跳转的以太网目的地址。</span></span><br><span class="line">  <span class="comment">// （“发送”是通过确保maybe_send()在下次调用时会释放帧来完成的，</span></span><br><span class="line">  <span class="comment">// 但请考虑一旦帧生成就认为它已经发送。）</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">send_datagram</span><span class="params">( <span class="type">const</span> InternetDatagram&amp; dgram, <span class="type">const</span> Address&amp; next_hop )</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Receives an Ethernet frame and responds appropriately.</span></span><br><span class="line">  <span class="comment">// If type is IPv4, returns the datagram.</span></span><br><span class="line">  <span class="comment">// If type is ARP request, learn a mapping from the &quot;sender&quot; fields, and send an ARP reply.</span></span><br><span class="line">  <span class="comment">// If type is ARP reply, learn a mapping from the &quot;sender&quot; fields.</span></span><br><span class="line">  <span class="comment">// 接收一个以太网帧并作出适当响应。</span></span><br><span class="line">  <span class="comment">// 如果类型是IPv4，返回数据报。</span></span><br><span class="line">  <span class="comment">// 如果类型是ARP请求，从“发送者”字段学习映射，并发送一个ARP回复。</span></span><br><span class="line">  <span class="comment">// 如果类型是ARP回复，从“发送者”字段学习映射。</span></span><br><span class="line">  <span class="function">std::optional&lt;InternetDatagram&gt; <span class="title">recv_frame</span><span class="params">( <span class="type">const</span> EthernetFrame&amp; frame )</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Called periodically when time elapses</span></span><br><span class="line">  <span class="comment">// 定期调用，当时间流逝时</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">tick</span><span class="params">( <span class="type">size_t</span> ms_since_last_tick )</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CS144 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS144-3</title>
      <link href="/posts/3d0542b6.html"/>
      <url>/posts/3d0542b6.html</url>
      
        <content type="html"><![CDATA[<h1 id="CS144-3"><a href="#CS144-3" class="headerlink" title="CS144-3"></a>CS144-3</h1><div class="tabs" id="test1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="test1-1">test1 1</button></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p>如果已经通过了lab2的测试，就可以开始lab3</p><p><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/屏幕截图-2023-12-05-142751.png"/></div>&lt;/div&gt;<br>然后就可以开始同步实验文件了<code>cmake --build build --target check 3</code></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div class="tabs" id="test1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="test1-1">test1 1</button></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>实验开始</strong><br>这次需要实现的其实也就四个函数，其他函数只需要调用头文件中维护的变量</p><p><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/屏幕截图 2023-12-15 233227.png"/></div>&lt;/div&gt;<br>我当时卡在不知道tick要如何实现，不让调用系统时间，只通过传参要怎么实现，说到底还是不了解这个传参的作用，其实每一次该函数被调用结束，都会重置为0，换一句话说，就是调用到第二次调用所经历的时间间隔就是传参的值，相当于一个随机的数，你需要的就是处理这个传参。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div class="tabs" id="test1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="test1-1">test1 1</button><button type="button" class="tab " data-href="test1-2">test1 2</button><button type="button" class="tab " data-href="test1-3">test1 3</button></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>代码实现</strong><br>接下来我讲讲我的实现思路，想自己思考的可以去实验了。</p><p>整体上，需要找到一个数据结构来存放我们的数据，我这里使用的是deque，因为数据的增删频繁，用queque也可以，但是实现起来复杂，没有必要。</p><p>我们创建两存储，一个是已经发送的但是未确认的，一个是准备发送的报文段。push函数用来把需要发送的报文段放入准备发送的deque类型存储，receive函数用来改变已经发送但未确认的deque类存储。时钟的开关用一个变量来维护，当发送出去后就开启时钟，如果当前发送但未确认的deque类存储中没有元素那么表明这个阶段的所有数据均发送过去，可以重置有关时钟的参数，如RTO。具体可以看我的代码和代码中的注释。</p></div><div class="tab-item-content" id="test1-2"><p><strong>TCP_sender.cc</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tcp_sender.hh&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tcp_config.hh&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* TCPSender constructor (uses a random ISN if none given) */</span></span><br><span class="line">TCPSender::<span class="built_in">TCPSender</span>( <span class="type">uint64_t</span> initial_RTO_ms, optional&lt;Wrap32&gt; fixed_isn )</span><br><span class="line">  : <span class="built_in">isn_</span>( fixed_isn.<span class="built_in">value_or</span>( Wrap32 &#123; <span class="built_in">random_device</span>()() &#125; ) ), <span class="built_in">initial_RTO_ms_</span>( initial_RTO_ms )</span><br><span class="line">  ,<span class="built_in">RTO_ms_</span>( initial_RTO_ms )</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="comment">//返回当前在传输中的序列号数量，也就是已经发送但还未收到确认的数据包数量。</span></span><br><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">TCPSender::sequence_numbers_in_flight</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> abs_seqno-por_abs_ackno;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回连续重传的次数，即同一数据包被重传的次数。</span></span><br><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">TCPSender::consecutive_retransmissions</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// Your code here.</span></span><br><span class="line">  <span class="keyword">return</span> retransmissions;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//该方法尝试发送</span></span><br><span class="line"><span class="function">optional&lt;TCPSenderMessage&gt; <span class="title">TCPSender::maybe_send</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// Your code here.</span></span><br><span class="line">  <span class="comment">//是否没有准备</span></span><br><span class="line">  <span class="keyword">if</span>(_ready_collections.<span class="built_in">empty</span>())&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullopt</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//如果准备了的话</span></span><br><span class="line">  TCPSenderMessage maybe_send_Message;</span><br><span class="line">  maybe_send_Message=_ready_collections.<span class="built_in">front</span>();</span><br><span class="line">  <span class="comment">//缓存数据(空包不要缓存)</span></span><br><span class="line">  <span class="keyword">if</span>(maybe_send_Message.<span class="built_in">sequence_length</span>()==<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> maybe_send_Message;</span><br><span class="line">  &#125;</span><br><span class="line">  _outstanding_collections.<span class="built_in">push_back</span>(maybe_send_Message);</span><br><span class="line">  _ready_collections.<span class="built_in">pop_front</span>();</span><br><span class="line">  <span class="comment">//让时钟启动</span></span><br><span class="line">  tick_start=<span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> maybe_send_Message;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//该方法初定为去放数据</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPSender::push</span><span class="params">( Reader&amp; outbound_stream )</span></span></span><br><span class="line"><span class="function"></span>&#123;    <span class="comment">// Your code here.</span></span><br><span class="line"><span class="comment">//循环去处理每一个数据，保证其空间可以放入数据即可</span></span><br><span class="line"><span class="comment">//假设看看剩余空间是否仍然有空余（sequence_numbers_in_flight() 的最大值就是 window_size）不会产生uint64_t回滚</span></span><br><span class="line">  <span class="type">uint64_t</span> available_window_space =<span class="built_in">max</span>(<span class="built_in">static_cast</span>&lt;<span class="type">uint64_t</span>&gt;(<span class="number">1</span>), window_size)-<span class="built_in">sequence_numbers_in_flight</span>();</span><br><span class="line">  <span class="comment">//用于测试</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span> (available_window_space&gt;<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// cout &lt;&lt;n&lt;&lt; &quot;available_window_space1:&quot;&lt;&lt;available_window_space&lt;&lt;&quot;,&quot;&lt;&lt;endl;</span></span><br><span class="line">    <span class="comment">//建立一个默认的消息，范围在0到MAX_PAYLOAD_SIZE</span></span><br><span class="line">    TCPSenderMessage NewMessages;</span><br><span class="line">    <span class="type">size_t</span> NewMessages_length=(<span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(available_window_space))&gt;=TCPConfig::MAX_PAYLOAD_SIZE?</span><br><span class="line">    TCPConfig::MAX_PAYLOAD_SIZE:(<span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(available_window_space));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">read</span>(outbound_stream,NewMessages_length,NewMessages.payload);</span><br><span class="line">    available_window_space-=NewMessages.payload.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">//是否需要SYN包装</span></span><br><span class="line">    <span class="keyword">if</span>(!has_SYN)&#123;</span><br><span class="line">      has_SYN=<span class="literal">true</span>;</span><br><span class="line">      NewMessages.SYN=<span class="literal">true</span>;</span><br><span class="line">      NewMessages.seqno=isn_;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">       NewMessages.seqno = Wrap32::<span class="built_in">wrap</span>( abs_seqno, isn_ );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//是否需要FIN包装</span></span><br><span class="line">    <span class="keyword">if</span>(!has_FIN&amp;&amp;outbound_stream.<span class="built_in">is_finished</span>()&amp;&amp;available_window_space&gt;<span class="number">0</span>)&#123;</span><br><span class="line">      has_FIN=<span class="literal">true</span>;</span><br><span class="line">      NewMessages.FIN=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//是否可以退出（只有当空间不足够以及到结尾以后才会产生空包）</span></span><br><span class="line">    <span class="keyword">if</span>(!NewMessages.SYN&amp;&amp;!NewMessages.FIN&amp;&amp;NewMessages.payload.<span class="built_in">size</span>()==<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//用于测试</span></span><br><span class="line">    <span class="comment">// n++;</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt;n&lt;&lt; &quot;psuh:&quot;&lt;&lt;has_SYN&lt;&lt;&quot;,&quot;&lt;&lt;endl;</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt;n&lt;&lt; &quot;available_window_space2:&quot;&lt;&lt;available_window_space&lt;&lt;&quot;,&quot;&lt;&lt;endl;</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt;n&lt;&lt; &quot;window_size:&quot;&lt;&lt;window_size&lt;&lt;&quot;,&quot;&lt;&lt;endl;</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt;n&lt;&lt; &quot;sequence_numbers_in_flight():&quot;&lt;&lt;sequence_numbers_in_flight()&lt;&lt;&quot;,&quot;&lt;&lt;endl;</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt;n&lt;&lt; &quot;NewMessages.sequence_length():&quot;&lt;&lt;NewMessages.sequence_length()&lt;&lt;&quot;,&quot;&lt;&lt;endl;</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt;n&lt;&lt; &quot;abs_seqno:&quot;&lt;&lt;abs_seqno&lt;&lt;&quot;,&quot;&lt;&lt;endl;</span></span><br><span class="line">    <span class="comment">//均可以放入</span></span><br><span class="line">    <span class="comment">//更新下次的位置</span></span><br><span class="line">    _ready_collections.<span class="built_in">push_back</span>(NewMessages);</span><br><span class="line">    abs_seqno += NewMessages.<span class="built_in">sequence_length</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// //当对方没有空间的时候，我们仍然假设他有一个，让他更新窗口</span></span><br><span class="line">  <span class="comment">// uint16_t window_size=new_win_r-new_win_l; //获取窗口的大小</span></span><br><span class="line">  <span class="comment">// if(window_size==0)&#123;</span></span><br><span class="line">  <span class="comment">// _ready_collections.push_back( send_empty_message());</span></span><br><span class="line">  <span class="comment">// return;</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">  <span class="comment">// //保证已经建立好传输</span></span><br><span class="line">  <span class="comment">// if(has_SYN)&#123;</span></span><br><span class="line">  <span class="comment">//   //生成尽可能多的TCPSenderMessage</span></span><br><span class="line">  <span class="comment">//   while(window_size!=0)&#123;</span></span><br><span class="line">  <span class="comment">//     TCPSenderMessage NewMessages;</span></span><br><span class="line">  <span class="comment">//     uint16_t NewMessages_length=window_size&gt;=</span></span><br><span class="line">  <span class="comment">//     TCPConfig::MAX_PAYLOAD_SIZE?</span></span><br><span class="line">  <span class="comment">//     TCPConfig::MAX_PAYLOAD_SIZE:window_size;</span></span><br><span class="line">  <span class="comment">//     window_size-=NewMessages_length;</span></span><br><span class="line">  <span class="comment">//     //如果是最后一段，那么我们就标识FIN包</span></span><br><span class="line">  <span class="comment">//     if(outbound_stream.is_finished())&#123;</span></span><br><span class="line">  <span class="comment">//       NewMessages.FIN=true;</span></span><br><span class="line">  <span class="comment">//     &#125;</span></span><br><span class="line">  <span class="comment">//     //只给我看我怎么构建信息啊，我直接引用？</span></span><br><span class="line">  <span class="comment">//     NewMessages.payload&#123;&amp;outbound_stream.peek()&#125;;</span></span><br><span class="line">  <span class="comment">//     outbound_stream.pop(NewMessages_length);</span></span><br><span class="line">  <span class="comment">//     NewMessages.seqno=temp.wrap( outbound_stream.bytes_popped() + 1 + outbound_stream.is_finished(), zero_point );</span></span><br><span class="line">  <span class="comment">//     total__ready_collections_length=NewMessages.seqno;</span></span><br><span class="line">  <span class="comment">//     _ready_collections.push_back(NewMessages);</span></span><br><span class="line">  <span class="comment">//   &#125;;</span></span><br><span class="line">  <span class="comment">// &#125;else&#123;</span></span><br><span class="line">  <span class="comment">//   //如果没有建立连接就先发出SYN包</span></span><br><span class="line">  <span class="comment">//   TCPSenderMessage Message_SYN;</span></span><br><span class="line">  <span class="comment">//   Message_SYN.SYN=true;</span></span><br><span class="line">  <span class="comment">//   Message_SYN.seqno=isn_;</span></span><br><span class="line">  <span class="comment">//   zero_point=isn.raw_value_;</span></span><br><span class="line">  <span class="comment">//   _ready_collections.push_back(Message_SYN);</span></span><br><span class="line">  <span class="comment">//   has_SYN=true;</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">  (<span class="type">void</span>)outbound_stream;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//该方法初定为发送空数据</span></span><br><span class="line"><span class="function">TCPSenderMessage <span class="title">TCPSender::send_empty_message</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// Your code here.</span></span><br><span class="line">  <span class="comment">//首先是定义一段空数据</span></span><br><span class="line">  <span class="keyword">return</span> TCPSenderMessage&#123;Wrap32::<span class="built_in">wrap</span>(abs_seqno, isn_ ), <span class="literal">false</span>, <span class="built_in">Buffer</span>(), <span class="literal">false</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//该方法设置窗口大小，同时删除无用段</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPSender::receive</span><span class="params">( <span class="type">const</span> TCPReceiverMessage&amp; msg )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// Your code here.</span></span><br><span class="line">  <span class="comment">//获得窗口左和窗口右(由于窗口大小是uint16MAX所以设置为uint16MAX)</span></span><br><span class="line">  window_size=msg.window_size;</span><br><span class="line">  <span class="comment">//获得abs_ackno</span></span><br><span class="line">  <span class="keyword">if</span>(msg.ackno.<span class="built_in">has_value</span>())&#123;</span><br><span class="line">    abs_ackno=msg.ackno.<span class="built_in">value</span>().<span class="built_in">unwrap</span>( isn_, por_abs_ackno );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//确认新的确认码的有效性</span></span><br><span class="line">  <span class="keyword">if</span>(!msg.ackno.<span class="built_in">has_value</span>()||abs_ackno&gt;abs_seqno||abs_ackno&lt;por_abs_ackno)&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 删除已经确认的段</span></span><br><span class="line">  <span class="keyword">while</span> (!_outstanding_collections.<span class="built_in">empty</span>() ) &#123;</span><br><span class="line">    <span class="keyword">if</span>( _outstanding_collections.<span class="built_in">front</span>().seqno.<span class="built_in">unwrap</span>(isn_,abs_ackno) +_outstanding_collections.<span class="built_in">front</span>().<span class="built_in">sequence_length</span>() - <span class="number">1</span> &gt;= abs_ackno)&#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _outstanding_collections.<span class="built_in">pop_front</span>();</span><br><span class="line">    <span class="comment">// RTO设置</span></span><br><span class="line">    cur_time = <span class="number">0</span>;</span><br><span class="line">    RTO_ms_ = initial_RTO_ms_;</span><br><span class="line">    retransmissions = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; &quot;receive&quot;&lt;&lt;RTO_ms_&lt;&lt;endl;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//设置时钟关闭</span></span><br><span class="line">  <span class="keyword">if</span>(_outstanding_collections.<span class="built_in">empty</span>())&#123;</span><br><span class="line">    tick_start=<span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//更新确认</span></span><br><span class="line">  por_abs_ackno=abs_ackno;</span><br><span class="line">  (<span class="type">void</span>)msg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该段设置为更新时间</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPSender::tick</span><span class="params">( <span class="type">const</span> <span class="type">size_t</span> ms_since_last_tick )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// Your code here.</span></span><br><span class="line">  <span class="comment">//是否建立启动了时钟,是否建立了连接</span></span><br><span class="line">  <span class="keyword">if</span>(!tick_start||!has_SYN)&#123;</span><br><span class="line">    <span class="comment">// cout &lt;&lt;n&lt;&lt; &quot;是否建立启动了时钟,是否建立了连接&quot;&lt;&lt;&quot;tick_start:&quot;&lt;&lt;tick_start&lt;&lt;&quot;,&quot;&lt;&lt;&quot;has_SYN:&quot;&lt;&lt;has_SYN&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// //测试temp</span></span><br><span class="line">  <span class="comment">// uint64_t temp=cur_time;</span></span><br><span class="line">  cur_time+=ms_since_last_tick;</span><br><span class="line">  <span class="comment">// cout &lt;&lt;n&lt;&lt; &quot;赋值时的时间&quot;&lt;&lt;&quot;cur_time:&quot;&lt;&lt;temp&lt;&lt;&quot;,&quot;&lt;&lt;&quot;ms_since_last_tick:&quot;&lt;&lt;cur_time-temp&lt;&lt;endl;</span></span><br><span class="line">  <span class="comment">//是没有超时的话返回</span></span><br><span class="line">  <span class="keyword">if</span>(cur_time&lt;RTO_ms_)&#123;</span><br><span class="line">    <span class="comment">// cout &lt;&lt;n&lt;&lt; &quot;是没有超时的话返回&quot;&lt;&lt;&quot;cur_time:&quot;&lt;&lt;cur_time&lt;&lt;&quot;,&quot;&lt;&lt;&quot;RTO_ms_:&quot;&lt;&lt;RTO_ms_&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//RTO退避</span></span><br><span class="line">  <span class="keyword">if</span>((window_size)&gt;<span class="number">0</span>)&#123;</span><br><span class="line">    RTO_ms_*=<span class="number">2</span>;</span><br><span class="line">    <span class="comment">//  cout &lt;&lt;n&lt;&lt; &quot;RTO退避&quot;&lt;&lt;&quot;RTO_ms_:&quot;&lt;&lt;RTO_ms_&lt;&lt;&quot;,&quot;&lt;&lt;&quot;window_size:&quot;&lt;&lt;window_size&lt;&lt;endl;</span></span><br><span class="line">  &#125;<span class="comment">//从新放到我们准备发送的deque</span></span><br><span class="line">  <span class="keyword">if</span>(!_outstanding_collections.<span class="built_in">empty</span>())&#123;</span><br><span class="line">    _ready_collections.<span class="built_in">push_front</span>(_outstanding_collections.<span class="built_in">front</span>());</span><br><span class="line">    retransmissions++;</span><br><span class="line">    cur_time=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//  cout &lt;&lt;n&lt;&lt; &quot;从新放到我们准备发送的deque&quot;&lt;&lt;&quot;cur_time:&quot;&lt;&lt;cur_time&lt;&lt;&quot;,&quot;&lt;&lt;&quot;retransmissions:&quot;&lt;&lt;retransmissions&lt;&lt;endl;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// cout&lt;&lt;n&lt;&lt;&quot;最后的所有参数一览&quot;&lt;&lt;&quot;ms_since_last_tick&quot;&lt;&lt;ms_since_last_tick&lt;&lt;&quot;,&quot;</span></span><br><span class="line">  <span class="comment">// &lt;&lt;&quot;has_SYN:&quot;&lt;&lt;has_SYN&lt;&lt;&quot;,&quot;</span></span><br><span class="line">  <span class="comment">// &lt;&lt;&quot;tick_start:&quot;&lt;&lt;tick_start&lt;&lt;&quot;,&quot;</span></span><br><span class="line">  <span class="comment">// &lt;&lt;&quot;cur_time:&quot;&lt;&lt;cur_time&lt;&lt;&quot;,&quot;</span></span><br><span class="line">  <span class="comment">// &lt;&lt;&quot;RTO_ms_:&quot;&lt;&lt;RTO_ms_&lt;&lt;&quot;,&quot;</span></span><br><span class="line">  <span class="comment">// &lt;&lt;&quot;retransmissions:&quot;&lt;&lt;retransmissions&lt;&lt;endl;</span></span><br><span class="line">  (<span class="type">void</span>)ms_since_last_tick;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p></div><div class="tab-item-content" id="test1-3"><p><strong>TCP_sender.hh</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;byte_stream.hh&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tcp_receiver_message.hh&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tcp_sender_message.hh&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TCPSender</span></span><br><span class="line">&#123;</span><br><span class="line">  Wrap32 isn_;</span><br><span class="line">  <span class="type">uint64_t</span> initial_RTO_ms_;</span><br><span class="line">  <span class="type">uint64_t</span> RTO_ms_;</span><br><span class="line">  <span class="type">uint64_t</span> window_size=<span class="number">1</span>;</span><br><span class="line">  <span class="type">uint64_t</span> cur_time=<span class="number">0</span>;<span class="comment">//这次的总毫秒数</span></span><br><span class="line">  <span class="type">uint64_t</span> abs_seqno=<span class="number">0</span>;<span class="comment">//记录下次的绝对位置</span></span><br><span class="line">  <span class="type">uint64_t</span> por_abs_ackno=<span class="number">0</span>;<span class="comment">//记录上次的绝对位置</span></span><br><span class="line">  <span class="type">uint64_t</span> abs_ackno=<span class="number">0</span>;<span class="comment">//记录下次的绝对位置</span></span><br><span class="line">  <span class="type">uint8_t</span> retransmissions=<span class="number">0</span>;<span class="comment">//记录重传次数</span></span><br><span class="line">  <span class="type">bool</span> tick_start=<span class="literal">false</span>;<span class="comment">//是否启动了时钟</span></span><br><span class="line">  <span class="type">bool</span> has_SYN=<span class="literal">false</span>;<span class="comment">//连接与否</span></span><br><span class="line">  <span class="type">bool</span> has_FIN=<span class="literal">false</span>;<span class="comment">//是否尝试断开</span></span><br><span class="line">  std::deque&lt;TCPSenderMessage&gt; _outstanding_collections=&#123;&#125;; <span class="comment">// 记录所有已发送未完成的段</span></span><br><span class="line">  std::deque&lt;TCPSenderMessage&gt; _ready_collections=&#123;&#125;;       <span class="comment">// 记录所有准备好发送的段</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">/* Construct TCP sender with given default Retransmission Timeout and possible ISN */</span></span><br><span class="line">   <span class="comment">/* 使用给定的默认重传超时和可能的ISN构造TCP发送者 */</span></span><br><span class="line">  <span class="built_in">TCPSender</span>( <span class="type">uint64_t</span> initial_RTO_ms, std::optional&lt;Wrap32&gt; fixed_isn );</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Push bytes from the outbound stream */</span></span><br><span class="line">  <span class="comment">/* 从出站流中推送字节 */</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">( Reader&amp; outbound_stream )</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Send a TCPSenderMessage if needed (or empty optional otherwise) */</span></span><br><span class="line">  <span class="comment">/* 如果需要发送TCPSenderMessage，则发送（否则返回空的optional） */</span></span><br><span class="line">  <span class="function">std::optional&lt;TCPSenderMessage&gt; <span class="title">maybe_send</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Generate an empty TCPSenderMessage */</span></span><br><span class="line">   <span class="comment">/* 生成一个空的TCPSenderMessage */</span></span><br><span class="line">  <span class="function">TCPSenderMessage <span class="title">send_empty_message</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Receive an act on a TCPReceiverMessage from the peer&#x27;s receiver */</span></span><br><span class="line">    <span class="comment">/* 接收并响应对端接收者的TCPReceiverMessage */</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">receive</span><span class="params">( <span class="type">const</span> TCPReceiverMessage&amp; msg )</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Time has passed by the given # of milliseconds since the last time the tick() method was called. */</span></span><br><span class="line">  <span class="comment">/* 自上次调用tick()方法以来，时间已经过去了给定的毫秒数 */</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">tick</span><span class="params">( <span class="type">uint64_t</span> ms_since_last_tick )</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Accessors for use in testing */</span></span><br><span class="line">    <span class="comment">/* 用于测试的访问器 */</span></span><br><span class="line">  <span class="function"><span class="type">uint64_t</span> <span class="title">sequence_numbers_in_flight</span><span class="params">()</span> <span class="type">const</span></span>;  <span class="comment">// How many sequence numbers are outstanding?// 有多少序列号正在传输中？</span></span><br><span class="line">  <span class="function"><span class="type">uint64_t</span> <span class="title">consecutive_retransmissions</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">// How many consecutive *re*transmissions have happened?// 发生了多少次连续的*重*传输？</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CS144 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS144-2</title>
      <link href="/posts/4a027220.html"/>
      <url>/posts/4a027220.html</url>
      
        <content type="html"><![CDATA[<h1 id="CS144-2"><a href="#CS144-2" class="headerlink" title="CS144-2"></a>CS144-2</h1><div class="tabs" id="test1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="test1-1">test1 1</button></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>检查</strong><br>在实验2之前，要保证之前的实验1已经通过测试<br><code>cmake --build build --target check 1</code>如果出现如下就可以继续实验了</p><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/屏幕截图-2023-12-04-223142.png"/></div></div></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div class="tabs" id="test1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="test1-1">test1 1</button></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>获取实验文件</strong><br><code>git fetch</code>来检索实验分配的最新版本<br><code>git merge origin/check2-startercode</code>然后同步这次的实验代码<br>在这一部分中，你需要实现TCPReceiver，和一个wrapping_integers这是我们整个实验中的端口的服务端和绝对/相对序列号的转换<br>在这实验之前，你需要了解报文中的确认号（ackno），序列号（seqno）以及连接请求（SYN）和断开请求（FIN），了解这些就足以应对这个实验。<br>你需要知道的是以上四个量在传递过程中的值的变化，最好是自己尝试画出来</p><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/屏幕截图-2023-12-05-125014-1024x678.png"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/屏幕截图-2023-1"/></div></div></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div class="tabs" id="test1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="test1-1">test1 1</button></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>实验开始</strong><br>首先这一部分难的地方并不在于去理解发送中的状态更新，而是在于如何在适当的时刻去利用相对位置和绝对位置这两个状态，而且要实现这两个转换个，如果在实现了转换的部分，同时如果这个在收发过程想明白，那么这个实验容易通过的。</p><p>首先你需要知道，当2的32次方超过就会溢出，如果是无符号型就会回滚到0，所以我们需要利用这一点，直接强转，让绝对位置变成相对位置。我当时对于unwrap的实现思路是算出有多少个循环（也就是2^32有多少个）然后把检查点左边的和右边的最近求出来，比较一下距离谁近就可以了。</p><p>关于这一部分，我之前的思路是直接用相对位置来比较检查点的距离，然后直接加上循环几圈，但是后面出现了端点是检查点的情况，以及端点是序列号的情况，这导致后面一直出现边界问题，所以倒不如直接求出来两个绝对位置，然后求他们到检查点的距离来得要巴适。</p><p>对于这一部分如果不清楚的话我们可以做一道题</p><p>时钟问题：一台机器每个一段时间都会记录累计的工作总小时数 m，每一个人只知道最后记得的工作时间在24刻度的时钟的 n 刻度上，小明现在只知道 n 和 m 如何求出总的工作实际数 g？</p><p>(m-n)%24就是求出从 n 到 m 有多少个完整的周期，然后 24 x (m-n)%24+n 就是最后的结果</p><p>换而 lab 2言之 (m-n)&gt;&gt;32&lt;&lt;32+n</p><p>这一部分可以琢磨一下，我当时琢磨了两天（泪目），当然实现起来还是以上的扩展版本，要多注意边界问题。</p><p>其次是你需要知道的结构体，第一个是TCP应答消息，第二个是TCP的发送消息</p><p>然后需要好好思考这些结构体的成员变量如何联系到本次实验的主题，以及如何在调用函数的时候用到他们，同时需要按F12去查看对应的成员变量类型是否有成员函数，清楚了这些函数作用可以极大减少代码量，这需要你自己去发现，因为这部分文档中也并没有直接给出来，估计故意是让大家思考的。</p><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/屏幕截图-2023-12-04-225439.png"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/屏幕截图-2023-12-04-225641.png"/></div></div>清楚其结构才能明白如何调用函数头文件中的辅助函数。我实现的过程也是很曲折的，一步一步整理思路，然后去调用F12去看代码实现，具体的思路过程可以看我粘贴在文末的代码注释，在此之前建议自己思考，这个思考过程才是提升自己的最好方式。接下来我复制文档的一部分（偷个懒）在 64 位索引和 32 位 seqno 之间转换作为热身，我们需要实现 TCP 的索引表示方式。上周你创建了一个重组器，它重新组装子字符串，每个独立的字节有一个 64 位的流索引，流中的第一个字节的索引总是零。一个 64 位的索引足够大以至于我们可以把它当作永不溢出。2^64 是真的大然而，在 TCP 头中，空间是宝贵的，并且流中的每个字节的索引不是用 64 位索引表示，而是用 32 位的“序列号”，或者“seqno”表示。这添加了三个复杂点：- 1.你的实现需要计划 32 位整数的环绕。TCP 中的流可以任意长——TCP 可以发送的 ByteStream 的长度没有限制。但是 2^32 字节只有 4 GiB，这并不大。一旦一个 32 位序列号计数到 2^32 - 1，流中的下一个字节将有序列号零。- 2.TCP 序列号从一个随机值开始：为了避免对早先在同一端点之间的连接的旧段产生混乱，TCP 试图确保序列号不能被猜测并且不太可能重复。因此，一个流的序列号不会从零开始。流中的第一个序列号是一个被称为初始序列号（ISN）的随机 32 位数。这是表示“零点”或 SYN（流的开始）的序列号。其余的序列号在此后表现正常：数据的第一个字节将有 ISN+1（mod 2^32）的序列号，第二个字节将有 ISN+2（mod 2^32）的序列号，等等。- 3.逻辑开始和结束每个占用一个序列号：除了确保收到所有的数据字节，TCP 还确保字节流的开始和结束可靠地被接收。因此，在 TCP 中，SYN（stream-beginning）和 FIN（stream-ending）控制标志被分配序列号。每个序列号占用一个序列号。（SYN 标志占用的序列号是 ISN。）流中的每个数据字节也占用一个序列号。记住，SYN 和 FIN 并不是流本身的一部分，它们不是“字节”——他们表示字节流本身的开始和结束。<div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/屏幕截图-2023-12-04-231234-1024x432.png"/></div></div></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div class="tabs" id="test1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="test1-1">test1 1</button></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>tcp_receiver.cc</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tcp_receiver.hh&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPReceiver::receive</span><span class="params">( TCPSenderMessage message, Reassembler&amp; reassembler, Writer&amp; inbound_stream )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  需要使用到的有inser函数</span></span><br><span class="line"><span class="comment">  ：</span></span><br><span class="line"><span class="comment">  Reassembler::insert( uint64_t first_index, string data, bool is_last_substring, Writer&amp; output )</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  绝对序号，data，是不是最后一个数据包，output系统</span></span><br><span class="line"><span class="comment">  而output是一个Writer类型，需要外界提供，所以目光在inbound_stream</span></span><br><span class="line"><span class="comment">  message.payload是数据字段</span></span><br><span class="line"><span class="comment">  所以写出来应该是</span></span><br><span class="line"><span class="comment">  reassembler.insert(message.seqno,message.payload,message.FIN,inbound_stream)</span></span><br><span class="line"><span class="comment">  但是应该分别为连接请求和确认和中间段包，和挥手包四种可能</span></span><br><span class="line"><span class="comment">  而reassembler.insert(message.seqno,message.payload,message.FIN,inbound_stream)</span></span><br><span class="line"><span class="comment">  已经包涵了FIN包的处理，以及SYN包的空包处理，也就是说，需要关心的也就first_index这个接口</span></span><br><span class="line"><span class="comment">  当SYN=1时是SYN包，此时没有数据，且设定了初始的绝对位置,此时应该是不需要传递到insert中的</span></span><br><span class="line"><span class="comment">  当SYN=0时是中间段，此时的seqno就是我们的数据index</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//此处我不知道SYN如果多发了几次要怎么处理，然后还是不同的情况下，一般来说一个是再开一个线程</span></span><br><span class="line"><span class="comment">//如果此时我们的SYN包接受到，那么我们保存我们已经接受到SYN包,保存一下状态，以及初始的序列号</span></span><br><span class="line">  <span class="keyword">if</span>(message.SYN)&#123;</span><br><span class="line">    <span class="comment">//如果接收到了就保存这个状态</span></span><br><span class="line">    SYN_received=<span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//第一次开启的时候会记录一下零点的位置</span></span><br><span class="line">    zero_point=message.seqno;</span><br><span class="line">    FIN_received=message.FIN;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  abs_seq=message.seqno.<span class="built_in">unwrap</span>( zero_point, inbound_stream.<span class="built_in">bytes_pushed</span>() );</span><br><span class="line">  <span class="comment">//排除掉我们可能出现的SYN情况，FIN包他本身就可以处理</span></span><br><span class="line">  <span class="keyword">if</span>(SYN_received)&#123;</span><br><span class="line">    <span class="comment">//insert接受的是下一个abs_seq的下标，而abs_seq是依据当前流系统接收的包，拆包后的长度-1是因为只改变index后的数据，以及是否是SYN包是为了包涵当开头时，是0，没有向前的下标了</span></span><br><span class="line">    reassembler.<span class="built_in">insert</span>( abs_seq+ message.SYN - <span class="number">1</span>,message.payload,message.FIN,inbound_stream);</span><br><span class="line">    <span class="keyword">if</span>(FIN_received)&#123;</span><br><span class="line">      <span class="comment">//后面可以用作半退出状态去接收数据</span></span><br><span class="line">      half_close=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TCPReceiverMessage <span class="title">TCPReceiver::send</span><span class="params">( <span class="type">const</span> Writer&amp; inbound_stream )</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  这里就应该发送SYN包和ACK包，问题是要一起发送还是发送两次？</span></span><br><span class="line"><span class="comment">  看了一下结构体确实是需要发送两次,但是他返回的就一种，那算了，就返回ACK包就行了</span></span><br><span class="line"><span class="comment">  直接通过返回来返回给对方？</span></span><br><span class="line"><span class="comment">  窗户应该设置多大？</span></span><br><span class="line"><span class="comment">  那么我认为inbound_stream似乎没有什么用</span></span><br><span class="line"><span class="comment">  然而是用来获取检查点的</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">   <span class="comment">//由于我们一次连接只需要对SYN响应一次，所以我们响应过一次就设置为false防止误用，这条废除，因为后续连接需要保存syn</span></span><br><span class="line">  TCPReceiverMessage message_ACK;</span><br><span class="line">  <span class="comment">//SYN包：</span></span><br><span class="line">  <span class="type">uint64_t</span> res = inbound_stream.<span class="built_in">available_capacity</span>();</span><br><span class="line">  message_ACK.window_size = res &gt; UINT16_MAX ? UINT16_MAX : res;</span><br><span class="line">  <span class="keyword">if</span>(!SYN_received)&#123;</span><br><span class="line">    <span class="keyword">return</span> message_ACK;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//这一步网上看到的是用inbound_stream.bytes_pushed当做要装包的数据，我寻思难道不是seqno？</span></span><br><span class="line">  <span class="comment">//这是因为seq插入后，不一定是完全的包，我们会经历合并等等操作，最后返回的应该是我们接受到的有效长度，所以用的是inbound_stream.bytes_pushed()</span></span><br><span class="line">  <span class="comment">//+1是为了当有效长度的一个确认，然后是否是FIN包，我们也需要确认如果是最后一个包，我们分别需要对其seq确认，和FIN包确认，</span></span><br><span class="line">  <span class="comment">//正版的是分开两次确认不知道为什么这两必须是同时合并一步确认</span></span><br><span class="line">  message_ACK.ackno=temp.<span class="built_in">wrap</span>( inbound_stream.<span class="built_in">bytes_pushed</span>() + <span class="number">1</span> + inbound_stream.<span class="built_in">is_closed</span>(), zero_point );</span><br><span class="line">   <span class="keyword">return</span> message_ACK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><br><strong><em>tcp_receiver.hh</em></strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reassembler.hh&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tcp_receiver_message.hh&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tcp_sender_message.hh&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TCPReceiver</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">TCPReceiver</span>():<span class="built_in">SYN_received</span>(<span class="literal">false</span>),<span class="built_in">half_close</span>(<span class="literal">false</span>),<span class="built_in">FIN_received</span>(<span class="literal">false</span>),<span class="built_in">zero_point</span>(<span class="number">0</span>),<span class="built_in">temp</span>(<span class="number">0</span>),<span class="built_in">abs_seq</span>(<span class="number">0</span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">TCPReceiver接收TCPSenderMessages，将它们的有效载荷插入到正确的流索引的Reassembler中。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">receive</span><span class="params">( TCPSenderMessage message, Reassembler&amp; reassembler, Writer&amp; inbound_stream )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* TCPReceiver将TCPReceiverMessages发送回TCPSender。 */</span></span><br><span class="line">  <span class="function">TCPReceiverMessage <span class="title">send</span><span class="params">( <span class="type">const</span> Writer&amp; inbound_stream )</span> <span class="type">const</span></span>;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">//是不是正在连接中</span></span><br><span class="line">  <span class="type">bool</span> SYN_received;</span><br><span class="line">  <span class="comment">//是不是完成了半关闭</span></span><br><span class="line">  <span class="type">bool</span> half_close;</span><br><span class="line">  <span class="comment">//用来标记结束</span></span><br><span class="line">  <span class="type">bool</span> FIN_received;</span><br><span class="line">  <span class="comment">//为ack数做准备</span></span><br><span class="line">  <span class="comment">//初始的绝对长度</span></span><br><span class="line">  Wrap32 zero_point;</span><br><span class="line">  Wrap32 temp;</span><br><span class="line">  <span class="type">uint64_t</span> abs_seq;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/屏幕截图-2023-12-05-125922-1024x218.png"/></div>&lt;/div&gt;<br><strong><em>wrapping_integers.cc</em></strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;wrapping_integers.hh&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">Wrap32 <span class="title">Wrap32::wrap</span><span class="params">( <span class="type">uint64_t</span> n, Wrap32 zero_point )</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> Wrap32 &#123; zero_point + <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(n) &#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//zero_point 是uint32_t类型</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">Wrap32::unwrap</span><span class="params">( Wrap32 zero_point, <span class="type">uint64_t</span> checkpoint )</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//求出序列号的循环中的绝对位置</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span> abs_seqno = <span class="built_in">static_cast</span>&lt;<span class="type">uint64_t</span>&gt;( <span class="keyword">this</span>-&gt;raw_value_ - zero_point.raw_value_ );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (abs_seqno&gt;checkpoint)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> abs_seqno;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里checkpoint&gt;&gt;32求出的是检查点的2的32次倍数，而checkpoint-abs_seqno求出的是从序列号到checkpoint的距离的周期数，相当于把abs_seqno置原点，重新求周期，求一个，从而和检查点处于同一个周期内</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//其实最重要的是吧检查点和序号的周期全部拿走，让其余检查点共处一个相对周期</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span> cycle=((checkpoint-abs_seqno)&gt;&gt;<span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span> r=<span class="built_in">static_cast</span>&lt;<span class="type">uint64_t</span>&gt;((<span class="number">1ull</span>&lt;&lt;<span class="number">32</span>)*(cycle+<span class="number">1</span>)+abs_seqno);</span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span> l=<span class="built_in">static_cast</span>&lt;<span class="type">uint64_t</span>&gt;((<span class="number">1ull</span>&lt;&lt;<span class="number">32</span>)*cycle+abs_seqno);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(checkpoint-l&gt;r-checkpoint)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">但是只需要相对的位置就可以了，因为假设我们的周期只有一个，那么检查点的相对序列和当前相对序列的距离如果大于周期的一半，</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">说明checkpoint更加接近另一个循环的点，而我们求的是向下取整的cycle，</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">所以我们后续去加上cycle的时候，是在检查点左侧最近的位置，</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">而如果我们的序列号相对位置是大于周期一半的话，</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">由于题目是说要求检查点最近的点，</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">那么肯定就是在检查点右边最近的，</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">也就是我们当前的绝对序列号的下一个周期，</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">所以要进位</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">由于相对周期要判断的条件太多，还不如选择暴力的最后判断，况且性能还行，就不需要这样做了</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><br><strong><em>wrapping_integers.hh</em></strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdint&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Wrap32类型代表一个32位无符号整数，该整数：</span></span><br><span class="line"><span class="comment">从一个任意的&quot;零点&quot;（初始值）开始，并且</span></span><br><span class="line"><span class="comment">当达到2^32 - 1时，回到零。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Wrap32</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="type">uint32_t</span> raw_value_ &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Wrap32</span><span class="params">( <span class="type">uint32_t</span> raw_value )</span> : raw_value_( raw_value ) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 构造一个 Wrap32，给定一个绝对序列号 n 和零点。*/</span></span><br><span class="line">  <span class="function"><span class="type">static</span> Wrap32 <span class="title">wrap</span><span class="params">( <span class="type">uint64_t</span> n, Wrap32 zero_point )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">unwrap方法返回一个绝对序列号，该序列号将包装到这个Wrap32，给定零点</span></span><br><span class="line"><span class="comment">以及一个&quot;检查点&quot;：接近期望答案的另一个绝对序列号。</span></span><br><span class="line"><span class="comment">有许多可能的绝对序列号都包装到同一个Wrap32。</span></span><br><span class="line"><span class="comment">unwrap方法应该返回最接近检查点的那个。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">uint64_t</span> <span class="title">unwrap</span><span class="params">( Wrap32 zero_point, <span class="type">uint64_t</span> checkpoint )</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">  Wrap32 <span class="keyword">operator</span>+( <span class="type">uint32_t</span> n ) <span class="type">const</span> &#123; <span class="keyword">return</span> Wrap32 &#123; raw_value_ + n &#125;; &#125;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>==( <span class="type">const</span> Wrap32&amp; other ) <span class="type">const</span> &#123; <span class="keyword">return</span> raw_value_ == other.raw_value_; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CS144 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS144-1</title>
      <link href="/posts/d30b239a.html"/>
      <url>/posts/d30b239a.html</url>
      
        <content type="html"><![CDATA[<h1 id="CS144-1"><a href="#CS144-1" class="headerlink" title="CS144-1"></a>CS144-1</h1><div class="tabs" id="test1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="test1-1">test1 1</button></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>前言</strong><br><code>cmake --build build --target check 0</code>来检查你的lab0后就可以开始这部分的实验了<br>事实上对于这部分实验，在我整个实验中花费的时间是最长的，代码也是最长的，而且即使通过了，后续的实验中，也会由于这部分导致超时，而无法通过。所以参考了其他大佬的思路才通过了这部分的测试</p><p>这是我参考的大佬的链接，需要代码的可以去他那边看看<code>https://github.com/Mobuiss</code></p><p>目前大多数对于这一题的思路就是重复子串的合并，我一开始想到的也是用map来实现这个过程，但是后面写得也很长，性能很低。大佬的思路就不一样了，是用一个vector来维护buffer，下面详细讲。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div class="tabs" id="test1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="test1-1">test1 1</button></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>实验开始</strong><br>这个实验的主体是通过insert这个函数实现的 </p><p>它的传参有</p><p><code>uint64_t first_index</code> <code>string data</code> <code>bool is_last_substring</code> <code>Writer&amp; output</code></p><p>first_index是每一个data绝对位置，也就是类似于leetcode中合并区间的区间下标。data就是数据本身，可以调用.size来获取长度，is_last_substring就是问是否是最后一个数据段,output是一个输出接口，调用output.push（）就可以把完整的数据段输出。</p><p>实现过程：</p><p>先是看是否是最后一段数据，如果是就设置保存一下，后面可以用来作为结束的依据。</p><p>然后就是判断是否是过于新或者过于旧的片段我们就不要</p><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/屏幕截图-2023-12-06-205242.png"/></div></div>如果是旧消息（原作者意思是设置左边界）或者新消息（原作者是设置右边界）我们就截取窗口位置<div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/屏幕截图-2023-12-06-205538.png"/></div></div>他在实现右边界是比较有意思的，由于之前排除掉就消息，只剩下刚刚好符合的消息，和新消息，通过min函数来判断是否符合容量去实现的。也就是新消息和刚好落在窗口内的消息一起判断了<div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/M0UPLX1HSOJSQ0N63JDY4.png"/></div></div>后面的思路也是让让拍案叫绝，是通过一个vector来维护一串数字，这些数字可以转换成char类型，把符合条件的消息全部转换成int放到vecotr中，然后通过一个随机固定的数字val填充为填充的，原作者用的值，咳咳(笑而不语)。然后如果需要的下标不是val的值（也就是恰好等于我们的需要的下标）则把其后面连续的都放到buffer中<div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/C79TGM1QIOJZ464BH.png"/></div></div>具体实现可以去看原作者是如何做的，接下来我讲另一种思路也就是我一开始想做的，也是绝大多数人的思路经历和上面一样的筛选步骤后存入后由于map会自动排序，会形成如下（实际上维护可能只有两到三个左右的消息段，这里为了演示画多一点）<div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/EHS39GNTQ6Y70ZQ188T1-202x300.png"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/0C6LZBWIM89AEUVMQXF.png"/></div></div>然后会通过辅助函数来将所有的片段拍在一起，其中涉及到左合并和右合并<div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/L70S1R0FXCDLJXAGOFB-e1702352108675.png"/></div></div></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><p>然后回放到map中（图中有可能结果有多个不相邻的判断，不一定是只有一个），下次放入判断前重新检查一下是否有新的片段成为了需要的下标，就推送到output里</p><p>由于笔者写的这部分代码确实不太好，所以如果想参考的话可以去我上面推荐的作者或者其他博客看看。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CS144 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS144-0</title>
      <link href="/posts/a40c130c.html"/>
      <url>/posts/a40c130c.html</url>
      
        <content type="html"><![CDATA[<h1 id="CS144-0"><a href="#CS144-0" class="headerlink" title="CS144-0"></a>CS144-0</h1><p>由于没有学校的邮箱，前面虚拟机交流也很简单，直接从代码发送阶段开始。<br><div class="tabs" id="test1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="test1-1">test1 1</button><button type="button" class="tab " data-href="test1-2">test1 2</button></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>1.编写报文</strong><br>实验步骤：</p><p>在你的虚拟机上，获取实验的源代码: <code>git clone https://github.com/cs144/minnow</code></p><p>进入 Lab 0 目录: <code>cd minnow</code></p><p>创建一个目录来编译实验室软件: <code>cmake -S . -B build</code></p><p>编译源代码: <code>cmake --build build</code></p><p>在构建目录外部，打开并开始编辑 <code>writeups/check 0. Md 文件。</code></p><p>在文件 <code>../apps/webget. cc</code> 中，找到并实现 get_URL 函数。你需要使用 HTTP 协议，使用 TCPSocket 和 Address 类。<br><span class='p red'>这里会出现的问题是克隆GitHub库的时候，由于网络问题克隆不了，建议多尝试，不推荐直接从GitHub库下载后导入虚拟机，因为后续需要同步新的实验，会由于git库的归属问题，导致无法同步。</span></p><p>做这一部分以前，要先有Http报文的前置知识，了解整个http的报文结构，才能完成这一部分的实验</p></div><div class="tab-item-content" id="test1-2"><p><strong>知识点</strong><br><a class="btn-anzhiyu " href="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/87812_FUF8PO1PX9DM3E-1024x639.png"   title=""><i class="anzhiyufont anzhiyu-icon-circle-arrow-right"></i></a><br><a class="btn-anzhiyu " href="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/MMWT9GZ0MBZEGUC073KU-1024x334.png"   title=""><i class="anzhiyufont anzhiyu-icon-circle-arrow-right"></i></a></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div></p><div class="tabs" id="test1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="test1-1">test1 1</button><button type="button" class="tab " data-href="test1-2">test1 2</button><button type="button" class="tab " data-href="test1-3">test1 3</button></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>1.1发送get报文</strong><br>在这个实验中，只需要发送最简单的GET报文请求即可，即写一段字符串，包含GET，HTTP类型，Host接口，以及最后的连接关闭。</p><p>这部分代码并不难，我会放在文章的末尾，在此之前如果你只是过来看思路，可以自己先思考一下，需要注意的是每一个元素之间需要有一个空格以及最后也需要一个换行，细节上需要去留意。</p><p>之后我们在控制台make我们的代码</p></div><div class="tab-item-content" id="test1-2"><p><strong>测试</strong><br>通过运行 <code>./apps/webget cs144.keithw.org /hello</code> 来测试程序。你可以实验不同的 http URL。比如说 <code>./apps/webget www.baidu.com /hello</code><br><a class="btn-anzhiyu " href="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/PQWU7GDORQ_039M@F1L-1024x450.png"   title=""><i class="anzhiyufont anzhiyu-icon-circle-arrow-right"></i></a></p></div><div class="tab-item-content" id="test1-3"><p><strong>自动化测试</strong><br>然后运行 <code>cmake --build build --target check_webget</code> 进行自动测试。<br><a class="btn-anzhiyu " href="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/NXXCAKXEKMW6DLM465-1024x428.png"   title=""><i class="anzhiyufont anzhiyu-icon-circle-arrow-right"></i></a></p><p>当看到两个测试用例通过，代表你可以继续下一步的实验了，打开 <code>src/byte stream.hh</code> 和 <code>src/byte stream.cc</code> 文件，实现给定接口的对象。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div class="tabs" id="test1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="test1-1">test1 1</button></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>2.实现字节系统</strong><br>我提供一些简单的接口描述</p><div class='checkbox'><input type="checkbox" />            <p>void push( std::string data ); // 将数据推入流中，但只推入可用容量的数据。</p>            </div><div class='checkbox'><input type="checkbox" />            <p>void close(); // 表示流已经结束，不会有更多数据写入。; // 将数据推入流中，但只推入可用容量的数据。</p>            </div><div class='checkbox'><input type="checkbox" />            <p>void set_error(); // 表示流出现错误。</p>            </div><div class='checkbox'><input type="checkbox" />            <p>bool is_closed() const; // 判断流是否已关闭。</p>            </div><div class='checkbox'><input type="checkbox" />            <p>uint64_t available_capacity() const; // 当前可以推入流的字节数。</p>            </div><div class='checkbox'><input type="checkbox" />            <p>uint64_t bytes_pushed() const; // 已推入流的总字节数。</p>            </div># 读取者接口：<div class='checkbox'><input type="checkbox" />            <p>void pop( uint64_t len ); // 从缓冲区移除 len 字节。</p>            </div><div class='checkbox'><input type="checkbox" />            <p>bool is_finished() const; // 判断流是否已完成（关闭并完全弹出）。</p>            </div><div class='checkbox'><input type="checkbox" />            <p>bool has_error() const; // 判断流是否发生过错误。</p>            </div><div class='checkbox'><input type="checkbox" />            <p>uint64_t bytes_buffered() const; // 当前缓冲的字节数量（推入但尚未弹出的）。</p>            </div><div class='checkbox'><input type="checkbox" />            <p>uint64_t bytes_popped() const; // 已从流中弹出的总字节数。</p>            </div><p>这一部分我总体的实现思路是，直接通过原生的string作为buffer，然后通过设置一些变量在头文件中记录状态，比如poped函数就可以直接返回这些状态。具体代码我会放在文末，或者您可以访问我的GitHub，来获得代码。</p><p>然后通过使用 <code>cmake --build build --target check0</code> 命令运行自动化测试。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div class="tabs" id="test1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="test1-1">test1 1</button><button type="button" class="tab " data-href="test1-2">test1 2</button><button type="button" class="tab " data-href="test1-3">test1 3</button></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>代码</strong></p><h3 id="webget-cc"><a href="#webget-cc" class="headerlink" title="webget.cc"></a>webget.cc</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;socket.hh&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;span&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;string&gt;MoreRequest;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_URL</span><span class="params">( <span class="type">const</span> string&amp; host, <span class="type">const</span> string&amp; path )</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">      <span class="function">Address <span class="title">addr</span><span class="params">(host,<span class="string">&quot;http&quot;</span>)</span></span>;</span><br><span class="line">      TCPSocket tcp_socket;<span class="comment">//建立套接字，用来连接（有了插坐）</span></span><br><span class="line"> <span class="keyword">try</span>&#123;</span><br><span class="line">        tcp_socket.<span class="built_in">connect</span>(addr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> ( <span class="type">const</span> exception&amp; e ) &#123;</span><br><span class="line">    cerr &lt;&lt; <span class="string">&quot;Unable to connect:&quot;</span>&lt;&lt;e.<span class="built_in">what</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">    string DefaultRequest=<span class="string">&quot;GET&quot;</span>;</span><br><span class="line">    string ConnectionHead = <span class="string">&quot;Close&quot;</span>;</span><br><span class="line">    string CacheControlHead=<span class="string">&quot;no-cache&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!MoreRequest.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">for</span>(string &amp;str:MoreRequest)&#123;</span><br><span class="line">        CacheControlHead+=(<span class="string">&quot;,&quot;</span>+str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">RequestHead</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    DefaultRequest+<span class="string">&quot; &quot;</span>+path+ <span class="string">&quot; HTTP/1.1\r\n&quot;</span> )</span></span>;</span><br><span class="line">    RequestHead+=<span class="string">&quot;Host: &quot;</span> + host+ <span class="string">&quot;\r\n&quot;</span>;</span><br><span class="line">    RequestHead+=<span class="string">&quot;Cache-Control: &quot;</span> + CacheControlHead + <span class="string">&quot;\r\n&quot;</span>;</span><br><span class="line">    RequestHead+=<span class="string">&quot;Connection: &quot;</span> + ConnectionHead + <span class="string">&quot;\r\n\r\n&quot;</span>;</span><br><span class="line">    tcp_socket.<span class="built_in">write</span>(RequestHead);</span><br><span class="line">    string outinfo;</span><br><span class="line">  tcp_socket.<span class="built_in">read</span>( outinfo );</span><br><span class="line">  <span class="keyword">while</span> ( !outinfo.<span class="built_in">empty</span>() ) &#123;</span><br><span class="line">    cout &lt;&lt; outinfo;</span><br><span class="line">    tcp_socket.<span class="built_in">read</span>( outinfo );</span><br><span class="line">  &#125;</span><br><span class="line">    tcp_socket.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">( <span class="type">int</span> argc, <span class="type">char</span>* argv[] )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ( argc &lt;= <span class="number">0</span> ) &#123;</span><br><span class="line">      <span class="built_in">abort</span>(); <span class="comment">// For sticklers: don&#x27;t try to access argv[0] if argc &lt;= 0.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> args = <span class="built_in">span</span>( argv, argc );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The program takes two command-line arguments: the hostname and &quot;path&quot; part of the URL.</span></span><br><span class="line">    <span class="comment">// Print the usage message unless there are these two arguments (plus the program name</span></span><br><span class="line">    <span class="comment">// itself, so arg count = 3 in total).</span></span><br><span class="line">    <span class="keyword">if</span> ( argc != <span class="number">3</span> ) &#123;</span><br><span class="line">      cerr &lt;&lt; <span class="string">&quot;Usage: &quot;</span> &lt;&lt; args.<span class="built_in">front</span>() &lt;&lt; <span class="string">&quot; HOST PATH\n&quot;</span>;</span><br><span class="line">      cerr &lt;&lt; <span class="string">&quot;\tExample: &quot;</span> &lt;&lt; args.<span class="built_in">front</span>() &lt;&lt; <span class="string">&quot; stanford.edu /class/cs144\n&quot;</span>;</span><br><span class="line">      <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get the command-line arguments.</span></span><br><span class="line">    <span class="type">const</span> string host &#123; args[<span class="number">1</span>] &#125;;</span><br><span class="line">    <span class="type">const</span> string path &#123; args[<span class="number">2</span>] &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call the student-written function.</span></span><br><span class="line">    <span class="built_in">get_URL</span>( host, path );</span><br><span class="line">  &#125; <span class="built_in">catch</span> ( <span class="type">const</span> exception&amp; e ) &#123;</span><br><span class="line">    cerr &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="test1-2"><h3 id="bytestream-cc"><a href="#bytestream-cc" class="headerlink" title="bytestream.cc"></a>bytestream.cc</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;byte_stream.hh&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">ByteStream::<span class="built_in">ByteStream</span>( <span class="type">uint64_t</span> capacity ) : <span class="built_in">capacity_</span>( capacity ) &#123;&#125;</span><br><span class="line"><span class="type">static</span>  <span class="type">size_t</span> SHUT_RDWR=<span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Writer::push</span><span class="params">( string data )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;ByteStreamState==SHUT_RDWR)&#123;</span><br><span class="line">  <span class="built_in">set_error</span>();</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">uint64_t</span> <span class="title">datasize</span><span class="params">(data.size())</span></span>;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;headroom_&lt;datasize)&#123;</span><br><span class="line">  <span class="built_in">set_error</span>();</span><br><span class="line">  datasize=<span class="keyword">this</span>-&gt;headroom_;</span><br><span class="line">  data.<span class="built_in">resize</span>(datasize);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>-&gt;buffer+=data;</span><br><span class="line">  <span class="keyword">this</span>-&gt;buffered+=datasize;</span><br><span class="line">  <span class="keyword">this</span>-&gt;pushed+=datasize;</span><br><span class="line">  <span class="keyword">this</span>-&gt;headroom_-=datasize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Writer::close</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;ByteStreamState==SHUT_RDWR)&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>-&gt;ByteStreamState=SHUT_RDWR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Writer::set_error</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// unsigned int WriteOFF_0</span></span><br><span class="line">  <span class="comment">// unsigned int Overflow_1</span></span><br><span class="line">  <span class="comment">// unsigned int ReadOFF_2</span></span><br><span class="line">  <span class="keyword">this</span>-&gt;errorsize++;</span><br><span class="line">  <span class="comment">// string WriteOFF=&quot;Unable to write because write has been turned off&quot;;</span></span><br><span class="line">  <span class="comment">// string Overflow=&quot;Data exceeds the maximum limit&quot;;</span></span><br><span class="line">  <span class="comment">// string ReadOFF=&quot;Unable to read because read has been turned off&quot;;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Writer::is_closed</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;ByteStreamState==SHUT_RDWR)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">Writer::available_capacity</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>-&gt;headroom_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">Writer::bytes_pushed</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>-&gt;pushed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string_view <span class="title">Reader::peek</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">string_view</span>(<span class="keyword">this</span>-&gt;buffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Reader::is_finished</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;ByteStreamState==SHUT_RDWR&amp;&amp;buffered==<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Reader::has_error</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;errorsize!=<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Reader::pop</span><span class="params">( <span class="type">uint64_t</span> len )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(len&lt;<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(len&gt;<span class="keyword">this</span>-&gt;buffered)</span><br><span class="line">  &#123;</span><br><span class="line">    len=<span class="keyword">this</span>-&gt;buffered;</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="keyword">this</span>-&gt;buffer.<span class="built_in">erase</span>(<span class="number">0</span>, len);</span><br><span class="line">   <span class="keyword">this</span>-&gt;buffered-=len;</span><br><span class="line">   <span class="keyword">this</span>-&gt;headroom_+=len;</span><br><span class="line">   <span class="keyword">this</span>-&gt;poped+=len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">Reader::bytes_buffered</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>-&gt;buffered;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">Reader::bytes_popped</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>-&gt;poped;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="test1-3"><h3 id="bytestream-hh"><a href="#bytestream-hh" class="headerlink" title="bytestream.hh"></a>bytestream.hh</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string_view&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Reader</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Writer</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ByteStream</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> errorsize=<span class="number">0</span>;</span><br><span class="line">  <span class="type">uint64_t</span> capacity_;</span><br><span class="line">  <span class="type">uint64_t</span> buffered=<span class="number">0</span>;</span><br><span class="line">  <span class="type">uint64_t</span> pushed=<span class="number">0</span>;</span><br><span class="line">  <span class="type">uint64_t</span> poped=<span class="number">0</span>;</span><br><span class="line">  <span class="type">uint64_t</span> headroom_=capacity_;</span><br><span class="line">  std::string buffer&#123;&#125;;</span><br><span class="line">  <span class="type">size_t</span> ByteStreamState=<span class="number">4</span>;</span><br><span class="line">  <span class="comment">// Please add any additional state to the ByteStream here, and not to the Writer and Reader interfaces.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">ByteStream</span><span class="params">( <span class="type">uint64_t</span> capacity )</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Helper functions (provided) to access the ByteStream&#x27;s Reader and Writer interfaces</span></span><br><span class="line">  <span class="function">Reader&amp; <span class="title">reader</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">const</span> Reader&amp; <span class="title">reader</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function">Writer&amp; <span class="title">writer</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">const</span> Writer&amp; <span class="title">writer</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Writer</span> : <span class="keyword">public</span> ByteStream</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">( std::string data )</span></span>; <span class="comment">// Push data to stream, but only as much as available capacity allows.</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span></span>;     <span class="comment">// Signal that the stream has reached its ending. Nothing more will be written.</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">set_error</span><span class="params">()</span></span>; <span class="comment">// Signal that the stream suffered an error.</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">is_closed</span><span class="params">()</span> <span class="type">const</span></span>;              <span class="comment">// Has the stream been closed?</span></span><br><span class="line">  <span class="function"><span class="type">uint64_t</span> <span class="title">available_capacity</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">// How many bytes can be pushed to the stream right now?</span></span><br><span class="line">  <span class="function"><span class="type">uint64_t</span> <span class="title">bytes_pushed</span><span class="params">()</span> <span class="type">const</span></span>;       <span class="comment">// Total number of bytes cumulatively pushed to the stream</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Reader</span> : <span class="keyword">public</span> ByteStream</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">std::string_view <span class="title">peek</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">// Peek at the next bytes in the buffer</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">( <span class="type">uint64_t</span> len )</span></span>;      <span class="comment">// Remove `len` bytes from the buffer</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">is_finished</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">// Is the stream finished (closed and fully popped)?</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">has_error</span><span class="params">()</span> <span class="type">const</span></span>;   <span class="comment">// Has the stream had an error?</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">uint64_t</span> <span class="title">bytes_buffered</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">// Number of bytes currently buffered (pushed and not popped)</span></span><br><span class="line">  <span class="function"><span class="type">uint64_t</span> <span class="title">bytes_popped</span><span class="params">()</span> <span class="type">const</span></span>;   <span class="comment">// Total number of bytes cumulatively popped from stream</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * read: A (provided) helper function thats peeks and pops up to `len` bytes</span></span><br><span class="line"><span class="comment"> * from a ByteStream Reader into a string;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">( Reader&amp; reader, <span class="type">uint64_t</span> len, std::string&amp; out )</span></span>;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CS144 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS144前言</title>
      <link href="/posts/db34f9f3.html"/>
      <url>/posts/db34f9f3.html</url>
      
        <content type="html"><![CDATA[<div class="tabs" id="test1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="test1-1">test1 1</button><button type="button" class="tab " data-href="test1-2">test1 2</button></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>CS144 - 前言</strong><br>在我开始深入CS144这门课程之前，我必须先声明一下 —— 我并非什么大佬。实际上，我在网络系统这方面的旅程才刚刚开始，有时候，我自己也还在为之前的认知感到惊讶。毕竟，将书本知识转化为可以在真实世界中运行的代码是一条充满挑战的路。我分享的内容，可能不见得是行业内的最优解，但至少代表了我的一点小小见解，希望能给你提供一些不同的思考角度。</p></div><div class="tab-item-content" id="test1-2"><p><strong>小声逼逼</strong></p><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/d9f7af772a7bd52f9f904d06899f5d151788e195.jpg@1256w_1256h_!web-article-pic.avif" alt="说白了，别嫌我太菜。"/></div><span class="image-caption">说白了，别嫌我太菜。</span></div></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div class="tabs" id="test1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="test1-1">test1 1</button></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>原地址</strong><br>好，正题来了，这是CS144课程的官方链接<a class="btn-anzhiyu " href="https://cs144.github.io/"   title="CS144"><span>CS144</span></a> 强烈推荐给像我一样对网络系统感兴趣的朋友们。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div class="tabs" id="test1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="test1-1">test1 1</button></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>心路历程(废话 busi)</strong><br>开始实操这门课的项目时，我真的遇到了不少的阻力。以前我更多的是书面上的学习，对概念和理论比较了解，但在动手实现它们的时候，突然间好像有一面墙立在了我的面前，让我手足无措，反反复复在文档与之前学过的知识对照，又双叒叕地与bug和失败结果打交道。程序员嘛，谁没有过在编译器前哭泣的时候呢？</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div class="tabs" id="test1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="test1-1">test1 1</button><button type="button" class="tab " data-href="test1-2">test1 2</button></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>有所所获</strong><br>这个过程中，我学到了很多东西——不仅仅是知识上的收获，更多的是在面对问题和困难时，如何保持冷静，如何一步步地解决问题。我不得不说，这些经验是十分宝贵的，它们磨练了我的耐心和毅力，也让我对计算机网络的理解更加深刻。</p></div><div class="tab-item-content" id="test1-2"><p><strong>持续进步</strong><br>在不断的尝试和失败中，我领悟到了计算机网络的复杂性，也见证了代码的力量。每一次debug，每一次代码的修改，都让我对初看起来高不可攀的网络协议有了一点点新的理解。通过实际编写和实现代码，我开始真正感受到了协议之间的美妙互动和逻辑上的严谨性。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div class="tabs" id="test1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="test1-1">test1 1</button></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>讲给你们</strong><br>我希望可以把这份乐趣和收获分享给每一个读到这篇博客的你。不管你现在是一个处于编程起步阶段的新手，还是一直在寻找新知和挑战的资深开发者，我都相信CS144能给你带来一些新的启发。别忘了，最好的学习方式，往往是直接跳进来，动手去做，去体验，像游泳一样，旱地学泳是不可以的，拘泥于书本也是不可以的。</p><p>所以，让我们一起继续这趟探索之旅吧。接下来的篇章，我会深入分享我在实现CS144项目中的具体经历和收获。希望我的旅程可以给你带来一些帮助，也期待听到你的故事和成长。别怕起步难，我们都在这条路上！</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><p>以下是中文文档，你可以通过中英来更好的理解文档。</p><a class="btn-anzhiyu " href="https://huanxue.love/230-2/"   title="旧站文档"><i class="anzhiyufont anzhiyu-icon-circle-arrow-right"></i><span>旧站文档</span></a>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CS144 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nullpot</title>
      <link href="/posts/d1c40c5e.html"/>
      <url>/posts/d1c40c5e.html</url>
      
        <content type="html"><![CDATA[<style>#article-container a:not(.headerlink, .fancybox, .default-style a) {    font-weight: 700;    color: var(--font-color);    padding: 0 3px;    border-bottom: 2px var(--leonus-main) solid;}#article-container a:not(.headerlink, .fancybox, .default-style a):hover {    color: #fff;    border-radius: 5px;    text-decoration: none;    background-color: var(--leonus-main);}#danmu {    width: 100%;    height: calc(100% - 60px);    position: fixed;    left: 0;    top: 60px;    z-index: 1;    pointer-events: none;}.hidedanmu {    opacity: 0;}.hidedanmu * {    pointer-events: none !important;}div#danmuBtn {    display: flex;    justify-content: center;}div#danmuBtn button {    background: var(--leonus-main);    color: white;    padding: 8px 20px;    margin: 0 20px;    border-radius: 100px;}.default-style {    pointer-events: all;    cursor: pointer;    font-size: 16px;    border-radius: 100px;    overflow: hidden;}.default-style a {    background-color: rgba(0, 0, 0, 0.5);    transition: .3s;    color: #eee !important;    display: flex;    align-items: center;    justify-content: center;    padding: 6px 16px 6px 6px;    text-decoration: none !important;}.default-style a:hover {    background-color: rgba(0, 0, 0, 0.7);}.default-style img {    pointer-events: none;    height: 30px;    width: 30px;    margin: 0 5px 0 0 !important;    border-radius: 50% !important;}.default-style p {    line-height: 1;    pointer-events: none;    margin: 0 !important;    max-width: 300px;    white-space: nowrap;    overflow: hidden;    text-overflow: ellipsis;}</style><div class="note success flat"><p>如果有什么 <strong>想说的</strong>、<strong>想问的</strong> 或者 <strong>发现了本站的BUG</strong>，欢迎留言告知😊。</p></div><div class="note pink icon-padding flat"><i class="note-icon fa-solid fa-link"></i><p>若想 <strong>添加友链</strong> 请前往 <a href="/link/">友情链接</a> 页面进行友链申请😄</p></div><div id="danmuBtn"></div><div id="danmu"></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Greetings, Universe!</title>
      <link href="/posts/534e3aec.html"/>
      <url>/posts/534e3aec.html</url>
      
        <content type="html"><![CDATA[<h1 id="该网站的诞生"><a href="#该网站的诞生" class="headerlink" title="该网站的诞生"></a>该网站的诞生</h1><p>从前，在Echo的小窝里，有一群聪明的猫猫虫<br><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/4353.gif" style="width:400px;"/></div></div><br>猫猫虫们聪明又可爱，他们相亲相爱<br><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/2579762.gif" style="width:400px;"/></div></div><br>，互相交流建站的经验，和生活琐事。<br><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/50.gif" style="width:400px;"/></div></div><br>有一天，有一只猫猫发现了不得了的事情<br><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/30.gif" style="width:400px;"/></div></div><br>人家隔壁的石头搭建的窝也太好看了吧<br><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/20211115204431_27525.jpeg" style="width:400px;"/></div></div><br>猫猫们也想要那样的一个窝，但是目前的窝又是猫猫们舍不得的，这可把猫猫们急的呀团团转<div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/80.gif" style="width:400px;"/></div></div><br>怎么办？<br><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/254623.jpg" style="width:400px;"/></div></div><br>怎么办？<br><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/3454s6443.jpg" style="width:400px;"/></div></div><br>突然聪明的猫猫们想出了一个办法<br>小孩子才做选择，猫猫们全都要<br>于是本站诞生啦！<br><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/huanxueshengmou/picture-host/5435354.gif" style="width:400px;"/></div></div></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
