<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>喂饭级，通过内网穿透自动拉取git仓库代码</title>
      <link href="/posts/309fd10a.html"/>
      <url>/posts/309fd10a.html</url>
      
        <content type="html"><![CDATA[<div class="tabs" id="uniquename1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename1-1"><i class="icon"></i>思路</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename1-1"><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>通过 github 的 webhook 来通知本地拉取代码<br>本地通过 ngrok 开放端口，并且设置一个服务器对该端口进行监听<br>在监听服务器当中设置下拉操作和对非 github webhook 的操作进行过滤处理</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div class="tabs" id="uniquename2"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename2-1"><i class="icon"></i>有什么用</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename2-1"><h3 id="有什么用"><a href="#有什么用" class="headerlink" title="有什么用"></a>有什么用</h3><p>因为大部分人是没有公网 ip 的，更多是本地电脑的操作代码，所以好处在于，只要设置好 hook，那么团队的操作将不需要自己 pull (如果不喜欢 pull 自己改)，自动同步代码。</p><p>如果是服务器，那么省略掉 ngrok，直接监听端口，可以完成持续性集成的操作</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div class="tabs" id="uniquename3"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename3-1"><i class="icon"></i>注册一个 ngrok</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename3-1"><h3 id="注册一个-ngrok"><a href="#注册一个-ngrok" class="headerlink" title="注册一个 ngrok"></a>注册一个 ngrok</h3><p>去官网注册一个账号 <a href="https://ngrok.com/">https://ngrok.com/</a><br>这里 qq 的邮箱是不可以的，如果有谷歌的账号就直接注册跳到如何使用 ngrok</p><p>如果没有谷歌账号那么看下一步<br>去注册这个邮箱 <a href="https://app.tuta.com">https://app.tuta.com</a><br><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/20241124150811.png" alt=""><br>然后再去注册，回到邮箱收到如下<br><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/20241124151130.png" alt=""><br>把 https 的部分复制出来访问即可激活 ngrok</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div class="tabs" id="uniquename4"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename4-1"><i class="icon"></i>如何使用 ngrok</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename4-1"><h3 id="如何使用-ngrok"><a href="#如何使用-ngrok" class="headerlink" title="如何使用 ngrok"></a>如何使用 ngrok</h3><p><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/20241124151331.png" alt=""><br>这样就是注册成功了，然后我们点击跳过，到 win 的下载页面（mac 选 mac，linux 选 linux）<br><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/20241124151506.png" alt=""><br>下载好选一个地方解压，这个地方日后作为你启动该内网穿透的地方<br>解压完后会出现一个可执行文件<br><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/20241124151813.png" alt=""><br>在地址栏输入 cmd<br>然后把刚刚的<br><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/20241124152017.png" alt=""><br>粘贴到 cmd 当中执行</p><p>出现如图就是成功了，并且以后你可以修改其中的值<br>![[Pasted image 20241124152109.png]]<br>值参考官网 <a href="https://ngrok.com/docs/agent/config/">https://ngrok.com/docs/agent/config/</a><br>不过默认不需要修改</p><p>再执行 <code>ngrok http 8080</code><br>出现如下就是可以了，蓝色箭头的是提供给外部访问的地址<br><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/20241124152403.png" alt=""></p><p>自行在其他手机端或者其他端测试该地址是否可以访问</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div class="tabs" id="uniquename5"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename5-1"><i class="icon"></i>配合 github 钩子</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename5-1"><h3 id="配合-github-钩子"><a href="#配合-github-钩子" class="headerlink" title="配合 github 钩子"></a>配合 github 钩子</h3><p>Server 监听端口，内网穿透修改对应端口，即可在外部访问</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div class="tabs" id="uniquename6"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename6-1"><i class="icon"></i>Server 端代码</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename6-1"><h3 id="Server-端代码"><a href="#Server-端代码" class="headerlink" title="Server 端代码"></a>Server 端代码</h3><p>依赖express 和 node<br>安装 node <a href="https://nodejs.org/en/download/package-manager">https://nodejs.org/en/download/package-manager</a><br>安装 <code>npm install express</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入必要的模块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; exec &#125; = <span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置服务器端口号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">PORT</span> = <span class="number">3000</span>;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于解析 application/json 和 application/x-www-form-urlencoded 数据</span></span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">json</span>());</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">urlencoded</span>(&#123; <span class="attr">extended</span>: <span class="literal">true</span> &#125;));</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment">// GitHub Webhook 处理路由</span></span><br><span class="line"></span><br><span class="line">app.<span class="title function_">post</span>(<span class="string">&#x27;/webhook&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取请求头中的 GitHub 事件类型</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> githubEvent = req.<span class="title function_">header</span>(<span class="string">&#x27;X-GitHub-Event&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> githubDelivery = req.<span class="title function_">header</span>(<span class="string">&#x27;X-GitHub-Delivery&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 确认这是一个 ping 或 push 事件</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (githubEvent === <span class="string">&#x27;ping&#x27;</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;收到 GitHub 的 ping 事件&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    res.<span class="title function_">status</span>(<span class="number">200</span>).<span class="title function_">send</span>(<span class="string">&#x27;Pong!&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Postman 检查：ping 事件处理成功！&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (githubEvent === <span class="string">&#x27;push&#x27;</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`收到推送事件: Delivery ID - <span class="subst">$&#123;githubDelivery&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 git 命令拉取最新代码(要修改目录)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> gitPullCommand = <span class="string">&#x27;cd &quot;D:/Users/27599/Desktop/gitea/基于github的action测试&quot; &amp;&amp; git pull&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="title function_">exec</span>(gitPullCommand, <span class="function">(<span class="params">error, stdout, stderr</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (error) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">`拉取代码时出现错误: <span class="subst">$&#123;error.message&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res.<span class="title function_">status</span>(<span class="number">500</span>).<span class="title function_">send</span>(<span class="string">&#x27;Error pulling code from GitHub repository&#x27;</span>);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (stderr) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">`错误输出: <span class="subst">$&#123;stderr&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`拉取代码的输出: <span class="subst">$&#123;stdout&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">      res.<span class="title function_">status</span>(<span class="number">200</span>).<span class="title function_">send</span>(<span class="string">&#x27;Code pulled successfully from GitHub repository&#x27;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Postman 检查：push 事件处理成功，代码已成功拉取！&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`未知事件类型: <span class="subst">$&#123;githubEvent&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">    res.<span class="title function_">status</span>(<span class="number">400</span>).<span class="title function_">send</span>(<span class="string">&#x27;Unknown event type&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Postman 检查：收到未知的 GitHub 事件类型。&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听指定端口</span></span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="variable constant_">PORT</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`服务器在端口 <span class="subst">$&#123;PORT&#125;</span> 上运行并监听 GitHub Webhook 通知`</span>);</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Postman 检查：服务器已启动，准备接收 Webhook 通知。&#x27;</span>);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 捕获所有可能的未捕获异常</span></span><br><span class="line"></span><br><span class="line">process.<span class="title function_">on</span>(<span class="string">&#x27;uncaughtException&#x27;</span>, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;未捕获的异常:&#x27;</span>, err);</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Postman 检查：出现未捕获的异常，请检查错误信息。&#x27;</span>);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">process.<span class="title function_">on</span>(<span class="string">&#x27;unhandledRejection&#x27;</span>, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;未处理的拒绝:&#x27;</span>, err);</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Postman 检查：出现未处理的 Promise 拒绝，请检查错误信息。&#x27;</span>);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>其中注意要修改的目录地址</p><div class="tip warning"><p>其 server 文件和你的 git仓库项目（.git 在项目里面）是同级的关系</p></div><p>在 server 目录下执行<br><code>node server.js</code><br>把服务器开启</p><p>会如图下所示<br><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/20241124153557.png" alt=""><br>然后保证你的内网映射端口是 3000<br><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/20241124153700.png" alt=""></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div class="tabs" id="uniquename7"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename7-1"><i class="icon"></i>配置 github webhook</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename7-1"><h3 id="配置-github-webhook"><a href="#配置-github-webhook" class="headerlink" title="配置 github webhook"></a>配置 github webhook</h3><p><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/20241124154031.png" alt=""><br><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/20241124154155.png" alt=""><br>提交<br><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/20241124154250.png" alt=""><br>你会收到<br><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/20241124154357.png" alt=""><br>说明连接上了</p><p>然后我们 push 一下新代码，看看能不能下拉<br><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/20241124154534.png" alt=""><br>这样就成功了</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div class="tabs" id="uniquename8"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename8-1"><i class="icon"></i>使用 pm 2持久化自动拉取</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename8-1"><h3 id="使用-pm-2持久化自动拉取"><a href="#使用-pm-2持久化自动拉取" class="headerlink" title="使用 pm 2持久化自动拉取"></a>使用 pm 2持久化自动拉取</h3><p>我们如果总是这样开着一个很麻烦，那么有没有办法让其默认启动呢？<br>就是使用 pm 2 来代为管理<br>安装参考： <a href="https://blog.csdn.net/sunyctf/article/details/130655852">https://blog.csdn.net/sunyctf/article/details/130655852</a></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div class="tabs" id="uniquename9"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename9-1"><i class="icon"></i>例子</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename9-1"><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>例如 <code>pm2 start server.js --name &quot;pull automatic program&quot;</code><br>就可以 <code>pm2 list</code> 查看该进程<br><code>pm2 restart &quot;pull automatic program&quot;</code> 重启该进程<br><code>pm2 stop &quot;pull automatic program&quot;</code> 停止该进程<br><code>pm2 delete &quot;pull automatic program&quot;</code> 删除该进程<br><code>pm2 logs &quot;pull automatic program&quot;</code> 查看日志</p><p><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/20241124161440.png" alt=""></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于创建mysql连接池的具体思路和实现</title>
      <link href="/posts/a3bc84e3.html"/>
      <url>/posts/a3bc84e3.html</url>
      
        <content type="html"><![CDATA[<div class="tabs" id="uniquename2"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename2-1"><i class="icon"></i>思路</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename2-1"><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>首先连接池做的就是管理连接的作用</p><p>而用户需要的是连接</p><p>我们就是管理连接并且提供连接的过程</p><p>所以我们围绕的是 getconnection，如何让用户获得一个连接。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div class="tabs" id="uniquename3"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename3-1"><i class="icon"></i>目的</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename3-1"><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>原本的 mysql 的 api 或者封装的 mysql 类，都可以建立连接，为什么要做一个连接池来管理呢？</p><p>因为大量的用户连接请求会导致大量的连接创建和销毁，消耗资源，所以就想能不能优化这一部分？</p><p>其中大量的连接是重复的，是可以被重新调用访问数据库的。也就是说很多是不需要销毁的，如果恰好够用且不销毁，那么就不会大量创建，所以其中创建和销毁是重复的。</p><p>所以整个的数据库连接池就是为了提升效率，减少重复的冗余操作。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div class="tabs" id="uniquename4"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename4-1"><i class="icon"></i>整个 mysql 结构图</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename4-1"><h3 id="整个-mysql-结构图"><a href="#整个-mysql-结构图" class="headerlink" title="整个 mysql 结构图"></a>整个 mysql 结构图</h3><p><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/46546a5w1d5.png" alt=""></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div class="tabs" id="uniquename5"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename5-1"><i class="icon"></i>单例设计思路</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename5-1"><h3 id="单例设计思路"><a href="#单例设计思路" class="headerlink" title="单例设计思路"></a>单例设计思路</h3><p>单例推荐采用的是 c++11 支持的性质：”在 C++中，函数内部可以声明静态局部变量。这些变量在函数第一次执行到它们的声明时进行初始化，并且在程序的整个运行期间保持它们的值，即使函数已经返回。每次函数被调用时，这些变量都会保持它们上一次调用结束时的状态。”</p><p>也就是说，只要被执行一次，那么就会初始化，且只初始化一次。</p><p>所以也引出我们单例设计的模式：“magic static“</p><p>其他的单例模式不是很推荐，因为或多或少都有其他的问题，像 <code>饿汉模式</code>，如果程序运行过程中可能不会使用到该单例，会导致资源浪费，而 <code>双重检查锁定模式</code> 会因为编译器的优化导致出现线程安全问题，就是你想的和编译器以为的不一样。还有就是 <code>枚举类型</code> 实现起来繁琐且不直观。</p><p>所以采用 <code>magic static</code> 的方式，简单且安全</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取单例实例</span></span><br><span class="line"><span class="function">connection_pool&amp; <span class="title">connection_pool::GetInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> connection_pool connPool;</span><br><span class="line">    <span class="keyword">return</span> connPool;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div class="tabs" id="uniquename6"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename6-1"><i class="icon"></i>RAII 设计思路</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename6-1"><h3 id="RAII-设计思路"><a href="#RAII-设计思路" class="headerlink" title="RAII 设计思路"></a>RAII 设计思路</h3><p>我们获取当前的连接池的单例后，要考虑的就是如何写我们的构造函数，这个应该参照 RAII 设计</p><p> RAII 模式，也就是“资源获取即初始化”，为的是将资源的获取和释放与对象的生命周期绑定在一起。当对象被创建时，它负责获取所需的资源；当对象被销毁时，它负责释放资源。</p><p>所以我们的构造函数和析构函数就要围绕构造的时候获取什么？析构的时候顺带销毁什么？</p><p>连接池，那就是 sql 连接管理的池子，自然就是<strong>构造函数获取初始连接，析构函数析构所有连接</strong></p><p>所以设计上应该需要在构造函数和析构函数中设置两个循环，分别管理连接</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">ConnectionPool::~<span class="built_in">ConnectionPool</span>()</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放队列中的所有连接</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!m_connectionQ.<span class="built_in">empty</span>())&#123;</span><br><span class="line"></span><br><span class="line">        MySqlConn *conn = m_connectionQ.<span class="built_in">front</span>();</span><br><span class="line"></span><br><span class="line">        m_connectionQ.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span> conn;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放在外面的连接</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (MySqlConn* conn : m_memoryS) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span> conn;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div class="tabs" id="uniquename7"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename7-1"><i class="icon"></i>生产者线程，消费者线程</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename7-1"><h3 id="生产者线程，消费者线程"><a href="#生产者线程，消费者线程" class="headerlink" title="生产者线程，消费者线程"></a>生产者线程，消费者线程</h3><ul><li>首先生产者线程应该有生产函数</li><li>消费者线程有消费函数</li><li>两者线程应该分离开来区别于主线程</li></ul><p>所以引出三个问题<br>主线程是什么？<br>消费者函数怎么写？<br>生产者函数怎么写？</p><h4 id="主线程"><a href="#主线程" class="headerlink" title="主线程"></a>主线程</h4><p>母庸质疑就是调用线程池的 main 方法。</p><p>那么不可能在调用 main 方法的地方我们分离生产者函数和消费者函数，因为我们是封装好的类，应该只提供让用户 get 的接口，而不是让用户操作，应该让用户将其看成黑盒，而不是做更多的操作。</p><p>所以，应该如何分离消费者线程和和生产者线程呢？</p><p>首先，从线程安全的角度看，如果生产者，消费者线程，启动得太快，那么就会访问到未初始化的数据，如果启动得太慢，又无法动态调整连接数量，导致响应过慢，影响效率。</p><p>再从职责上讲，函数无非就是 <code>getconnection</code> ，<code>produceConnection</code>，<code>recycleConnection</code> <code>getInstance</code><br>什么样的函数就应该只做怎么样的事情，所以选择在构造函数中分离生产函数和消费函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">ConnectionPool::<span class="built_in">ConnectionPool</span>()</span><br><span class="line"></span><br><span class="line">&#123;  </span><br><span class="line">    <span class="comment">//加载配置文件</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">parseJsonFile</span>())&#123;</span><br><span class="line"></span><br><span class="line">        std::cerr&lt;&lt;<span class="string">&quot;pareseJsonFile is failed&quot;</span>&lt;&lt;std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_CntSize=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建连接个数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m_minSize;i++)&#123;</span><br><span class="line">    <span class="built_in">addConnection</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调用两个线程分别生产和消费</span></span><br><span class="line"><span class="comment">//选择在构造函数中分离生产函数和消费函数</span></span><br><span class="line">    <span class="function">std::thread <span class="title">producer</span><span class="params">(&amp;ConnectionPool::produceConnection,<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">recycler</span><span class="params">(&amp;ConnectionPool::recycleConnection,<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    producer.<span class="built_in">detach</span>();</span><br><span class="line">    recycler.<span class="built_in">detach</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="生产者函数"><a href="#生产者函数" class="headerlink" title="生产者函数"></a>生产者函数</h4><p>生产函数 <code>produceConnection</code></p><p>首先他需要线程分离，然后 <code>不断</code> 地去判断一些条件，符合条件的就生产，因为 <code>不断</code> 所以我们必须用 <code>while</code> 来覆盖住整个函数。</p><p>前面提到，如果我们需要按时间回收，用队列是比较好的选择，所以我们存储方式是选择队列，当符合条件就生产，加入队列。</p><p>那么这个条件是什么呢?</p><p>这个条件有两点  </p><ul><li>第一如果队列中有可用连接就不生产  </li><li>第二如果生产连接达到上限就不生产  </li></ul><p>这样做就可以让连接维持在一个规定的上界，同时让队列始终保持有连接。  </p><p>随后当我们调用完函数以后就需要通知消费者消费，所以函数最后要加一个信号量通知。  </p><p>但有一个问题，生产者如果不生产需不需要通知消费者?<br>事实上是不需要的，等待调用连接结束，可以通过智能指针回收连接到队列当中，同时再唤醒消费者即可。  </p><p>所以整个的逻辑是<br>当消费者消费时，生产者就得被唤醒，判断队列是否为空，如果为空，就说明需要生产连接，再判断是否生产在上限以内，如果是就生产，然后唤醒，不是就重新循环等待被唤醒。  </p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ConnectionPool::produceConnection</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="comment">//创建自动管理锁的对象</span></span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(m_mutexQ)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(!m_connectionQ.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            m_cond.<span class="built_in">wait</span>(locker);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(m_CntSize&lt;m_maxSize)&#123;</span><br><span class="line">        <span class="built_in">addConnection</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//生产后要去唤醒消费者线程</span></span><br><span class="line">        m_cond.<span class="built_in">notify_all</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div class="tabs" id="uniquename8"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename8-1"><i class="icon"></i>消费者线程</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename8-1"><h3 id="消费者线程"><a href="#消费者线程" class="headerlink" title="消费者线程"></a>消费者线程</h3><h4 id="getconnection"><a href="#getconnection" class="headerlink" title="getconnection"></a>getconnection</h4><p>消费者线程就是 <code>getConnection</code> 函数和<code>recycleConnection</code>函数两个函数，我们先说 <code>getConnection</code>，<code>getConnection</code> 是主线程用户调用的线程，通过调用获得连接。  </p><p><code>getConnection</code>无非就是拿的过程，从什么地方拿?从队列中拿，拿取头一个元素，返回的是一个指针类型。  </p><p>那么拿走的连接如何还回到队列当中呢?时间上肯定是需要单用户结束调用的时候，还回到队列当中，一般的想法是提供一个用户接口，让用户把连接放进去，但是这样太不优雅了，不应该让用户管理释放。  </p><p>那么回到刚刚说的，返回的是一个指针类型，是不是就可以考虑智能指针，来管理连接。通过lambda函数，把释放的链接放入队列。另外的关于智能指针的选择，推荐使用独占智能制造，因为共享智能指针可能会被用户错误的使用导致循环引用等问题，同时出现bug也不好寻找析构的代码行。所以优先考虑独占智能指针。  </p><p>那么回到代码上来，首先<code>getConnection</code>函数是通过用户主线程调用的，所以是不需要向分离线程一样，使用一个while来维持线程运作，这是区别于生产者线程和回收者线程的。  </p><p>首先通过锁实现线程同步，再去访问当前的队列有没有连接，有连接就拿。没有连接就阻塞一段时间，再访问，如果没有得到打印错误信息，直接返回空。得到的连接用智能指针管理，释放智能指针的时候，同时把连接放回队列当中。最后通知生产者判断有没有必要生产，返回一个智能指针类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;MySqlConn&gt;ConnectionPool::<span class="built_in">getConnection</span>()</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">locker</span><span class="params">(m_mutexQ)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先判断是否有连接可用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果是空的，那么就保证阻塞</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m_connectionQ.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cv_status::timeout == m_cond.<span class="built_in">wait_for</span>(locker, chrono::<span class="built_in">milliseconds</span>(m_timeout))) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果阻塞后仍然为空那么就记入次数，同时再次进入阻塞</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (m_connectionQ.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Unable to acquire connection from pool&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记忆当前的连接</span></span><br><span class="line"></span><br><span class="line">    m_memoryS.<span class="built_in">insert</span>(m_connectionQ.<span class="built_in">front</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//然后直接获取</span></span><br><span class="line"></span><br><span class="line">    shared_ptr&lt;MySqlConn&gt;<span class="built_in">connptr</span>(m_connectionQ.<span class="built_in">front</span>(),[<span class="keyword">this</span>](MySqlConn*conn)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//由于资源是共享的，所以要加锁</span></span><br><span class="line"></span><br><span class="line">        lock_guard&lt;mutex&gt; <span class="built_in">locker</span>(m_mutexQ);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果找到就删除</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (m_memoryS.<span class="built_in">find</span>(conn) != m_memoryS.<span class="built_in">end</span>()) &#123;</span><br><span class="line"></span><br><span class="line">        m_memoryS.<span class="built_in">erase</span>(conn);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        conn-&gt;<span class="built_in">refreshAliveTime</span>();</span><br><span class="line"></span><br><span class="line">        m_connectionQ.<span class="built_in">push</span>(conn);</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    m_connectionQ.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">    m_cond.<span class="built_in">notify_all</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> connptr;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="回收线程"><a href="#回收线程" class="headerlink" title="回收线程"></a>回收线程</h4><p>回收线程的设计是基于如果多余的连接超时就释放连接，以保证空闲时没有大量的连接占用。  </p><p>因为需要再后台去轮询所有的连接是否超时，所以需要用到线程分离，那么就需要一个while循环这个函数代码。<br>但是也不能一直轮询，会浪费cpu调度，那么就使用一个sleep隔一段时间回收一次。<br>回收的时候需要对队列资源进行访问，所以要用到锁，上一个锁然后开始访问资源，访问哪一个资源呢?如果回收连接的话，回收那一刻一定是最新的，所以在队头的一定是最旧的，所以从队头到队尾轮询时间。<br>如果此时连接数量大于初始设置数量，且超时，那么就回收连接，否则就直接返回，因为如果当前没有超市，后面更新的也不会超时了。  </p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="type">void</span> <span class="title">ConnectionPool::recycleConnection</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// std::cerr&lt;&lt;&quot;recycleConnection&quot;&lt;&lt;std::endl;</span></span><br><span class="line"></span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(m_mutexQ)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(m_CntSize&gt;m_minSize)&#123;</span><br><span class="line"></span><br><span class="line">            MySqlConn* conn=m_connectionQ.<span class="built_in">front</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//为什么队头的存活时间是最长的？</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(conn-&gt;<span class="built_in">getAliveTime</span>()&gt;=m_maxIdleTime)&#123;</span><br><span class="line"></span><br><span class="line">                m_connectionQ.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                m_CntSize--;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">delete</span> conn;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div class="tabs" id="uniquename9"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename9-1"><i class="icon"></i>析构函数</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename9-1"><h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>那么因为我们使用的是RAII原则，所以创建的要再析构中释放掉，那么我们释放的是什么，是连接对吧，所以我们把队列中的全部弹出来释放掉就可以了。  </p><p>但是有没有发现一个问题，如果说用户提前调用了析构函数，那么是不是队列没了，队列里面的连接释放了，但是分出去的连接还会回来访问队列，出现未定义的行为?  </p><p>那么如果我们把析构函数设置成私有的似乎是可以的，不让用户提前删除，但是如果用户就想关闭数据库怎么办?<br>而且因为析构函数是私有的，那么栈上就无法释放这个实例，因为当作用域结束，编译器是会自动调用析构函数的，如果私有将无法调用，从而出现内存泄漏。  </p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div class="tabs" id="uniquename10"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename10-1"><i class="icon"></i>一些额外的问题</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename10-1"><h3 id="一些额外的问题"><a href="#一些额外的问题" class="headerlink" title="一些额外的问题"></a>一些额外的问题</h3><p>如果我们考虑使用一个<code>close</code>函数通过<code>while</code>配合信号量，当返回的时候通知<code>close</code>判断是否符合析构条件，如果析构，听起来好像还行，但是问题在于，我们的析构函数是不应该被成员函数调用的，如果成员函数使用了成员变量，那么这个成员变量被析构了又在成员函数作用域，这样容易引起错误。  </p><p>所以我对此的想法就是做再做一个集合，存放分出去的连接，当析构函数被调用的时候，两个集合都便利一遍，释放就可以了。  </p><p>所以在<code>getConnection</code>函数中我们把连接添加到分出去集合<br>在<code>lambda</code>中，我们从分发集合中删除该连接。  </p><p>所以我们通过分发集合和空闲队列一起管理连接的建立。</p><p>这样就把在外的和在内的连接都回收了就不会出现连接回收的问题。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div class="tabs" id="uniquename11"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename11-1"><i class="icon"></i>源码</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename11-1"><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><h4 id="cpp"><a href="#cpp" class="headerlink" title=".cpp"></a>.cpp</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ConnectionPool.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;rapidjson/document.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;rapidjson/istreamwrapper.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span>  </span></span><br><span class="line"></span><br><span class="line">ConnectionPool::~<span class="built_in">ConnectionPool</span>()</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放队列中的所有连接</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!m_connectionQ.<span class="built_in">empty</span>())&#123;</span><br><span class="line"></span><br><span class="line">        MySqlConn *conn = m_connectionQ.<span class="built_in">front</span>();</span><br><span class="line"></span><br><span class="line">        m_connectionQ.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span> conn;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放在外面的连接</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (MySqlConn* conn : m_memoryS) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span> conn;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="function">ConnectionPool *<span class="title">ConnectionPool::getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> ConnectionPool instance; <span class="comment">// 局部静态变量，线程安全的初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &amp;instance;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用户获取接口(可以用优先级队列优化)</span></span><br><span class="line"></span><br><span class="line">shared_ptr&lt;MySqlConn&gt;ConnectionPool::<span class="built_in">getConnection</span>()</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// std::cerr&lt;&lt;&quot;getConnection()locker(m_mutexQ)&quot;&lt;&lt;std::endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">locker</span><span class="params">(m_mutexQ)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先判断是否有连接可用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m_connectionQ.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// std::cerr&lt;&lt;&quot; getConnection()_while (m_connectionQ.empty()&quot;&lt;&lt;std::endl;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cv_status::timeout == m_cond.<span class="built_in">wait_for</span>(locker, chrono::<span class="built_in">milliseconds</span>(m_timeout))) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果阻塞后仍然为空那么就记入次数，同时再次进入阻塞</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (m_connectionQ.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Unable to acquire connection from pool&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记忆当前的连接</span></span><br><span class="line"></span><br><span class="line">    m_memoryS.<span class="built_in">insert</span>(m_connectionQ.<span class="built_in">front</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//然后直接获取</span></span><br><span class="line"></span><br><span class="line">    shared_ptr&lt;MySqlConn&gt;<span class="built_in">connptr</span>(m_connectionQ.<span class="built_in">front</span>(),[<span class="keyword">this</span>](MySqlConn*conn)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//由于资源是共享的，所以要加锁</span></span><br><span class="line"></span><br><span class="line">        lock_guard&lt;mutex&gt; <span class="built_in">locker</span>(m_mutexQ);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果找到就删除</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (m_memoryS.<span class="built_in">find</span>(conn) != m_memoryS.<span class="built_in">end</span>()) &#123;</span><br><span class="line"></span><br><span class="line">        m_memoryS.<span class="built_in">erase</span>(conn);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        conn-&gt;<span class="built_in">refreshAliveTime</span>();</span><br><span class="line"></span><br><span class="line">        m_connectionQ.<span class="built_in">push</span>(conn);</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    m_connectionQ.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">    m_cond.<span class="built_in">notify_all</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> connptr;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//连接池初始化</span></span><br><span class="line"></span><br><span class="line">ConnectionPool::<span class="built_in">ConnectionPool</span>()</span><br><span class="line"></span><br><span class="line">&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//加载配置文件</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">parseJsonFile</span>())&#123;</span><br><span class="line"></span><br><span class="line">        std::cerr&lt;&lt;<span class="string">&quot;pareseJsonFile is failed&quot;</span>&lt;&lt;std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_CntSize=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建连接个数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m_minSize;i++)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">addConnection</span>();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用两个线程分别生产和消费</span></span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">producer</span><span class="params">(&amp;ConnectionPool::produceConnection,<span class="keyword">this</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">recycler</span><span class="params">(&amp;ConnectionPool::recycleConnection,<span class="keyword">this</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    producer.<span class="built_in">detach</span>();</span><br><span class="line"></span><br><span class="line">    recycler.<span class="built_in">detach</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化数据库数据</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ConnectionPool::parseJsonFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::ifstream <span class="title">ifs</span><span class="params">(<span class="string">&quot;dbconf.json&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">rapidjson::IStreamWrapper <span class="title">isw</span><span class="params">(ifs)</span></span>;</span><br><span class="line"></span><br><span class="line">    rapidjson::Document d;</span><br><span class="line"></span><br><span class="line">    d.<span class="built_in">ParseStream</span>(isw);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (d.<span class="built_in">IsObject</span>()) &#123;</span><br><span class="line"></span><br><span class="line">        m_ip = d[<span class="string">&quot;ip&quot;</span>].<span class="built_in">GetString</span>();</span><br><span class="line"></span><br><span class="line">        m_port = d[<span class="string">&quot;port&quot;</span>].<span class="built_in">GetUint</span>();</span><br><span class="line"></span><br><span class="line">        m_user = d[<span class="string">&quot;userName&quot;</span>].<span class="built_in">GetString</span>();</span><br><span class="line"></span><br><span class="line">        m_passwd = d[<span class="string">&quot;password&quot;</span>].<span class="built_in">GetString</span>();</span><br><span class="line"></span><br><span class="line">        m_dbName = d[<span class="string">&quot;dbName&quot;</span>].<span class="built_in">GetString</span>();</span><br><span class="line"></span><br><span class="line">        m_minSize = d[<span class="string">&quot;minSize&quot;</span>].<span class="built_in">GetInt</span>();</span><br><span class="line"></span><br><span class="line">        m_maxSize = d[<span class="string">&quot;maxSize&quot;</span>].<span class="built_in">GetInt</span>();</span><br><span class="line"></span><br><span class="line">        m_maxIdleTime = d[<span class="string">&quot;maxIdleTime&quot;</span>].<span class="built_in">GetInt</span>();</span><br><span class="line"></span><br><span class="line">        m_timeout = d[<span class="string">&quot;timeout&quot;</span>].<span class="built_in">GetInt</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生产数据库连接</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ConnectionPool::produceConnection</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// std::cerr&lt;&lt;&quot;produceConnection()_while(true)&quot;&lt;&lt;std::endl;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建自动管理锁的对象</span></span><br><span class="line"></span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(m_mutexQ)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果当前还有就阻塞</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!m_connectionQ.<span class="built_in">empty</span>())&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// std::cerr&lt;&lt;&quot;produceConnection()_while(!m_connectionQ.empty())&quot;&lt;&lt;std::endl;</span></span><br><span class="line"></span><br><span class="line">            m_cond.<span class="built_in">wait</span>(locker);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果当前没有就生产</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(m_CntSize&lt;m_maxSize)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// std::cerr&lt;&lt;&quot;produceConnection()_if(m_CntSize&lt;m_maxSize)&quot;&lt;&lt;std::endl;</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">addConnection</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//生产后要去唤醒消费者线程</span></span><br><span class="line"></span><br><span class="line">        m_cond.<span class="built_in">notify_all</span>();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ConnectionPool::recycleConnection</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// std::cerr&lt;&lt;&quot;recycleConnection&quot;&lt;&lt;std::endl;</span></span><br><span class="line"></span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(m_mutexQ)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(m_CntSize&gt;m_minSize)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// std::cerr&lt;&lt;&quot;recycleConnection_while(m_CntSize&gt;m_minSize)&quot;&lt;&lt;std::endl;</span></span><br><span class="line"></span><br><span class="line">            MySqlConn* conn=m_connectionQ.<span class="built_in">front</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//为什么队头的存活时间是最长的？</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(conn-&gt;<span class="built_in">getAliveTime</span>()&gt;=m_maxIdleTime)&#123;</span><br><span class="line"></span><br><span class="line">                m_connectionQ.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                m_CntSize--;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">delete</span> conn;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ConnectionPool::addConnection</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// std::cerr&lt;&lt;&quot;addConnection()&quot;&lt;&lt;std::endl;</span></span><br><span class="line"></span><br><span class="line">    MySqlConn *p = <span class="keyword">new</span> <span class="built_in">MySqlConn</span>();</span><br><span class="line"></span><br><span class="line">    p-&gt;<span class="built_in">connect</span>(m_user, m_passwd, m_dbName, m_ip, m_port);</span><br><span class="line"></span><br><span class="line">    p-&gt;<span class="built_in">refreshAliveTime</span>(); <span class="comment">// 刷新一下开始空闲的起始时间</span></span><br><span class="line"></span><br><span class="line">    m_connectionQ.<span class="built_in">push</span>(p);</span><br><span class="line"></span><br><span class="line">    m_CntSize++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="h"><a href="#h" class="headerlink" title=".h"></a>.h</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MySqlConn.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConnectionPool</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁用拷贝构造函数和赋值操作符</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">ConnectionPool</span>(<span class="type">const</span> ConnectionPool&amp; obj) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    ConnectionPool&amp; <span class="keyword">operator</span>=(<span class="type">const</span> ConnectionPool&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">ConnectionPool</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> ConnectionPool* <span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如何让用户得到链接？(因为要动态管理所以用非静态的接口)</span></span><br><span class="line"></span><br><span class="line">    <span class="function">shared_ptr&lt;MySqlConn&gt; <span class="title">getConnection</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ConnectionPool</span>() ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//json使用文件</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">parseJsonFile</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">produceConnection</span><span class="params">()</span> </span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">recycleConnection</span> <span class="params">()</span> </span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addConnection</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不需要静态指针成员，因为我们使用局部静态变量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据库的ip</span></span><br><span class="line"></span><br><span class="line">    string m_ip;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据库管理用户名</span></span><br><span class="line"></span><br><span class="line">    string m_user;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据库的密码</span></span><br><span class="line"></span><br><span class="line">    string m_passwd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据库的库名</span></span><br><span class="line"></span><br><span class="line">    string m_dbName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//我的端口</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> m_port;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//规定上下界</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m_CntSize=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m_minSize;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m_maxSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最大请求连接重试次数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> maxRetryCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//超时的等待时长</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m_timeout;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最长的sql连接空闲时长</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m_maxIdleTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//链接队列</span></span><br><span class="line"></span><br><span class="line">    std::queue&lt;MySqlConn*&gt; m_connectionQ;</span><br><span class="line"></span><br><span class="line">    std::set&lt;MySqlConn*&gt; m_memoryS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//访问队列的互斥锁</span></span><br><span class="line"></span><br><span class="line">    std::mutex m_mutexQ  ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//消费者线程和生产者线程的条件变量</span></span><br><span class="line"></span><br><span class="line">    std::condition_variable m_cond;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>]]></content>
      
      
      <categories>
          
          <category> MySql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文让你理解网络阻塞与非阻塞和多路io复用</title>
      <link href="/posts/a8fad53.html"/>
      <url>/posts/a8fad53.html</url>
      
        <content type="html"><![CDATA[<div class="tabs" id="uniquename2"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename2-1"><i class="icon"></i>主线是什么</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename2-1"><h3 id="主线是什么"><a href="#主线是什么" class="headerlink" title="主线是什么"></a>主线是什么</h3><p>首先为什么需要我们的网络多路复用，阻塞和非阻塞，因为我们需要考虑效率，而客户端和服务端一对一通信显然是不会陷入效率问题，而真正会产生效率问题是因为我们的多线程处理并发的场景，因此主线就是多线程中的主线程和子线程</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div class="tabs" id="uniquename3"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename3-1"><i class="icon"></i>阻塞在阻塞什么</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename3-1"><h3 id="阻塞在阻塞什么"><a href="#阻塞在阻塞什么" class="headerlink" title="阻塞在阻塞什么"></a>阻塞在阻塞什么</h3><h4 id="函数分析"><a href="#函数分析" class="headerlink" title="函数分析"></a>函数分析</h4><p>我们不妨分析一下所有的 socket 函数，看看什么适合主线程，什么适合子线程。<br>首先 socket 函数创建的是一个 sock 结构体，交给内核管理<br>然后是 bind 函数给 sock 绑定 ip 和端口<br>之后是 listen 函数初始化半连接队列和全连接队列，并且初始化 sock 状态<br>再然后是 accept 函数从全连接队列中获取 sock 的 fd<br>Recv 函数通过这个 fd 获得 sock 中缓冲区的内容，并加以处理<br>Send 函数通过 fd 获得 sock 中缓冲区的位置，并开始写，又由内核发送</p><h4 id="哪些阻塞？"><a href="#哪些阻塞？" class="headerlink" title="哪些阻塞？"></a>哪些阻塞？</h4><ol><li><p><code>socket()</code>：这个函数用于创建一个新的 socket，这个过程通常是非阻塞的。</p></li><li><p><code>bind()</code>：这个函数用于将 socket 绑定到一个特定的 IP 地址和端口号，这个过程也是非阻塞的。</p></li><li><p><code>listen()</code>：这个函数用于将 socket 设置为监听模式，等待客户端的连接请求，这个过程也是非阻塞的。</p></li><li><p><code>accept()</code>：这个函数用于接受客户端的连接请求。如果没有客户端请求连接，这个函数会阻塞，直到有客户端连接为止。</p></li><li><p><code>recv()</code>：这个函数用于从连接的 socket 中接收数据。如果 socket 中没有数据，这个函数会阻塞，直到有数据可读。</p></li><li><p><code>send()</code>：这个函数用于向连接的 socket 发送数据。如果发送缓冲区已满，这个函数会阻塞，直到有足够的空间可以发送新的数据。</p></li></ol><p>三个阻塞，分别为 <code>accept()</code> <code>recv()</code> <code>send()</code></p><h4 id="主线程应该是什么，子线程应该是什么，为什么"><a href="#主线程应该是什么，子线程应该是什么，为什么" class="headerlink" title="主线程应该是什么，子线程应该是什么，为什么"></a>主线程应该是什么，子线程应该是什么，为什么</h4><p>按照上面的解释，我们应该只考虑 <code>accept()</code> <code>recv()</code> <code>send()</code> 中区分从哪里开始是主线程，哪里是子线程，因为如果是非阻塞的话，那么是不需要分主线程还是子线程的，因为如果不阻塞就不存在要创建多个线程来处理，一个线程就可以直接处理完了。或者换一个角度想，如果主线程出现了阻塞很多，那么整个程序就堵住了，所以为了防止主线程被堵住，应该把经常造成阻塞的函数分给子线程，让子线程自个去阻塞，然后不影响整个进程。</p><p><code>accept()</code>： accept 函数从全连接队列中获取 sock 的 fd<br>这个操作相当于是去取 sock，如果没有客户端请求，那么就不会有 sock。</p><p>那么我们来假设一下，如果是放到子线程会怎么样？</p><p>那么主线程此时是没有阻塞状态的对吧？子线程和主线程是相互脱离的，很有可能就是主线程已经结束，而子线程没运行完或者是在阻塞，而<strong>导致子线程没有处理完，主线程提前结束</strong></p><p>那么我们来假设一下，如果是放到主线程会怎么样？</p><p>那么就不会出现上述情况，主线程会一直等待请求（while 循环维持），显示就是主线程正在等待数据对吧。</p><p><strong>所以我们把 accept 归类到主线程，保证主线程正常等待客户端通信，防止主线程提前结束</strong></p><p>由于我们的收发是一个组合操作所以我们一起考虑<br><code>recv()</code>：这个函数用于从连接的 socket 中接收数据。如果 socket 中没有数据，这个函数会阻塞，直到有数据可读。<br><code>send()</code>：这个函数用于向连接的 socket 发送数据。如果发送缓冲区已满，这个函数会阻塞，直到有足够的空间可以发送新的数据。</p><p>那么我们来假设一下，如果是放到子线程会怎么样？</p><p>那么就是从 accept 得到的 fd 都交给子线程处理，相当于一个线程拥有一个 sock，然后我们把剩余的操作全部交给子线程</p><p>那么我们来假设一下，如果是放到主线程会怎么样？</p><p>那么就是从 accept 得到的 fd 都交给主线程处理，相当于主线程一次只能处理一个请求，失去了并发性。</p><p>所以我们知道了，accept 用于持续接收通信所以必须放在主线程，而 recv 和 send 保证并发就必须放到子线程中</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div class="tabs" id="uniquename4"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename4-1"><i class="icon"></i>非阻塞在非阻塞什么</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename4-1"><h3 id="非阻塞在非阻塞什么"><a href="#非阻塞在非阻塞什么" class="headerlink" title="非阻塞在非阻塞什么"></a>非阻塞在非阻塞什么</h3><h4 id="非阻塞理解"><a href="#非阻塞理解" class="headerlink" title="非阻塞理解"></a>非阻塞理解</h4><p>非阻塞的事实上就是对于阻塞 io 的一种改进，虽然阻塞 io 可以通过多线程技术实现一个效果不错的并发，但是也是以消耗大量资源（线程创建销毁）的代价下完成的。</p><p>上面说阻塞是 <code>accept()</code> <code>recv()</code> <code>send()</code> 三个函数导致的，那么非阻塞自然就是使的这是三个函数变成非阻塞的状态。</p><p>很显然通过之前的讨论，accept 假装必须阻塞，保证客户端的请求得以响应，但是这不就矛盾了？我们如果阻塞了 accept，那么怎么执行下面的接收和发送？我们只有一个主线程。</p><p>很简单，我们对于 accept 的返回值进行一个判断，如果小于 0，那么就是没有接收到就去执行 recv 和 send，如果接收到那么就缓存到数组当中。</p><p>然后 recv 和 send 从数组中提取 fd，然后根据返回值，有准备好就发和接收，如果没有就跳过。然后重新进入 accept 循环</p><p>这样就实现了非阻塞同时并发的效果</p><p>所以非阻塞是非阻塞了 <code>accept()</code> <code>recv()</code> <code>send()</code> 三个函数</p><h4 id="非阻塞条件"><a href="#非阻塞条件" class="headerlink" title="非阻塞条件"></a>非阻塞条件</h4><ul><li>设置非阻塞 sock<br>  阻塞：<br>  <code>int lfd=socket(AF_INET,SOCK_STREAM,0);</code><br>  非阻塞：<br>  <code>int lfd = socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK, 0);</code></li><li>初始化 accept接收到 sock 为非阻塞<br>  <code>#include &lt;fcntl.h&gt;</code><br>  <code>fcntl(new_socket_fd, F_SETFL, O_NONBLOCK);</code><h4 id="非阻塞代码"><a href="#非阻塞代码" class="headerlink" title="非阻塞代码"></a>非阻塞代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_CLIENTS 1000</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sockfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM | SOCK_NONBLOCK, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_addr;</span><br><span class="line"></span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line"></span><br><span class="line">    serv_addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    serv_addr.sin_port = <span class="built_in">htons</span>(<span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bind</span>(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;serv_addr, <span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">listen</span>(sockfd, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> client_sockets[MAX_CLIENTS];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;MAX_CLIENTS; i++)</span><br><span class="line"></span><br><span class="line">        client_sockets[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> new_socket = <span class="built_in">accept</span>(sockfd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (new_socket &lt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (errno == EAGAIN || errno == EWOULDBLOCK)</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">                    <span class="built_in">perror</span>(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">fcntl</span>(new_socket, F_SETFL, O_NONBLOCK);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;MAX_CLIENTS; i++) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (client_sockets[i] == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                    client_sockets[i] = new_socket;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;MAX_CLIENTS; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (client_sockets[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">                <span class="type">int</span> valread = <span class="built_in">recv</span>(client_sockets[i], buffer, <span class="built_in">sizeof</span>(buffer), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (valread &lt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (errno != EAGAIN &amp;&amp; errno != EWOULDBLOCK)</span><br><span class="line"></span><br><span class="line">                        <span class="built_in">perror</span>(<span class="string">&quot;recv&quot;</span>);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (valread == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="built_in">close</span>(client_sockets[i]);</span><br><span class="line"></span><br><span class="line">                    client_sockets[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="built_in">send</span>(client_sockets[i], buffer, valread, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div class="tabs" id="uniquename5"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename5-1"><i class="icon"></i>多路 io 复用，多路在哪里</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename5-1"><h3 id="多路-io-复用，多路在哪里"><a href="#多路-io-复用，多路在哪里" class="headerlink" title="多路 io 复用，多路在哪里"></a>多路 io 复用，多路在哪里</h3><p>我们知道目前的多路 io 复用基本上是 epoll ，但是我们还是需要去从 select 开始讲讲从根源触发到底是怎么回事</p><p>多路复用复用在那里？我们不妨看看非阻塞 nio 的实现，其中有一个循环去接收 accept 存到数组当中，这个过程会不断检查是否有准备好的数据，并且 recv 和 send 也会不断去检测是否有准备好的缓冲区。</p><p>Select 是什么，select 是将这种轮询给放到内核中，更具体的说，就是把对缓冲区的访问轮询给放到内核中，让内核自己去判断哪一个 fd 对应的读缓冲区或者写缓冲区出现可用的时候，返回 fd_set 类型的链表会标志为 1。</p><p>也就是说 select 是把我们非阻塞状态中对缓冲区的检测放到了内核，减少了从用户区到内核区的开销，这个开销也提一下，开销有：</p><ol><li><p><strong>上下文切换</strong>：从用户态转到内核态时，操作系统需要保存用户态的状态，并加载内核态的状态，这一过程称为上下文切换。上下文包括程序计数器、寄存器、内存权限等信息。</p></li><li><p><strong>安全性检查</strong>：在执行系统调用之前，操作系统会进行必要的安全性检查，以确保调用是合法的。这包括检查调用参数的有效性、权限验证等，这些检查本身也是一种开销。</p></li><li><p><strong>系统调用的处理</strong>：系统调用的处理通常比普通的函数调用更为复杂和耗时。系统需要在内核中查找相应的服务例程，并执行之，这个过程中可能还会涉及到更多的安全和兼容性检查。</p></li><li><p><strong>中断处理</strong>：在内核态，操作系统可能还需要处理各种中断和异常，这也会增加额外的开销。</p><h4 id="如何使用-select"><a href="#如何使用-select" class="headerlink" title="如何使用 select"></a>如何使用 select</h4><p>那么从 nio 到 select 变迁说完了，说说怎么使用。</p></li></ol><ul><li>Select 的函数<ul><li>有五个参数：<code>最大的 fd 值</code>，<code>读set</code>，<code>写set</code>，<code>异常set</code>，<code>超时结构体</code></li></ul></li><li>Isset 函数<ul><li>传入 <code>fd</code>，<code>fdset</code> 判断是否标志位为 1，如果是则准备好了，可以发送或者接收</li></ul></li><li>Select 的主线<ul><li>主线是通过对 fd 的遍历，用 isset 函数判断已经准备好缓冲区的 sock，随之调用或不调用 recv，send 函数</li></ul></li><li>Fd_Set<ul><li>需要先在 listen 后，通过 <code>fd_zero ()</code> 初始化 set，可以是读可以是写可以是异常, 用 <code>fd_set ()</code> 设置需要检查的内容，对服务器 sock 的 fd 设置标志位为 1</li></ul></li></ul><p>具体实现如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 9999</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">make_socket_non_blocking</span><span class="params">(<span class="type">int</span> fd)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> flags = <span class="built_in">fcntl</span>(fd, F_GETFL, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flags == <span class="number">-1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fcntl&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    flags |= O_NONBLOCK;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fcntl</span>(fd, F_SETFL, flags) == <span class="number">-1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fcntl&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> server_fd, new_socket;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> address;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> addrlen = <span class="built_in">sizeof</span>(address);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buffer[BUFFER_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 socket 文件描述符</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((server_fd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 socket 为非阻塞</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">make_socket_non_blocking</span>(server_fd);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 强制绑定端口</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">setsockopt</span>(server_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &amp;opt, <span class="built_in">sizeof</span>(opt))) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;setsockopt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line"></span><br><span class="line">    address.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    address.sin_port = <span class="built_in">htons</span>(PORT);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定 socket 到端口</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bind</span>(server_fd, (<span class="keyword">struct</span> sockaddr *)&amp;address, <span class="built_in">sizeof</span>(address))&lt;<span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;bind failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">listen</span>(server_fd, <span class="number">3</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    fd_set read_fds, temp_fds;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> max_sd = server_fd;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="built_in">FD_ZERO</span>(&amp;read_fds);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FD_SET</span>(server_fd, &amp;read_fds);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        temp_fds = read_fds;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> activity = <span class="built_in">select</span>(max_sd + <span class="number">1</span>, &amp;temp_fds, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((activity &lt; <span class="number">0</span>) &amp;&amp; (errno != EINTR)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;select error&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查是否有新的连接请求</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">FD_ISSET</span>(server_fd, &amp;temp_fds)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((new_socket = <span class="built_in">accept</span>(server_fd, (<span class="keyword">struct</span> sockaddr *)&amp;address, (<span class="type">socklen_t</span>*)&amp;addrlen))&lt;<span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">perror</span>(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置新 socket 为非阻塞</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">make_socket_non_blocking</span>(new_socket);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">FD_SET</span>(new_socket, &amp;read_fds);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (new_socket &gt; max_sd) &#123;</span><br><span class="line"></span><br><span class="line">                max_sd = new_socket;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 迭代所有的 socket 描述符</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= max_sd; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">FD_ISSET</span>(i, &amp;temp_fds)) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 检查是否是已经连接的客户端发来的数据</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (i != server_fd) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="type">int</span> valread = <span class="built_in">read</span>(i , buffer, BUFFER_SIZE);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (valread == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 客户端断开了连接</span></span><br><span class="line"></span><br><span class="line">                        <span class="built_in">close</span>(i);</span><br><span class="line"></span><br><span class="line">                           <span class="built_in">FD_CLR</span>(i, &amp;read_fds); <span class="comment">// 从文件描述符集合中移除</span></span><br><span class="line"></span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (valread &lt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 发生了读取错误</span></span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (errno != EAGAIN) &#123;</span><br><span class="line"></span><br><span class="line">                            <span class="built_in">perror</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line"></span><br><span class="line">                            <span class="built_in">close</span>(i);</span><br><span class="line"></span><br><span class="line">                            <span class="built_in">FD_CLR</span>(i, &amp;read_fds);</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 从客户端收到了数据，可以在这里处理</span></span><br><span class="line"></span><br><span class="line">                        buffer[valread] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;Received: %s\n&quot;</span>, buffer);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 回写数据到客户端（Echo服务器）</span></span><br><span class="line"></span><br><span class="line">                        <span class="built_in">send</span>(i, buffer, valread, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭监听的 socket 描述符</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(server_fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Poll-的思路"><a href="#Poll-的思路" class="headerlink" title="Poll 的思路"></a>Poll 的思路</h4><p>Poll 思路上和 select 是相近的，由于 select 他设置为 1024 个最大连接数量，这个是设定好的，由于考虑到兼容性以及并发的需要，所以出了 poll 这种理论上无限连接的模式。</p><p>实现：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 9999</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_CLIENTS 256</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">make_socket_non_blocking</span><span class="params">(<span class="type">int</span> fd)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> flags = <span class="built_in">fcntl</span>(fd, F_GETFL, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flags == <span class="number">-1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fcntl&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    flags |= O_NONBLOCK;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fcntl</span>(fd, F_SETFL, flags) == <span class="number">-1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fcntl&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> server_fd, new_socket;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> address;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> addrlen = <span class="built_in">sizeof</span>(address);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buffer[BUFFER_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((server_fd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="built_in">make_socket_non_blocking</span>(server_fd);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">setsockopt</span>(server_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &amp;opt, <span class="built_in">sizeof</span>(opt))) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;setsockopt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line"></span><br><span class="line">    address.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    address.sin_port = <span class="built_in">htons</span>(PORT);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bind</span>(server_fd, (<span class="keyword">struct</span> sockaddr *)&amp;address, <span class="built_in">sizeof</span>(address)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;bind failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">listen</span>(server_fd, <span class="number">3</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">pollfd</span> fds[MAX_CLIENTS];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> nfds = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    fds[<span class="number">0</span>].fd = server_fd;</span><br><span class="line"></span><br><span class="line">    fds[<span class="number">0</span>].events = POLLIN;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> poll_count = <span class="built_in">poll</span>(fds, nfds, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (poll_count &lt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;poll&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nfds; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (fds[i].revents &amp; POLLIN) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (fds[i].fd == server_fd) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> ((new_socket = <span class="built_in">accept</span>(server_fd, (<span class="keyword">struct</span> sockaddr *)&amp;address, (<span class="type">socklen_t</span>*)&amp;addrlen)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="built_in">perror</span>(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="built_in">make_socket_non_blocking</span>(new_socket);</span><br><span class="line"></span><br><span class="line">                    fds[nfds].fd = new_socket;</span><br><span class="line"></span><br><span class="line">                    fds[nfds].events = POLLIN;</span><br><span class="line"></span><br><span class="line">                    nfds++;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="type">int</span> valread = <span class="built_in">read</span>(fds[i].fd, buffer, BUFFER_SIZE);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (valread == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="built_in">close</span>(fds[i].fd);</span><br><span class="line"></span><br><span class="line">                        fds[i].fd = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (valread &lt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (errno != EAGAIN) &#123;</span><br><span class="line"></span><br><span class="line">                            <span class="built_in">perror</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line"></span><br><span class="line">                            <span class="built_in">close</span>(fds[i].fd);</span><br><span class="line"></span><br><span class="line">                            fds[i].fd = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                        buffer[valread] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;Received: %s\n&quot;</span>, buffer);</span><br><span class="line"></span><br><span class="line">                        <span class="built_in">send</span>(fds[i].fd, buffer, valread, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nfds; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (fds[i].fd == <span class="number">-1</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; nfds - <span class="number">1</span>; j++) &#123;</span><br><span class="line"></span><br><span class="line">                    fds[j] = fds[j + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                nfds--;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(server_fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Epoll-的思路"><a href="#Epoll-的思路" class="headerlink" title="Epoll 的思路"></a>Epoll 的思路</h4><p>Epoll 的思路是想要解决掉上述的 select/poll 的轮训，因为 isset 在辅助我们判断缓冲区是否好的前提是内核已经帮我们处理了对每一个缓冲区是否有数据进行一个判断，而这个操作也是十分消耗资源的，特别是连接一多的情况下，那么我们需要在内核轮询的也就更多了。</p><p>那么有没有一种不需要轮询的操作呢，那么就是我们直接对我们的每一个 fd 进行一个单一的监听，然后如果这个监听监听到数据就把 fd 放到就绪的空间内，然后我们需要的时候直接从这个区域中取出来就可以了，就不需要去轮询是否有数据。</p><p>而 <code>epoll</code> 通过以下步骤优化了这一过程：</p><ol><li>使用 <code>epoll_create</code> 创建一个 <code>epoll</code> 实例，这个实例将被用来存储和跟踪各个文件描述符的状态。</li><li>通过 <code>epoll_ctl</code> 添加或修改文件描述符的监听事件。这个调用使得内核得以知道哪些文件描述符被监控以及监控哪种类型的事件。</li><li>当调用 <code>epoll_wait</code> 时，此函数会阻塞直到至少有一个监控的文件描述符发生了事件。与 <code>select</code> 或 <code>poll</code> 不同的是，<code>epoll_wait</code> 已经不需要遍历所有文件描述符，而是直接返回那些已经触发事件的文件描述符。这样大大减少了不必要的检查和等待时间。</li></ol><p>也就是使用 epollcreate 创建一个代理对象，这个相当于是 select 的 select 函数的调用，拥有等待，就绪的队列，用于存放 sock，如果此时执行 epoll_wait 就会把当前的 sock 添加到等待队列当中，如果是网卡接受到数据的时候会向 cpu 发出中断，这个中断执行指令，把对应的 sock 索引从等待队列添加到就绪队列，此时会重新唤起我们的进程，此时 epoll_wait 就会解除阻塞，同时返回我们的就绪队列，我们可以根据就绪队列来获得所有已经就绪的 sock，之后随便我们来 read，或者 send</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 9999</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_EVENTS 256</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">make_socket_non_blocking</span><span class="params">(<span class="type">int</span> fd)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> flags = <span class="built_in">fcntl</span>(fd, F_GETFL, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (flags == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fcntl&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    flags |= O_NONBLOCK;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fcntl</span>(fd, F_SETFL, flags) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fcntl&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> server_fd, new_socket;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> address;</span><br><span class="line">    <span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> addrlen = <span class="built_in">sizeof</span>(address);</span><br><span class="line">    <span class="type">char</span> buffer[BUFFER_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    server_fd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (server_fd == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">make_socket_non_blocking</span>(server_fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">setsockopt</span>(server_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &amp;opt, <span class="built_in">sizeof</span>(opt))) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;setsockopt&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    address.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    address.sin_port = <span class="built_in">htons</span>(PORT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bind</span>(server_fd, (<span class="keyword">struct</span> sockaddr *)&amp;address, <span class="built_in">sizeof</span>(address)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;bind failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">listen</span>(server_fd, <span class="number">3</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> epoll_fd = <span class="built_in">epoll_create1</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (epoll_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;epoll_create1&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> event;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> events[MAX_EVENTS];</span><br><span class="line"></span><br><span class="line">    event.events = EPOLLIN;</span><br><span class="line">    event.data.fd = server_fd;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">epoll_ctl</span>(epoll_fd, EPOLL_CTL_ADD, server_fd, &amp;event) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;epoll_ctl: server_fd&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> n = <span class="built_in">epoll_wait</span>(epoll_fd, events, MAX_EVENTS, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;epoll_wait&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (events[i].data.fd == server_fd) &#123;</span><br><span class="line">                <span class="keyword">while</span> ((new_socket = <span class="built_in">accept</span>(server_fd, (<span class="keyword">struct</span> sockaddr *)&amp;address, (<span class="type">socklen_t</span>*)&amp;addrlen)) != <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="built_in">make_socket_non_blocking</span>(new_socket);</span><br><span class="line">                    event.events = EPOLLIN | EPOLLET;</span><br><span class="line">                    event.data.fd = new_socket;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">epoll_ctl</span>(epoll_fd, EPOLL_CTL_ADD, new_socket, &amp;event) == <span class="number">-1</span>) &#123;</span><br><span class="line">                        <span class="built_in">perror</span>(<span class="string">&quot;epoll_ctl: add&quot;</span>);</span><br><span class="line">                        <span class="built_in">close</span>(new_socket);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (errno != EAGAIN &amp;&amp; errno != EWOULDBLOCK) &#123;</span><br><span class="line">                    <span class="built_in">perror</span>(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> done = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="type">ssize_t</span> count = <span class="built_in">read</span>(events[i].data.fd, buffer, BUFFER_SIZE - <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span> (count == <span class="number">-1</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (errno != EAGAIN) &#123;</span><br><span class="line">                            <span class="built_in">perror</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                            done = <span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                        done = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    buffer[count] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Received: %s\n&quot;</span>, buffer);</span><br><span class="line">                    <span class="built_in">send</span>(events[i].data.fd, buffer, count, <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (done) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Closed connection on descriptor %d\n&quot;</span>, events[i].data.fd);</span><br><span class="line">                    <span class="built_in">close</span>(events[i].data.fd);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(server_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div class="tabs" id="uniquename6"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename6-1"><i class="icon"></i>总结</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename6-1"><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>事实上，上面的 io 复用都是基于单线程的情况下处理大量并发，但是为缓解线程压力也可以引入多线程来分担线程压力。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>]]></content>
      
      
      <categories>
          
          <category> Socket </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Socket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023年度总结</title>
      <link href="/posts/62c6c373.html"/>
      <url>/posts/62c6c373.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><div class="tabs" id="uniquename1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename1-1"><i class="icon"></i>前言</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename1-1"><p>本文记录关于我这一年的学习情况，大多数以obsidian的笔记作为主线，希望通过这条主线快速地回顾这一年的进程。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h3 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h3><div class="tabs" id="uniquename2"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename2-1"><i class="icon"></i>回顾</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename2-1"><div class="timeline undefined"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>2023</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>04-10</p></div></div><div class='timeline-item-content'><p>CSAPP</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>05-7</p></div></div><div class='timeline-item-content'><p>数据结构</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>08-10</p></div></div><div class='timeline-item-content'><p>侯捷面向对象</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>09-18</p></div></div><div class='timeline-item-content'><p>c++ Primer</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>09-25</p></div></div><div class='timeline-item-content'><p>侯捷STL源码剖析</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>10-1</p></div></div><div class='timeline-item-content'><p>Effective modern C++</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>10-20</p></div></div><div class='timeline-item-content'><p>Effective C++</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>11-10</p></div></div><div class='timeline-item-content'><p>计算机网络</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>11-25</p></div></div><div class='timeline-item-content'><p>More effective c++</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>12-05</p></div></div><div class='timeline-item-content'><p>拥有第一个博客</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>12-13</p></div></div><div class='timeline-item-content'><p>拥有第二个博客</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>12-23</p></div></div><div class='timeline-item-content'><p>CS144</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>12-30</p></div></div><div class='timeline-item-content'><p>git学习</p></div></div></div><div class="timeline undefined"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>2024</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>1-7</p></div></div><div class='timeline-item-content'><p>CMake学习</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>1-7</p></div></div><div class='timeline-item-content'><p>图论</p></div></div></div></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><p><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/动画-min.gif" alt=""></p><h3 id="心里话"><a href="#心里话" class="headerlink" title="心里话"></a>心里话</h3><div class="tabs" id="uniquename3"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename3-1"><i class="icon"></i>心里话</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename3-1"><p>回顾这一年我感觉学得是挺多的，但是很多的书籍仍然需要去沉淀，慢慢挖掘其中的深邃。然后对于平时，个人感觉也是挺水的，如果多努力一点可能能对知识掌握更深更广。希望24年能更好的努力吧，项目是一个没做，太卢瑟了，加油加油！</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>]]></content>
      
      
      <categories>
          
          <category> 年度 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMake_opencv</title>
      <link href="/posts/undefined.html"/>
      <url>/posts/undefined.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><div class="tabs" id="uniquename1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename1-1"><i class="icon"></i>前言</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename1-1"><p>这部分是关于如何入门地通过cmake使用opencv</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><div class="tabs" id="uniquename2"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename2-1"><i class="icon"></i>实践</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename2-1"><p>首先你需要在文件下创建：<br><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/adffgsgdsg.png" alt="[Pasted image 20231223114216.png]"><br><code>main.cpp</code> 的源码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    Mat srcImg = <span class="built_in">imread</span>(<span class="string">&quot;.jpg&quot;</span>); <span class="comment">// 尝试读取图片</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (srcImg.<span class="built_in">empty</span>()) &#123; <span class="comment">// 检查图片是否正确载入</span></span><br><span class="line"></span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Error: Image cannot be loaded!&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    string windowName = <span class="string">&quot;Image Display&quot;</span>; <span class="comment">// 明确窗口名</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">namedWindow</span>(windowName, WINDOW_KEEPRATIO); <span class="comment">// 创建窗口</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">imshow</span>(windowName, srcImg); <span class="comment">// 在窗口里显示图像</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="built_in">waitKey</span>(<span class="number">0</span>); <span class="comment">// 等待按键</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你需要的就是编写 <code>CMakeLists.txt</code> 的代码 </p><p>通过头文件可以知道我们需要找到我们的头文件：<code>opencv.hpp</code>，它在：<code>opencv\opencv\build\include\opencv2</code><br>然后需要用到 lib 文件，它在：<br><code>/opencv/build/x64/vc16/lib/opencv_world480d.lib</code></p><p>然后后面的你可以自己写下 <code>CMakeLists.txt</code> 的代码，自己运行和加入对应的 dll 文件就可以运行了<br>想自己写的可以暂停了</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include_directories</span>(D:/Users/<span class="number">27599</span>/Desktop/software/opencv/opencv/build/<span class="keyword">include</span>)<span class="comment">#找头文件的位置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(lesson2_opencv main.cpp)<span class="comment">#构建项目</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(lesson2_opencv D:/Users/<span class="number">27599</span>/Desktop/software/opencv/opencv/build/x64/vc16/lib/opencv_world480d.lib)<span class="comment">#连接静态库</span></span><br></pre></td></tr></table></figure><p><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/sadasfasfs.png" alt="[Pasted image 20231223115014.png]"><br><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/WP`TR8BMWYHT.png" alt="[Pasted image 20231223115111.png]"></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>]]></content>
      
      
      <categories>
          
          <category> CMake </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CMake </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMake优雅地使用环境变量</title>
      <link href="/posts/6f6925cb.html"/>
      <url>/posts/6f6925cb.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><div class="tabs" id="uniquename1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename1-1"><i class="icon"></i>前言</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename1-1"><p>本文只是关于如何配置他人已经包装好的软件配置路径。<br>由于每一个电脑的安装路径都不一样，所以如果为了保证 <code>CMakelists.txt</code> 可以在其他电脑上复用，需要用到环境变量，代替曾经用绝对路径的情况</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><div class="tabs" id="uniquename2"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename2-1"><i class="icon"></i>配置</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename2-1"><p>配置需要通过 <code>find_package(OpenCV REQUIRED)</code> 到环境变量中从上到下依次寻找路径，找到便退出。</p><p>在我们的 <code>xxx.cmake</code> 中会有关于如何设置 <code>CMakelists.txt</code> 的配置<br>例如 <code>OpenCV</code> 的 <code>OpenCVConfig.cmake</code> ：<img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/adfawfaw.png" alt="[Pasted image 20231228102620.png]"></p><p>将他们找到，然后注意三个部分，<code>find_package</code> 找到路径 <code>add_executable</code> 写可执行文件 <code>target_include_directories</code> 链接头  <code>target_link_libraries</code> 链接库</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(OpenCV REQUIRED)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(lesson4_opencv main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_include_directories</span>(lesson4_opencv PRIVATE <span class="variable">$&#123;OpenCV_INCLUDE_DIRS&#125;</span>)</span><br><span class="line"><span class="comment">#`$` + `&#123;&#125;` 是 cmake 里的变量</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(lesson4_opencv <span class="variable">$&#123;OpenCV_LIBS&#125;</span>)</span><br></pre></td></tr></table></figure><p>就可以了</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>]]></content>
      
      
      <categories>
          
          <category> CMake </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CMake </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMake常用指令推荐</title>
      <link href="/posts/a767a042.html"/>
      <url>/posts/a767a042.html</url>
      
        <content type="html"><![CDATA[<div class="table-container"><table><thead><tr><th>指令</th><th>描述</th><th>推荐</th><th>备注</th></tr></thead><tbody><tr><td><code>include_directories</code></td><td>在构建目标之前，为所有的目标添加头文件搜索路径。</td><td></td><td>非 target-specific，会影响整个 CMake 项目的所有目标。</td></tr><tr><td><code>target_include_directories</code></td><td>为特定的构建目标添加头文件搜索路径。</td><td>✅</td><td>target-specific，只影响指定的目标。</td></tr><tr><td><code>link_directories</code></td><td>在构建目标之前，添加库文件搜索路径。</td><td></td><td>非 target-specific，会影响之后定义的所有目标。但通常不推荐使用，因为它不提供精确的依赖关系。</td></tr><tr><td><code>target_link_libraries</code></td><td>为特定的构建目标链接一个或多个库。</td><td>✅</td><td>target-specific，只影响指定的目标，并且可以指定私有（<code>PRIVATE</code>）、接口（<code>INTERFACE</code>）或公共（<code>PUBLIC</code>）链接。</td></tr><tr><td><code>add_definitions</code></td><td>添加编译器定义（如预处理器定义）。</td><td></td><td>非 target-specific，会影响整个 CMake 项目的所有目标。</td></tr><tr><td><code>target_compile_definitions</code></td><td>为特定目标添加编译器定义。</td><td>✅</td><td>target-specific，允许为不同的 target 添加不同的编译器定义。</td></tr><tr><td><code>add_compile_options</code></td><td>添加编译器选项。</td><td></td><td>非 target-specific，会影响整个 CMake 项目的所有目标。</td></tr><tr><td><code>target_compile_options</code></td><td>为特定目标添加编译器选项。</td><td>✅</td><td>target-specific，允许为不同的 target 定制编译选项。</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> CMake </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CMake </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMake降低耦合</title>
      <link href="/posts/439c322c.html"/>
      <url>/posts/439c322c.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><div class="tabs" id="uniquename1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename1-1"><i class="icon"></i>前言</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename1-1"><p>这节课中的依赖是狭义的认为不需要提供的库不链接，换一句话说只有当前库中有调用另一个库的函数那么构成依赖。</p><h4 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h4><p>做法是将源代码文件（在这个案例中是 <code>.cpp</code> 文件，对于 C 项目将是 <code>.c</code> 文件）编译并打包成库文件。然后添加访问权级，让库可以被其他部分的项目代码链接和使用。<br>Cmake 权级如下：</p><div class="table-container"><table><thead><tr><th>范围</th><th>目标构建时</th><th>链接目标时</th><th>描述</th></tr></thead><tbody><tr><td>PRIVATE</td><td>是</td><td>否</td><td>目标私有，库或路径仅用于构建当前目标，在当前目标的外部不可见。</td></tr><tr><td>INTERFACE</td><td>否</td><td>是</td><td>目标接口，用于目标接口的库或路径不直接用于构建目标，但会传递给链接此目标的其他目标。</td></tr><tr><td>PUBLIC</td><td>是</td><td>是</td><td>两者兼而有之，库或路径用于构建当前目标，且会传递给任何链接了该目标的其他目标。</td></tr><tr><td></td><td></td><td></td></tr></tbody></table></div><p><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/7AUU.png" alt="[Pasted image 20231227225906.png]"></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h3 id="课程文件"><a href="#课程文件" class="headerlink" title="课程文件"></a>课程文件</h3><div class="tabs" id="uniquename2"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename2-1"><i class="icon"></i>课程文件</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename2-1"><p>以下是（比飞鸟贵重的多_HKL）up 教程里的各个文件代码<br><code>add.hh</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">int add(int a, int b);</span><br></pre></td></tr></table></figure><p><code>add.cpp</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printResult</span>(x + y);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>calculator.h</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Calculator</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    int calcAdd(int x, int y);</span><br><span class="line"></span><br><span class="line">    int calcSub(int x, int y);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>calculator.cpp</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;calculator.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;add.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sub.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Calculator::calcAdd</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">add</span>(x, y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Calculator::calcSub</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sub</span>(x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>common.h</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">void printResult(int a);</span><br></pre></td></tr></table></figure><p><code>common.cpp</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printResult</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;result is: &quot;</span> &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sub.h</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">int sub(int a, int b);</span><br></pre></td></tr></table></figure><p><code>sub.cpp</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printResult</span>(a - b);</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h3 id="文件关系处理"><a href="#文件关系处理" class="headerlink" title="文件关系处理"></a>文件关系处理</h3><div class="tabs" id="uniquename3"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename3-1"><i class="icon"></i>文件关系处理</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename3-1"><p><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/MIUP.png" alt="[Pasted image 20231227231456.png]"><br>我们希望的是每一个库只取自己需要的部分来减轻依赖，而不是<br><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/CF`U~REL.png" alt="[Pasted image 20231227231627.png]"><br>这就要求我们对 cmakelists 进行配置</p><p>这是 add 的 <code>CMakelists.txt</code> 配置+解释</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># add_library(add STATIC add.cpp)</span><br><span class="line"></span><br><span class="line">#[[这行代码创建了一个名为 add 的静态库。静态库与动态库（共享库）不同，是将代码直接嵌入到最终可执行文件中。由于这个静态库在链接时会全部复制到最终的可执行文件，它不会在运行时引入额外的依赖性。]]</span><br><span class="line"></span><br><span class="line"># target_link_libraries(add PRIVATE common)</span><br><span class="line"></span><br><span class="line">#[[这行代码指定了库 add 链接了另一个库，这里假设为 common。使用 PRIVATE 关键字表示 common 库的链接仅仅对 add 库内部实现是必需的，而不会影响那些链接了 add 库的上层目标（比如可执行文件或其他库）。也就是说，对于链接了 add 的上层目标来说，common 这个依赖是看不见的，降低了这个依赖的传播。]]</span><br><span class="line"></span><br><span class="line"># target_include_directories(add PUBLIC ./)</span><br><span class="line"></span><br><span class="line">#[[这行代码设置了 add 库的公开头文件路径。使用 PUBLIC 关键字意味着如果一个目标链接了 add 库，那么这个目标也会自动具有对 add 公开头文件的访问权。这里 ./ 指的可能是库源代码的根目录。这样使得任何链接了 add 的上层目标都会正确地找到这个库的头文件，而不需要这些上层目标自己再去指定包含路径。这减少了使用 add 库的上层目标的配置负担，因为它们不需要知道 add 库头文件的具体位置。]]</span><br></pre></td></tr></table></figure><p>一共三句话，构建库，指出依赖对象和权级，提供头文件路径。<br><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/X04XCF.png" alt="[Pasted image 20231227232305.png]"></p><p>依次配置四个文件的 <code>CMakelists.txt</code> 即可减小依赖。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h3 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h3><div class="tabs" id="uniquename4"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename4-1"><i class="icon"></i>后续</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename4-1"><p><code>main.cpp</code> 的同级下配置以下，以提供 cmake 路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># add_subdirectory(common)</span><br><span class="line"># add_subdirectory(add)</span><br><span class="line"># add_subdirectory(sub)</span><br><span class="line"># add_subdirectory(calculator)</span><br></pre></td></tr></table></figure><p>构建可执行文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># add_executable(lesson3_1 main.cpp)</span><br><span class="line"></span><br><span class="line"># target_link_libraries(lesson3_1 calculator)</span><br></pre></td></tr></table></figure><p>Q 1：<br>为什么 main 函数不需要构建静态库<br>A 1：<br>由于 <code>main</code> 函数是程序的起始点，它不是用于被其他函数或程序调用的，并不需要作为库中的一部分。库（无论是静态的还是动态的）是一组代码，其目的在于提供给其他程序调用，以实现代码复用或分离等目的。一个静态库或动态库包含了可以被各种不同程序重用的函数和数据。</p><p>最后顶级 <code>CMakelists.txt</code> 加上即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_subdirectory(lesson3_1)#去寻找cmake文件</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>]]></content>
      
      
      <categories>
          
          <category> CMake </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CMake </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMake在linux和win的运行执行文件不同之处</title>
      <link href="/posts/aaea630f.html"/>
      <url>/posts/aaea630f.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言-："><a href="#前言-：" class="headerlink" title="前言 ："></a>前言 ：</h3><div class="tabs" id="uniquename1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename1-1"><i class="icon"></i>前言 ：</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename1-1"><p>通过之前的文章应该了解到 linux 系统和 win 系统对于构建 cpp 文件的差别也是很大的。<br>这里补充一下执行文件的不同之处：</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h3 id="CMake在linux和win的运行执行文件不同之处"><a href="#CMake在linux和win的运行执行文件不同之处" class="headerlink" title="CMake在linux和win的运行执行文件不同之处"></a>CMake在linux和win的运行执行文件不同之处</h3><div class="tabs" id="uniquename2"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename2-1"><i class="icon"></i>CMake在linux和win的运行执行文件不同之处</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename2-1"><h4 id="Linux-的优点"><a href="#Linux-的优点" class="headerlink" title="Linux 的优点"></a>Linux 的优点</h4><p>Linux 下是有保存同级 <code>CMakelists.txt</code> 的 target_link_libraries 路径<br><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/asdfafsefdhf.png" alt="[Pasted image 20231226152958.png]"><br>而 windows 是没有保存路径的 <code>.exe</code> 必须要配合 <code>.dll</code> 文件，linux 的可执行文件是可以自寻路径的</p><h4 id="Windows-搜索路径"><a href="#Windows-搜索路径" class="headerlink" title="Windows 搜索路径"></a>Windows 搜索路径</h4><p>通过隐式和显式链接，Windows 首先搜索“已知 DLL”，如 Kernel 32. Dll 和 User 32. Dll。Windows 然后按下列顺序搜索 DLL：</p><ol><li>当前进程的可执行模块所在的目录。</li><li>当前目录。 </li><li>Windows 系统目录。GetSystemDirectory 函数检索此目录的路径。</li><li>Windows 目录。GetWindowsDirectory 函数检索此目录的路径。 </li><li>PATH 环境变量中列出的目录。</li></ol></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h3 id="Linux-搜索路径"><a href="#Linux-搜索路径" class="headerlink" title="Linux 搜索路径"></a>Linux 搜索路径</h3><div class="tabs" id="uniquename3"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename3-1"><i class="icon"></i>Linux 搜索路径</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename3-1"><p>Linux 搜索的先后顺序是： </p><ol><li>编译目标代码时指定的动态库搜索路径</li><li>环境变量 LD_LIBRARY_PATH 指定的动态库搜索路径</li><li>配置文件/etc/ld. So. Conf 中指定的动态库搜索路径</li><li>默认的动态库搜索路径/lib</li></ol></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>]]></content>
      
      
      <categories>
          
          <category> CMake </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CMake </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMake动态库</title>
      <link href="/posts/cawdawda5465745.html"/>
      <url>/posts/cawdawda5465745.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><div class="tabs" id="uniquename1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename1-1"><i class="icon"></i>前言</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename1-1"><p>相比较于静态库，动态库需要的是得到一些运行时的量，这是和静态库本质的区别</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h3 id="实现动态库"><a href="#实现动态库" class="headerlink" title="实现动态库"></a>实现动态库</h3><div class="tabs" id="uniquename2"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename2-1"><i class="icon"></i>实现动态库</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename2-1"><ul><li>确认平台<ul><li>我们配置动态库要注意是在什么平台下，如果是在 win 下需要有静态库作为帮手，把动态库导入</li><li>Windows 和 Linux 在处理静态库和动态库（也称为共享库）时有一些差异，这主要归因于它们的链接和加载机制的不同。这些差异影响了在各自平台上构建和运行程序的方式。</li></ul></li></ul></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h3 id="Windows-平台："><a href="#Windows-平台：" class="headerlink" title="Windows 平台："></a>Windows 平台：</h3><div class="tabs" id="uniquename3"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename3-1"><i class="icon"></i>Windows 平台：</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename3-1"><ol><li><p><strong>静态库（. Lib）：</strong></p><ul><li>在 Windows 上，静态库通常以 <code>.lib</code> 文件形式出现。</li><li>当程序编译时，静态库的内容被复制到最终的可执行文件（<code>.exe</code>）中。</li><li>因此，部署时不需要静态库文件，因为所有必需的代码都包含在 <code>.exe</code> 文件内。</li></ul></li><li><p><strong>动态链接库（DLL，. Dll）：</strong></p><ul><li>动态链接库（Dynamic Link Libraries, DLLs）是 Windows 上的共享库。</li><li>程序在运行时动态地链接到这些库，而不是在编译时。</li><li>这意味着，为了运行程序，必须有相应的 <code>.dll</code> 文件在可访问的路径上，例如程序所在目录或系统目录。</li></ul></li></ol><p>在 Windows 上，有时即使使用动态库，也需要一个小型的静态库（通常称为导入库），它包含了定位和链接到动态库的指令。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h3 id="Linux-平台："><a href="#Linux-平台：" class="headerlink" title="Linux 平台："></a>Linux 平台：</h3><div class="tabs" id="uniquename4"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename4-1"><i class="icon"></i>Linux 平台：</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename4-1"><ol><li><p><strong>静态库（. A）：</strong></p><ul><li>Linux 上的静态库通常以 <code>.a</code> 文件形式存在。</li><li>与 Windows 类似，静态库的内容在编译时被包含到最终的可执行文件中。</li><li>运行程序时不需要静态库文件。</li></ul></li><li><p><strong>共享库（. So）：</strong></p><ul><li>Linux 上的共享库通常是 <code>.so</code>（shared object）文件。</li><li>Linux 上的动态链接处理比 Windows 更灵活。程序可以直接链接到共享库，不需要额外的静态导入库。</li><li>运行时需要能够访问这些共享库，但不需要编译时的静态库。</li></ul></li></ol></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><div class="tabs" id="uniquename5"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename5-1"><i class="icon"></i>总结：</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename5-1"><ul><li>Windows 平台上，静态库（. Lib）通常是必需的，即使是对于动态链接的情况（通过导入库）。而动态库（. Dll）在运行时必须可用。</li><li>Linux 平台上，静态库（. A）用于完全静态链接的情况，共享库（. So）用于动态链接。动态链接在 Linux 上不依赖于编译时的静态库。</li></ul><p>这些差异反映了不同操作系统平台的底层架构和设计哲学。</p><ul><li>Win 下如何导入动态库<ul><li>当我们需要 dll 时，在 <code>.cpp</code> 文件的同级 cmakelists 下添加 SHARED 如下</li><li><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/adawjdoiawjodia.png" alt="[Pasted image 20231223100002.png]"></li><li>就可以生成 dll 文件</li><li><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/adawjdoiawjodia2.png" alt="[YXOPng]"></li><li>但是问题在于，构建 exe 的时候会发生损坏</li><li><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/adawjdoiawjodia3.png" alt="[ZKN 6OL~XG 9 B 1. Png]"></li><li></li><li>原因上面讲过，所以在 win 平台下我们需要加上 <code>__declspec(dllexport)</code> 到 <code>.cpp·</code> 文件以生成静态库帮助导入动态库</li><li><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/adawjdoiawjodia4.png" alt="[Pasted image 20231223094956.png]"></li><li>如果没有加上就会出现文件损毁</li><li><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/2342354234.png" alt="[ZKN ng]"></li><li>当我们加上后，在 cmakelists 中添加静态位置，再次进行构建就可以出现 exe 可执行文件 <img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/adawjdoiawjodia3.png" alt="[Pasted image 20231223095724.png]"></li></ul></li></ul></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h3 id="Win-下如何优雅地导入动态库"><a href="#Win-下如何优雅地导入动态库" class="headerlink" title="Win 下如何优雅地导入动态库"></a>Win 下如何优雅地导入动态库</h3><div class="tabs" id="uniquename6"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename6-1"><i class="icon"></i>Win 下如何优雅地导入动态库</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename6-1"><ol><li>为了优雅地引入 <code>__declspec(dllexport)</code>，需要去通过宏定义的方式去实现 <code>#define CMAKE_STUDY_API __declspec(dllimport)</code> 这样我们就可以通添加 CMAKE_STUDY_API 来使得程序更加易读</li><li>如果在编译 DLL 的时候定义了，那么会被定义为，这意味着随后所有标记了这个宏的类和函数都是要被导出的。<code>EXPORT``EXPORT``CMAKE_STUDY_API``__declspec(dllexport)</code></li><li>如果没有定义，意味着当前你可能在编译使用 DLL 的应用程序而非 DLL 本身。此时会被定义为，标记的类和函数表示从 DLL 中导入。<code>EXPORT``CMAKE_STUDY_API``__declspec(dllimport)</code></li></ol><p>例如，在 DLL 的项目中你可能会这样写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Define EXPORT when compiling the DLL</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXPORT  <span class="comment">// This is typically done in the project settings not in the code directly</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;your_header.h&quot;</span>  <span class="comment">// The header file containing the CMAKE_STUDY_API macro</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">CMAKE_STUDY_API <span class="type">void</span> <span class="title">SomeFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Function implementation that is to be exported from the DLL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，在使用这个 DLL 的其他项目中，你不定义，则会变成用于导入的宏：<code>EXPORT``CMAKE_STUDY_API</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// No EXPORT defined here, as we&#x27;re using the DLL</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;your_header.h&quot;</span>  <span class="comment">// The header file containing the CMAKE_STUDY_API macro</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UseSomeFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">SomeFunction</span>();  <span class="comment">// Call the function imported from the DLL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h3 id="Win-下如何表示导出导入-dll"><a href="#Win-下如何表示导出导入-dll" class="headerlink" title="Win 下如何表示导出导入 dll"></a>Win 下如何表示导出导入 dll</h3><div class="tabs" id="uniquename7"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename7-1"><i class="icon"></i>Win 下如何表示导出导入 dll</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename7-1"><p>在 Windows 操作系统中，有两种特殊的程序文件叫做 DLL（动态链接库）文件：</p><ol><li><p><strong>导出（Export）</strong>：想象一个工厂，它生产各种零件。这个工厂希望其他工厂或商店能够买到它的零件，所以它需要告诉大家：“这些是我制作的零件，欢迎购买！” 在程序中，如果你制作了一个 DLL，并且你希望其他程序能使用 DLL 里面的功能（函数、变量等），你需要“导出”这些功能。</p></li><li><p><strong>导入（Import）</strong>：现在想象你运营着另外一个工厂，你需要购买之前那个工厂的零件来制造你的产品。那么你就需要“导入”那些零件。在程序中，如果你的程序想要使用其他 DLL 文件里的功能，你就需要“导入”这些功能。</p></li></ol><p>在 C++中，为了告诉电脑哪些功能是要被导出的，哪些是要被导入的，我们需要使用一些特殊的关键字。在 Windows 中，我们用 <code>__declspec(dllexport)</code> 来标识要导出的功能，用 <code>__declspec(dllimport)</code> 来标识要导入的功能。</p><p>所以当我们结合上面通过宏的=来优化，我们可以写下 <code>export.h</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> EXPORT</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMAKE_STUDY_API __declspec(dllexport)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMAKE_STUDY_API __declspec(dllimport)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>代码段：</p><ul><li>当在制作 DLL 文件时，你会在你的代码中定义一个叫 <code>EXPORT</code> 的宏。这个宏只在制作 DLL 文件时使用。</li><li><code>CMAKE_STUDY_API</code> 这个宏将会根据是否定义了 <code>EXPORT</code> 来改变它的行为：<ul><li>如果定义了 <code>EXPORT</code>（意味着你正在制作 DLL），<code>CMAKE_STUDY_API</code> 就代表 <code>__declspec(dllexport)</code>，标识功能为“出售”状态。</li><li>如果没有定义 <code>EXPORT</code>（意味着你在使用别人的 DLL），<code>CMAKE_STUDY_API</code> 就代表 <code>__declspec(dllimport)</code>，标识功能为“购买”状态。</li></ul></li></ul><p>所以，<code>CMAKE_STUDY_API</code> 是一个切换开关，它可以根据你是正在制作还是使用 DLL，来切换为相应的状态。以上都是作为开发者需要知道的，而用户无需知道的，导入导出的作用就是为了运行的时候 dll 可以连接找到我们的函数。</p><p>经过以上，我们就可以放把 dll 到 bin 当中，以及头文件, 以提供给用户：<br><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/adawjdoiawjodia5.png" alt="[B%X7EMLUX0`OHH{X1SB_U8S 1.png]"><br><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/adawjdoiawjodia6.png" alt="[Pasted image 20231223102728.png]"><br>如此也可以生成 exe 文件用于执行</p><p>另外需要注意的是，我们生成的 <code>.exe</code> 文件需要去加上 <code>.dll</code> 文件，否则会找不到文件错误<br>曾经在游玩游戏的时候是否有出现过类似如下，找不到 <code>.dll</code><br><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/adawjdoiawjodia7.png" alt="[Pasted image 20231223095407.png]"><br>事实上需要保证 <code>.dll</code> 在 <code>.exe</code>   同级目录下或者在环境变量下就可以运行</p><h2 id="注意事项-："><a href="#注意事项-：" class="headerlink" title="注意事项 ："></a>注意事项 ：</h2><p>由于在 win 系统下我们的动态库也是出于不确定的情况，所以需要依赖 lib，而不只是 bin，所以你需要在 <code>.cpp</code> 类文件加入 <code>__declspec(dllexport)</code> <img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/adawjdoiawjodia8.png" alt="[Pasted image 20231223022548.png]"><br>同时还有 cmake 文件要加上 shared<br><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/adawjdoiawjodia9.png" alt="[Pasted image 20231223022659.png]"></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>]]></content>
      
      
      <categories>
          
          <category> CMake </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CMake </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMake静态库</title>
      <link href="/posts/cawdawda.html"/>
      <url>/posts/cawdawda.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><div class="tabs" id="uniquename1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename1-1"><i class="icon"></i>前言</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename1-1"><p>我们知道 c.cpp c. hh 两个文件会经过编译，然后生成机器码文件，<br>而静态库的作用就是保存机器码，一方面是保证了安全性，另一方面是不用再次编译（但是跨平台肯定是不行的）</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h3 id="如何生成静态库"><a href="#如何生成静态库" class="headerlink" title="如何生成静态库"></a>如何生成静态库</h3><div class="tabs" id="uniquename2"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename2-1"><i class="icon"></i>如何生成静态库</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename2-1"><p><code>add_library(静态库名字 STATIC 静态库.cpp文件)</code><br><code>add_library(add_static STATIC add.cpp)</code></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h3 id="静态库的完整过程"><a href="#静态库的完整过程" class="headerlink" title="静态库的完整过程"></a>静态库的完整过程</h3><div class="tabs" id="uniquename3"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename3-1"><i class="icon"></i>静态库的完整过程</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename3-1"><ol><li><p><strong>编译 <code>add.cpp</code> 生成静态库：</strong> 当通过命令添加一个库时，CMake 会为适用的源文件生成一个编译指令 <code>add_library(add_static STATIC add.cpp)</code>。在这种情况下，它将 <code>add.cpp</code> 编译文件并创建一个名为 <code>add_static</code> 的静态库（在 Windows 上通常是 <code>add_static.lib</code>，在 Unix-like 系统中是 <code>libadd_static.a</code>）。</p></li><li><p><strong>编译 <code>main.cpp</code> 生成对象文件：</strong> <code>add_executable(main main.cpp)</code> 命令告诉 CMake 对 <code>main.cpp</code> 文件进行编译，生成一个对象文件 <code>main.o</code>（ 或 <code>main.obj</code>）。</p></li><li><p><strong>将静态库 <code>add_static</code> 链接到最终的可执行文件 <code>main</code>：</strong> 确保在 CMake 创建最终的可执行文件时，它会链接之前编译的静态库 <code>add_static.lib</code>。这其中包括了查找和解析函数调用，比如 <code>add()</code> 函数，因为它在静态库 <code>add_static.lib</code> 中定义。这个链接过程涉及到把的 <code>main.cpp</code> 文件编译成可执行文件</p></li></ol><p>这样，生成的可执行文件 <code>main</code> 就包含了 <code>add_static</code> 库中所有必需的代码，这意味着在调用函数 <code>add()</code> 时不需要再有任何其它的库依赖。</p><p>编译和链接的具体命令取决于使用的编译器和平台。如果正在使用 GCC，则它可能会类似于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">g++ -c add.cpp -o add.o                    # 编译生成add.o</span><br><span class="line">ar rcs libadd_static.a add.o                # 通过静态库归档器创建静态库</span><br><span class="line">g++ -c main.cpp -o main.o                   # 编译生成main.o</span><br><span class="line">g++ main.o -L. -ladd_static -o main         # 链接生成main可执行文件</span><br></pre></td></tr></table></figure><p>这里，<code>-L.</code> 告诉编译器在当前目录下查找库（<code>-L</code> 指定库的搜索路径），而 <code>-ladd_static</code> 指定静态库名称（<code>lib</code> 不包括前缀和后缀 <code>.a</code> 或 <code>.lib</code>）。</p><p>正确建立的 CMake 项目会让这个过程自动化，所以通常不需要手动运行编译和链接命令。只需要在构建目录中运行以下 CMake 命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmake ..</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>或使用 CMake 生成适用于选择的 IDE 的工程。</p><p>CMake 后台进行的具体编译和链接命令对于最终用户通常是透明的，除非有错误发生或者需要调试 CMake 本身的问题。如果想看到 CMake 执行 <code>make</code> 的具体命令，可以在命令行中增加的选项，如：<code>VERBOSE=1</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make VERBOSE=1</span><br></pre></td></tr></table></figure><p>这将打印出每个编译和链接阶段的具体命令。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h3 id="静态库结构"><a href="#静态库结构" class="headerlink" title="静态库结构"></a>静态库结构</h3><div class="tabs" id="uniquename4"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename4-1"><i class="icon"></i>静态库结构</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename4-1"><p><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/asjdijaowidjiwa.png" alt="[Pasted image 20231223002434.png]"></p><p><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/awodjaowidjiowafa.png" alt="[Pasted image 20231223004758.png]"><br>以下是一个简单的示意，说明了这些组件是如何集成在静态库中的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[静态库 libadd_static.a 或 add_static.lib]</span><br><span class="line">    |</span><br><span class="line">    |-- [对象文件 add1.o]</span><br><span class="line">    |       |-- 函数 add1 的机器代码</span><br><span class="line">    |       |-- 符号表（包含函数 add1 的信息）</span><br><span class="line">    |</span><br><span class="line">    |-- [对象文件 add2.o]</span><br><span class="line">    |       |-- 函数 add2 的机器代码</span><br><span class="line">    |       |-- 符号表（包含函数 add2 的信息）</span><br><span class="line">    |</span><br><span class="line">    |-- ... (其他对象文件和它们的代码)</span><br><span class="line">    |</span><br><span class="line">    |-- [符号索引] (可选，用于快速查找符号)</span><br></pre></td></tr></table></figure><p>当链接器创建最终的可执行文件或另一个库时，如果需要使用静态库中的函数或变量，链接器会在静态库的符号表中查找相应的符号，并将对应的机器代码链接到最终的产物中。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>]]></content>
      
      
      <categories>
          
          <category> CMake </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CMake </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMake如何统一编译管理多个.cpp文件</title>
      <link href="/posts/63b0d074.html"/>
      <url>/posts/63b0d074.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><div class="tabs" id="uniquename1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename1-1"><i class="icon"></i>前言</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename1-1"><p>首先，可以思考一下，如果我们要去管理一堆文件，那么我们需要以何种关系结构去处理呢？如果这个问题换做是管理员工，管理学生呢？</p><p>其实这就是 CMake 文件的联系关系的思想，通过分层管理来间接获取到每一个文件，类似于框架图</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><div class="tabs" id="uniquename2"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename2-1"><i class="icon"></i>介绍</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename2-1"><p>所以我们首先需要定义一个最顶层的 CMakelist，管理版本号，以及多个</p><p>类似于</p><ul><li><p>一层</p></li><li><p>CMakelist</p><ul><li><p>二层</p></li><li><p>项目 1</p></li><li><p>CMakelist</p><ul><li>项目 1_1</li><li>CMakelist</li><li>项目 1_2</li><li>CMakelist</li></ul></li><li><p>项目 2</p></li><li><p>CMakelist</p></li><li><p>项目 3</p></li><li><p>CMakelist</p></li><li><p>项目 4</p></li><li><p>CMakelist<br>其中通过 <code>add_subdirectory</code> 让上层知道下层的目录位置<br>例如在寻找库的过程 (只是举个例子先不要在意库是什么)：</p><p><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/awd546w5a4d64aw.png" alt="[G%52CA~TNB.png]"></p></li></ul></li></ul></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h3 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h3><div class="tabs" id="uniquename3"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename3-1"><i class="icon"></i>实操</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename3-1"><p>对于第一次编译 <code>add. cpp</code> 文件的过程进行扩展，结构如下<br><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/dad21a5d1aw54d6wa.png" alt="[Pasted image 20240107234142.png]"><br>其中最底下的 <code>CMakelists.txt</code> 是顶层，sub 实现的是减法，mul 乘法在 add 子目录，和之前的加法实现就基本上一样，这里给出 <code>CMakelists.txt</code> 的配置<br>顶层 <code>CMakelists.txt</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">project(cmake_study)#定义一个项目名</span><br><span class="line"></span><br><span class="line">add_subdirectory(sub)</span><br><span class="line"></span><br><span class="line">add_subdirectory(add)</span><br><span class="line"></span><br><span class="line">cmake_minimum_required(VERSION 3.15)</span><br></pre></td></tr></table></figure><p><code>sub\CMakelists.txt</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.15)</span><br><span class="line"></span><br><span class="line">add_executable(lesson1_2 main.cpp sub.hh sub.cpp)#把需要的文件交给cmake进行编译</span><br></pre></td></tr></table></figure><p><code>add\CMakelists.txt</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.15)</span><br><span class="line"></span><br><span class="line">add_executable(lesson1_1 main.cpp add.hh add.cpp)#把需要的文件交给cmake进行编译</span><br><span class="line"></span><br><span class="line">add_subdirectory(mul)</span><br></pre></td></tr></table></figure><p><code>mul\CMakelists.txt</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.15)</span><br><span class="line"></span><br><span class="line">add_executable(lesson1_3 main.cpp mul.hh mul.cpp)#把需要的文件交给cmake进行编译</span><br></pre></td></tr></table></figure><p>然后我们分别去执行 <code>.exe</code><br><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/asdfacesfsg4122.png" alt="[Pasted image 20240107235306.png]"><br>说明我们多层管理成功</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>]]></content>
      
      
      <categories>
          
          <category> CMake </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CMake </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMake_message，set，list的用法</title>
      <link href="/posts/4cec0d6e.html"/>
      <url>/posts/4cec0d6e.html</url>
      
        <content type="html"><![CDATA[<h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><div class="tabs" id="uniquename1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename1-1"><i class="icon"></i>格式</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename1-1"><p>Message（模式+“${自定义/系统变量} hello world” …）<br>其中空格也可以用 <code>；</code> ，我会比较习惯用空格</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h3 id="普通模式"><a href="#普通模式" class="headerlink" title="普通模式"></a>普通模式</h3><div class="tabs" id="uniquename2"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename2-1"><i class="icon"></i>普通模式</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename2-1"><p>模式默认空，放着不写就行</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h3 id="特殊模式"><a href="#特殊模式" class="headerlink" title="特殊模式"></a>特殊模式</h3><div class="tabs" id="uniquename3"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename3-1"><i class="icon"></i>特殊模式</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename3-1"><p>STATUS<br>输出状态信息<br>WARNING<br>当用户错误运行时的错误信息<br>AUTHOR_WARNING<br>开发的时候当日志来用<br>SEND_ERROR<br>发送一个错误信息，但是不终止<br>FATAL_ERROR<br>发送一个错误信息，并且终止</p><h4 id="STATUS"><a href="#STATUS" class="headerlink" title="STATUS"></a>STATUS</h4><p><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/adgjksgajk.png" alt="[Pasted image 20240107130937.png]"><br><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/adhahjchkhxz.png" alt="[Pasted image 20240107130801.png]"><br>可以看到前面多加了两个 <code>-</code> 和下面的配置和生成构建文件消息提示是一样的状态信息</p><h4 id="WARNING"><a href="#WARNING" class="headerlink" title="WARNING"></a>WARNING</h4><p><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/uahduhawudhuihxzdjhkwa.png" alt="[Pasted image 20240107131729.png]"><br><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/auihduhksjhdcxkajhkdjwq.png" alt="[Pasted image 20240107131707.png]"><br>此消息会提示报错行：104 行<br>报错信息是：HELLO WORLD</p><h4 id="AUTHOR-WARNING"><a href="#AUTHOR-WARNING" class="headerlink" title="AUTHOR_WARNING"></a>AUTHOR_WARNING</h4><p><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/haowdhoiahdiojopxzdopwqa.png" alt="[Pasted image 20240107140201.png]"><br><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/auhsdidcoiowjd.png" alt="[Pasted image 20240107140220.png]"><br>和 WARNING 不同的是多了一行只能由开发者去解决的报错提示 <code>此警告适用于项目开发人员。 使用 -Wno-dev 来抑制它。</code></p><h4 id="SEND-ERROR"><a href="#SEND-ERROR" class="headerlink" title="SEND_ERROR"></a>SEND_ERROR</h4><p><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/sdhaksdhchwqdh.png" alt="[Pasted image 20240107132328.png]"><br><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/dahajkdhjwhkdh.png" alt="[Pasted image 20240107142211.png]"><br>和上面的 <code>WARNING</code> 的差别在于输出的报错信息是和 WARNING 相似的但是下面的配置，生成，构建均不成功</p><h4 id="FATAL-ERROR"><a href="#FATAL-ERROR" class="headerlink" title="FATAL_ERROR"></a>FATAL_ERROR</h4><p><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/aiduhiashciopwidjiwqh.png" alt="[Pasted image 20240107141333.png]"><br><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/gagssshgjhgawjdhgwj.png" alt="[Pasted image 20240107141837.png]"><br>和 SEND_ERROR 类似，但是会直接终止下面的构建，可以看到本一个出现的分割线没有输出了</p><p>以上是各个模式下出现的情况</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><div class="tabs" id="uniquename4"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename4-1"><i class="icon"></i>变量</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename4-1"><p>变量有分为用户定义的变量和我们 CMake 定义好的变量<br>输出的形式是 Message（模式+“${自定义/系统变量} …）</p><h4 id="系统自带的变量"><a href="#系统自带的变量" class="headerlink" title="系统自带的变量"></a>系统自带的变量</h4><ol><li><p><strong>项目信息</strong></p><ul><li><code>CMAKE_PROJECT_NAME</code>: 当前项目的名称。</li><li><code>PROJECT_SOURCE_DIR</code> / <code>CMAKE_SOURCE_DIR</code>: 顶层源代码目录。</li><li><code>PROJECT_BINARY_DIR</code> / <code>CMAKE_BINARY_DIR</code>: 顶层二进制或编译目录。</li></ul></li><li><p><strong>编译器和工具设置</strong></p><ul><li><code>CMAKE_C_COMPILER</code>: C编译器的全路径。</li><li><code>CMAKE_CXX_COMPILER</code>: C++编译器的全路径。</li><li><code>CMAKE_COMPILER_IS_GNUCC</code>: 如果是GNU的C编译器则为真。</li><li><code>CMAKE_COMPILER_IS_GNUCXX</code>: 如果是GNU的C++编译器则为真。</li></ul></li><li><p><strong>编译标志</strong></p><ul><li><code>CMAKE_C_FLAGS</code>: C编译器的命令行选项。</li><li><code>CMAKE_CXX_FLAGS</code>: C++编译器的命令行选项。</li></ul></li><li><p><strong>构建类型</strong></p><ul><li><code>CMAKE_BUILD_TYPE</code>: 当前的构建类型，如Release或Debug。</li></ul></li><li><p><strong>安装路径</strong></p><ul><li><code>CMAKE_INSTALL_PREFIX</code>: 安装目录的前缀。</li></ul></li><li><p><strong>系统信息</strong></p><ul><li><code>CMAKE_SYSTEM</code>: 宿主系统的名称。</li><li><code>CMAKE_SYSTEM_NAME</code>: 不包含版本的宿主系统名称。</li><li><code>CMAKE_SYSTEM_PROCESSOR</code>: 目标处理器的名称。</li></ul></li><li><p><strong>库和执行文件</strong></p><ul><li><code>CMAKE_ARCHIVE_OUTPUT_DIRECTORY</code>: 静态库的输出目录。</li><li><code>CMAKE_LIBRARY_OUTPUT_DIRECTORY</code>: 共享库的输出目录。</li><li><code>CMAKE_RUNTIME_OUTPUT_DIRECTORY</code>: 可执行文件的输出目录。</li></ul></li><li><p><strong>查找到的库和程序</strong></p><ul><li><code>CMAKE_PREFIX_PATH</code>: 系统查找包（libraries/packages）的路径。</li><li><code>CMAKE_INCLUDE_PATH</code>: 系统头文件查找路径。</li><li>变量例如<code>Boost_FOUND</code>，<code>Boost_INCLUDE_DIRS</code>，<code>Boost_LIBRARIES</code>等，通过<code>find_package(Boost)</code>自动生成。</li></ul></li><li><p><strong>版本信息</strong></p><ul><li><code>CMAKE_MAJOR_VERSION</code>, <code>CMAKE_MINOR_VERSION</code>, <code>CMAKE_PATCH_VERSION</code>: 分别代表 CMake 的主版本、次版本和补丁级别版本号。</li></ul></li></ol></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h3 id="用户定义变量"><a href="#用户定义变量" class="headerlink" title="用户定义变量"></a>用户定义变量</h3><div class="tabs" id="uniquename5"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename5-1"><i class="icon"></i>用户定义变量</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename5-1"><p>我们需要通过 set（变量名 “变量值”）<br>例如<br><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/awoidoiasdoijwo.png" alt="[Pasted image 20240107143812.png]"><br><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/ahwduhisauhdw.png" alt="[Pasted image 20240107143829.png]"><br>要注意的是如果用户定义的变量和系统的变量是同名的那么就会覆盖，作用的范围仅仅是当前的文件目录下</p><h4 id="设置带空格的变量"><a href="#设置带空格的变量" class="headerlink" title="设置带空格的变量"></a>设置带空格的变量</h4><p><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/aiodiaswjhdoiqw.png" alt="[Pasted image 20240107155414.png]"><br><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/aidhiauwhiduhaiw.png" alt="[Pasted image 20240107155430.png]"></p><h4 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h4><p><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/aduwhakhdcwhadhuiwa.png" alt="[Pasted image 20240107160219.png]"></p><p>通过以上就大致了解了 message 的格式对应的含义</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h3 id="输出文本方式"><a href="#输出文本方式" class="headerlink" title="输出文本方式"></a>输出文本方式</h3><div class="tabs" id="uniquename6"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename6-1"><i class="icon"></i>输出文本方式</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename6-1"><p><code>message([[   ]])</code> 和 <code>message(&quot;   &quot;)</code> 以及直接使用 <code>message( )</code> 均可以输出文本，区别是 <code>[[]]</code> 不会展开变量不会对其中诸如${A}的形式进行解析，而 <code>&quot;&quot;</code> 是会去解析变量，而直接（）是不推荐的，因为容易误导，我认为需要清晰地表达意图那么最好还是使用””<br><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/waouidoiahsoidhoiw.png" alt="[Pasted image 20240107154416.png]"><br><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/haoidhawoidijaj.png" alt="[Pasted image 20240107154425.png]"><br><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/ahdiuahsudhciowoiado.png" alt="[Pasted image 20240107154502.png]"><br><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/agdisughiduiuwgau.png" alt="[Pasted image 20240107154448.png]"></p><h4 id="LIST-创建多个变量（列表）"><a href="#LIST-创建多个变量（列表）" class="headerlink" title="LIST 创建多个变量（列表）"></a>LIST 创建多个变量（列表）</h4><p><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/dajciojadijwiajodija.png" alt="[Pasted image 20240107155046.png]"><br><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/jakdkasjhdkjhwkja.png" alt="[Pasted image 20240107155114.png]"><br>LIST 这个名字可以随便取，只要形式如上就算创建多个变量</p><p>关于列表的更多用法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"># 创建多个变量</span><br><span class="line"></span><br><span class="line">message(&quot;-------创建多个变量--------&quot;)</span><br><span class="line"></span><br><span class="line">set(LISTVALUE b2 b3 b4) # 设置变量 LISTVALUE 为 b2 b3 b4</span><br><span class="line"></span><br><span class="line">message($&#123;LISTVALUE&#125;) # 打印变量 LISTVALUE 的值</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"># 添加元素到变量</span><br><span class="line"></span><br><span class="line">list(APPEND port p1 p2 p3) # 将 p1 p2 p3 添加到变量 port 中</span><br><span class="line"></span><br><span class="line">message($&#123;port&#125;) # 打印 port 变量</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"># 获取长度</span><br><span class="line"></span><br><span class="line">message(&quot;-------获取长度--------&quot;)</span><br><span class="line"></span><br><span class="line">list(LENGTH LISTVALUE len) # 获取 LISTVALUE 的长度并存储到变量 len</span><br><span class="line"></span><br><span class="line">message($&#123;len&#125;) # 打印列表长度</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"># 查找变量并获取索引</span><br><span class="line"></span><br><span class="line">list(FIND LISTVALUE b2 index) # 寻找 LISTVALUE 中的 b2 并获取其索引</span><br><span class="line"></span><br><span class="line">message($&#123;index&#125;) # 输出找到的索引值</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"># 删除列表中的元素</span><br><span class="line"></span><br><span class="line">list(REMOVE_ITEM port p1) # 从 port 列表中删除元素 p1</span><br><span class="line"></span><br><span class="line">message($&#123;port&#125;) # 输出修改后的 port 列表</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"># 添加数据</span><br><span class="line"></span><br><span class="line">message(&quot;-------添加数据--------&quot;)</span><br><span class="line"></span><br><span class="line">list(APPEND LISTVALUE a5) # 向 LISTVALUE 列表中添加元素 a5</span><br><span class="line"></span><br><span class="line">message($&#123;LISTVALUE&#125;) # 输出添加 a5 后的 LISTVALUE 列表</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"># 在特定位置插入数据</span><br><span class="line"></span><br><span class="line">list(INSERT LISTVALUE 3 a4) # 在 LISTVALUE 列表的索引 3 位置插入 a4</span><br><span class="line"></span><br><span class="line">message($&#123;LISTVALUE&#125;) # 输出插入 a4 后的 LISTVALUE 列表</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"># 反转列表</span><br><span class="line"></span><br><span class="line">list(REVERSE LISTVALUE) # 反转 LISTVALUE 列表</span><br><span class="line"></span><br><span class="line">message($&#123;LISTVALUE&#125;) # 输出反转后的 LISTVALUE 列表</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"># 排序列表</span><br><span class="line"></span><br><span class="line">list(SORT LISTVALUE) # 对 LISTVALUE 列表进行排序</span><br><span class="line"></span><br><span class="line">message($&#123;LISTVALUE&#125;) # 输出排序后的 LISTVALUE 列表</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>]]></content>
      
      
      <categories>
          
          <category> CMake </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CMake </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMake_流程控制，函数和宏</title>
      <link href="/posts/7dccf0e3.html"/>
      <url>/posts/7dccf0e3.html</url>
      
        <content type="html"><![CDATA[<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><div class="tabs" id="uniquename1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename1-1"><i class="icon"></i>条件语句</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename1-1"><p>在 CMake 中，你可以使用 <code>if</code>、<code>elseif</code>、<code>else</code> 和 <code>endif</code> 来进行条件控制:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if(  )   # 执行当条件为真时的命令</span><br><span class="line">elseif(  )   # 执行当第一个条件为假而这个条件为真时的命令 </span><br><span class="line">else()   # 执行当所有条件都为假时的命令 </span><br><span class="line">endif()</span><br></pre></td></tr></table></figure><p>条件可以基于变量的值、是否定义了变量、文件是否存在等条件。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><div class="tabs" id="uniquename2"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename2-1"><i class="icon"></i>循环</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename2-1"><p>CMake 支持 <code>foreach</code> 循环和 <code>while</code> 循环。</p><p>其中 CMake 3.0以及更高版本中，你可以使用 <code>IN LISTS</code> 或 <code>IN ITEMS</code> 语法来明确指示 <code>foreach</code> 循环应该遍历的是列表变量或者是后面直接指定的项，使得 CMake 脚本更易读、写和维护。</p><p>使用 <code>foreach</code> 循环遍历列表中的每个项:<br>如果有需要遍历自己定义的变量那么</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foreach(loop_var IN [LISTS &lt;list...&gt;] [ITEMS &lt;items...&gt;]...)   # 对列表中的每个项执行命令 注意ITEMS项要在LISTS后面 </span><br><span class="line">endforeach()</span><br></pre></td></tr></table></figure><p>例如：<br><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/dsafasfhdththb.png" alt="[Pasted image 20240107175849.png]"><br><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/dsafszshyfgukmjgfh.png" alt="[Pasted image 20240107180148.png]"><br>混用的时候作用是挨个解析读取，注意一定要在 IN 后面指定是什么类型（LISTS or ITEMS)<br>如果想进行更细的操作可以使用定义的局部变量来进行操作，例如<br>上面图片中是 file，我们可以通过 file_0，或者 file_1 来分别操作 sources 和 headers<br><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/X31ZUXGEOOVXX.png" alt="[Pasted image 20240107182731.png]"><br><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/MLNA5sdfsdfd2.png" alt="[Pasted image 20240107182805.png]"><br>注：如果是低版本没有 IN 那么需要以${A}的形式去指定自定义变量<br>如果只是想在循环中指定项目元素</p><p>疑问：ITEMS 和 LISTS 的区别是什么？<br>答：区别是 ITEMS 是输出名字而 LISTS 是会去解析变量名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foreach(loop_var item1 item2 ... itemN)   # 对列表中的每个项执行命令</span><br><span class="line">endforeach()</span><br></pre></td></tr></table></figure><p>例如：<br><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/YJ1XDSCEZAQYEXEVYYIAE.png" alt="[Pasted image 20240107173220.png]"><br><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/asdasdgkjashkjd.png" alt="[Pasted image 20240107173156.png]"></p><p>或者是遍历数字</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foreach(loop_var RANGE total)    # 命令</span><br><span class="line">... </span><br><span class="line">ndforeach()</span><br></pre></td></tr></table></figure><p>使用 <code>while</code> 循环，直到条件为假:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">while(  )   # 执行命令直到条件变为假 </span><br><span class="line">endwhile()</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h3 id="函数和宏"><a href="#函数和宏" class="headerlink" title="函数和宏"></a>函数和宏</h3><div class="tabs" id="uniquename3"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename3-1"><i class="icon"></i>函数和宏</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename3-1"><p>函数和宏允许你定义代码块，并在需要的地方调用。</p><p>定义和调用函数:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function(my_func_name param1 param2)   # 函数体 </span><br><span class="line">endfunction()  </span><br><span class="line">my_func_name(arg1 arg2)</span><br></pre></td></tr></table></figure><p>定义和调用宏:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">macro(my_macro param1 param2)   # 宏体 </span><br><span class="line">endmacro()  </span><br><span class="line">my_macro(arg1 arg2)</span><br></pre></td></tr></table></figure><p>函数和宏之间的主要区别在于它们如何处理变量的作用域。宏不会产生新的作用域，而函数会。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><div class="tabs" id="uniquename4"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename4-1"><i class="icon"></i>用途</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename4-1"><p>If：<br>对于不同的操作系统进行适配需要用到判断语句：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(WIN32)</span><br><span class="line">    <span class="keyword">add_definitions</span>(-DWINDOWS)</span><br><span class="line"><span class="keyword">elseif</span>(UNIX)</span><br><span class="line">    <span class="keyword">add_definitions</span>(-DLINUX)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure><p>While：<br>可以构想一个场景，比如说，你需要在一列文件中搜索某个特定的文件，并将它的路径设置为变量：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(files <span class="string">&quot;file1.txt&quot;</span> <span class="string">&quot;file2.txt&quot;</span> <span class="string">&quot;file3.txt&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(found <span class="keyword">FALSE</span>)</span><br><span class="line"><span class="keyword">set</span>(i <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">NOT</span> found <span class="keyword">AND</span> i <span class="keyword">LESS</span> <span class="keyword">list</span>(LENGTH files))</span><br><span class="line">    <span class="keyword">list</span>(GET files <span class="variable">$&#123;i&#125;</span> current_file)</span><br><span class="line">    <span class="keyword">if</span>(current_file <span class="keyword">STREQUAL</span> <span class="string">&quot;file2.txt&quot;</span>)</span><br><span class="line">        <span class="keyword">set</span>(found <span class="keyword">TRUE</span>)</span><br><span class="line">        <span class="keyword">set</span>(special_file_path <span class="variable">$&#123;current_file&#125;</span>)</span><br><span class="line">    <span class="keyword">endif</span>()</span><br><span class="line">    <span class="keyword">math</span>(EXPR i <span class="string">&quot;$&#123;i&#125; + 1&quot;</span>)</span><br><span class="line"><span class="keyword">endwhile</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;Special file found at: $&#123;special_file_path&#125;&quot;</span>)</span><br></pre></td></tr></table></figure><p>foreach：<br>用来存储源文件名，便于后期的管理</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(src_files <span class="string">&quot;main.cpp&quot;</span> <span class="string">&quot;utils.cpp&quot;</span> <span class="string">&quot;widget.cpp&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span>(src_file IN LISTS src_files)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;Source file: $&#123;src_file&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">endforeach</span>()</span><br></pre></td></tr></table></figure><p>Function：<br>用来封装命令<br>如上面的命令就可以封装</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>(print_source_files)</span><br><span class="line">    <span class="keyword">foreach</span>(src_file IN LISTS ARGN)<span class="comment">#使用`ARGN`关键字来接收传递给函数的所有未命名参数。`ARGN`在函数中代表所有未处理的参数列表。</span></span><br><span class="line">        <span class="keyword">message</span>(STATUS <span class="string">&quot;Source file: $&#123;src_file&#125;&quot;</span>)</span><br><span class="line">    <span class="keyword">endforeach</span>()</span><br><span class="line"><span class="keyword">endfunction</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(src_files <span class="string">&quot;main.cpp&quot;</span> <span class="string">&quot;utils.cpp&quot;</span> <span class="string">&quot;widget.cpp&quot;</span>) print_source_files(<span class="variable">$&#123;src_files&#125;</span>)</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">macro</span>(print_source_files)</span><br><span class="line">    <span class="keyword">foreach</span>(src_file IN LISTS ARGN)</span><br><span class="line">        <span class="keyword">message</span>(STATUS <span class="string">&quot;Source file: $&#123;src_file&#125;&quot;</span>)</span><br><span class="line">    <span class="keyword">endforeach</span>()</span><br><span class="line"><span class="keyword">endmacro</span>()</span><br><span class="line"><span class="keyword">set</span>(src_files <span class="string">&quot;main.cpp&quot;</span> <span class="string">&quot;utils.cpp&quot;</span> <span class="string">&quot;widget.cpp&quot;</span>) print_source_files(<span class="variable">$&#123;src_files&#125;</span>)</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>]]></content>
      
      
      <categories>
          
          <category> CMake </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CMake </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMake处理项目流程（处理项目时究竟干了些什么事情）</title>
      <link href="/posts/caf7ca08.html"/>
      <url>/posts/caf7ca08.html</url>
      
        <content type="html"><![CDATA[<h3 id="总体流程"><a href="#总体流程" class="headerlink" title="总体流程"></a>总体流程</h3><div class="tabs" id="uniquename1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename1-1"><i class="icon"></i>总体流程</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename1-1"><p>CMake 的流程有以下的步骤<br><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/adcafcassefsevrbyhbdrt.png" alt="[Pasted image 20240107134748.png]"><br>了解过程会更好地帮助我们去理解整个 cmake 在干什么，debug 的时候更容易去定位错误</p><p>例如当对于任意合法的 <code>CMakelist.txt</code> 执行 <code>cmake --build .</code><br>Configuring done 配置完成<br>Generating done 生成完成<br>Build files have been written to… 构建文件已写入…（说明构建成功）<br><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/gvbseryhntuyjij.png" alt="[Pasted image 20240107134926.png]"><br>如果构建不合法则会出现<br><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/evtgrbdhuyjwraeftgbrhe.png" alt="[Pasted image 20240107160422.png]"><br>如果是配置和生成出现错误，那么就一定是 CMake 配置或 CMakelist 配置没有配置好</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h3 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h3><div class="tabs" id="uniquename2"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename2-1"><i class="icon"></i>编译过程</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename2-1"><p>事实上，CMake 只是处理配置和生成两个阶段，换一句话说 CMake 的配置和生成都是 cmake 自己的事情，而到了编译阶段则是调用其他的工具来进行编译 CMake 可以通过特定的命令（如 <code>cmake --build .</code>）来调用这些工具，但本质上它是在为这些工具提供参数，实际的编译工作是由那些如 <code>make</code>, <code>ninja</code> 工具完成的。（区分好各司什么职很重要）</p><h4 id="以下是编译过程："><a href="#以下是编译过程：" class="headerlink" title="以下是编译过程："></a>以下是编译过程：</h4><p><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/textgif.gif" alt="[textgif 1.gif]"></p><p><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/gsdrghdthrtdjhftuty.png" alt="[Pasted image 20231223205158.png]"><br><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/dafrgtfjhnmyrtdthsthstrth.png" alt="[Pasted image 20231223205452.png]"><br><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/awdfvsfgvsgvsregvrse.png" alt="[Pasted image 20231223205647.png]"><br>接下来我们通过 g++来来看看具体是怎么样处理的</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><div class="tabs" id="uniquename3"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename3-1"><i class="icon"></i>预处理</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename3-1"><p><code>g++ -E main.cpp -o main.i</code> 预处理<br><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/faefwefewagvwe.png" alt="[Pasted image 20231223211045.png]"><br><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/dfsefgvshtuufjj.png" alt="[Pasted image 20231223211312.png]"></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><div class="tabs" id="uniquename4"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename4-1"><i class="icon"></i>编译</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename4-1"><p><code>g++ -S main.i -o main.s</code> 编译<br><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/awdiuguikluogiou.png" alt="[Pasted image 20231223211523.png]"><br><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/asdfegsrghrthtfghrt.png" alt="[Pasted image 20231223211601.png]"></p><p>经过预处理和编译我们得到如下文件<br><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/adfsefgvrsgbrtgbehrgbszrsgb.png" alt="[Pasted image 20231223211751.png]"><br>这些也不必去全部一步一步进行，可以直接走最后一步从而走完全部过程<br>如下，但是只会得到最后的 <code>.o</code> 文件<br><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/sadasfsgbreertgserg.png" alt="[Pasted image 20231223212517.png]"><br><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/adjwjojoawjocikjkwdla.png" alt="[Pasted image 20231223212456.png]"></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h3 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h3><div class="tabs" id="uniquename5"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename5-1"><i class="icon"></i>汇编</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename5-1"><p><code>g++ -c add.s -o add.o</code><br><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/adhwhakjhkjzhnjdkajsdk.png" alt="[Pasted image 20231223213434.png]"><br>汇编成机器码文件</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><div class="tabs" id="uniquename6"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename6-1"><i class="icon"></i>链接</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename6-1"><p><code>g++ main.o add.o -o main</code><br><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/sajdoiiojijdoijwoijdoiajwoid.png" alt="[Pasted image 20231223213737.png]"></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><div class="tabs" id="uniquename7"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename7-1"><i class="icon"></i>总结</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename7-1"><p>CMake <code>.c</code> 或 <code>.cpp</code> 文件，在预处理阶段会引入 <code>.h</code> 文件生成包含所有需要的代码 <code>.i</code> 文件，经过编译生成汇编语言构成的 <code>.s</code> 文件，再汇编成目标所需的机器码 <code>.o</code> 文件，将 <code>.o</code> 文件集体打包就是 <code>.a</code> 静态库文件/ <code>. So</code> 动态库文件，最后链接成 <code>无后缀/.out</code> 的可执行文件</p><div class="table-container"><table><thead><tr><th>描述</th><th>Linux 后缀</th><th>Windows 后缀</th></tr></thead><tbody><tr><td>汇编源文件</td><td>. S 或 .S</td><td>. Asm</td></tr><tr><td>C/C++ 源文件</td><td>. C / .cpp</td><td>. C / .cpp 或 .cc</td></tr><tr><td>C/C++ 头文件</td><td>. H</td><td>. H</td></tr><tr><td>目标文件</td><td>. O</td><td>. Obj</td></tr><tr><td>静态库文件</td><td>. A</td><td>. Lib 或 .a</td></tr><tr><td>动态库/共享库文件</td><td>. So</td><td>. Dll</td></tr><tr><td>可执行文件</td><td>*(无后缀) 或 .out</td><td>. Exe</td></tr><tr><td>脚本文件</td><td>*(无后缀) 或 .sh</td><td>. Bat 或 .ps 1</td></tr><tr><td>CMake 配置文件</td><td>CMakeLists. Txt</td><td>CMakeLists. Txt</td></tr><tr><td>CMake 缓存文件</td><td>CMakeCache. Txt</td><td>CMakeCache. Txt</td></tr></tbody></table></div></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>]]></content>
      
      
      <categories>
          
          <category> CMake </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CMake </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMake如何编译一个.cpp文件</title>
      <link href="/posts/ed2a79d8.html"/>
      <url>/posts/ed2a79d8.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><div class="tabs" id="uniquename1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename1-1"><i class="icon"></i>前言</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename1-1"><p>本文分享的是关于如何去最简单地通过 CMake 去编译一个文件。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h3 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h3><div class="tabs" id="uniquename2"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename2-1"><i class="icon"></i>准备阶段</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename2-1"><p>首先先编写一个 <code>.cpp</code> 文件和 <code>.hh</code> 头文件<br><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/sdfgcgjkghhjg.png" alt="[Pasted image 20240107212230.png]"><br>内容如下<br><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/adsgghkyuyerwrwdcxdv.png" alt="[Pasted image 20240107212204.png]"><br><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/fhjhsdfsdytgf.png" alt="[Pasted image 20240107212454.png]"><br><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/shjgkujtrgarty.png" alt="[Pasted image 20240107212601.png]"><br>和可执行文件 <code>.main</code><br><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/dwatgdyjedfvgh.png" alt="[Pasted image 20240107212534.png]"><br><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/sdffckjrfcdsgvbtgewfgv.png" alt="[Pasted image 20240107212411.png]"></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h3 id="编写-CMakelists"><a href="#编写-CMakelists" class="headerlink" title="编写 CMakelists"></a>编写 CMakelists</h3><div class="tabs" id="uniquename3"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename3-1"><i class="icon"></i>编写 CMakelists</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename3-1"><p>在 main 的同级目录下创建一个 <code>CMakelist.txt</code> 的文件<br>编译如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">project(cmake_study)#定义一个项目名</span><br><span class="line">add_executable(lesson1_1 main.cpp add.hh add.cpp)#把需要的文件交给cmake进行编译</span><br></pre></td></tr></table></figure><p>然后我们就可以看到构建出来的文件<br><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/fgdykgujhtrgvfcwfgerrtyy.png" alt="[Pasted image 20240107213517.png]"><br>然后我们 cd 到 build 目录下运行 <code>.\lesson1_1.exe</code>（在 win 下的指令，如果是在 linux 系统下要用 <code>./lesson1_1.exe</code>）然后我们就得到输出的结果 <img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/fsfgtfjukiukyukyu.png" alt="[Pasted image 20240107215230.png]"></p><p>这就是已经可以最简单去编译一个 <code>.cpp</code> 文件了</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h3 id="一些优化"><a href="#一些优化" class="headerlink" title="一些优化"></a>一些优化</h3><div class="tabs" id="uniquename4"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename4-1"><i class="icon"></i>一些优化</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename4-1"><p>然后我们也可以把头文件通过 <code>include_directories(头文件绝对路径)</code> 的形式引入，或者更好的方式是 <code>target_include_directories（）</code> 这样我们就可以只 <code>add_executable(lesson2 main.cpp sub.cpp)</code> 而不需要再把头文件一并放进去，如果头文件在其他地方，那么这个优化可以隐藏一长串路径</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>]]></content>
      
      
      <categories>
          
          <category> CMake </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CMake </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从Makefile到CMake</title>
      <link href="/posts/caf7ca09.html"/>
      <url>/posts/caf7ca09.html</url>
      
        <content type="html"><![CDATA[<h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><div class="tabs" id="uniquename1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename1-1"><i class="icon"></i>开始</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename1-1"><p>原始的文件如下 ：</p><p><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/V7897987.png" alt=""></p><p>我们新建一个 Makefile</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">main: main.cpp add.cpp</span></span><br><span class="line"></span><br><span class="line">    g++ main.cpp add.cpp -o main</span><br></pre></td></tr></table></figure><p>然后再同级目录下就可以调用 make 文件来生成可执行文件了，<code>cs 144</code> 中 <code>lab 0</code> 也是如此，其中 make 的动作用处就是制作可执行文件 webget，然后传入两个参数的同时调用程序</p><p><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/I_]P3~K]62342342.png" alt=""></p><p>回到我们刚刚的代码，这里我们同级目录下 make<br><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/vagrfseggset.png" alt=""><br>出现可执行文件：<br><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/snhtsretbdrtbhrdtydrbhybhdrgtf.png" alt=""></p><p>那么怎么方便的 Makefile 为什么我们还需要使用 CMake？</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h3 id="统一了编译流程"><a href="#统一了编译流程" class="headerlink" title="统一了编译流程"></a>统一了编译流程</h3><div class="tabs" id="uniquename2"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename2-1"><i class="icon"></i>统一了编译流程</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename2-1"><p>虽然 Makefile 直接通过 make 就可以编译，似乎很简单，但是遇到的问题就是在于无法跨平台使用（假设只能在 win 上使用 visualstudio)<br>所以 CMake 就起到了统一的作用</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h3 id="如何通过-CMake-来编译可执行文件"><a href="#如何通过-CMake-来编译可执行文件" class="headerlink" title="如何通过 CMake 来编译可执行文件"></a>如何通过 CMake 来编译可执行文件</h3><div class="tabs" id="uniquename3"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename3-1"><i class="icon"></i>如何通过 CMake 来编译可执行文件</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename3-1"><h4 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h4><p>由于我们的编译文件都在同级所以要先移动到 build 文件下<br><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/dawdfafsbzrfnhfmgu.png" alt=""><br><code>cmake ..</code> 后面一个参数-B 的作用是指定 <code>Makelists.txt</code> 的位置<br>可以看到 build 文件夹下就有我们编译好的文件了<br><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/fsdghgikjfhfdr.png" alt=""><br>而这个过程在 win 平台下也是统一的，十分的方便</p><h4 id="生成可执行文件"><a href="#生成可执行文件" class="headerlink" title="生成可执行文件"></a>生成可执行文件</h4><p>然后我们通过最后的 <code>cmake --build .</code> 也是各个平台通用的<br><img src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/cfaetfgvbtfbXDsrbhy.png" alt=""></p><p>然后我们还可以通过 <code>cmake ../lesson1_1 -DCMAKE_ ERBOSE_MAKEFILE=ON</code> 添加一个开关来输出生成可执行文件的详细的信息，做到对编译工具的打印信息进行自定义管理</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>]]></content>
      
      
      <categories>
          
          <category> CMake </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CMake </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMake是一个怎么样的工具</title>
      <link href="/posts/7e66a467.html"/>
      <url>/posts/7e66a467.html</url>
      
        <content type="html"><![CDATA[<h3 id="CMake-是什么"><a href="#CMake-是什么" class="headerlink" title="CMake 是什么"></a>CMake 是什么</h3><div class="tabs" id="uniquename1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename1-1"><i class="icon"></i>CMake 是什么</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename1-1"><p>是一个工具集，用来生成构建工具脚本，例如 ninja（跨平台），make（linux），visual studio（win），xcode（mac）<br>就像一个厨师，你把菜递给他，他选择用什么样的工具帮您编译。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h3 id="CMake-的作用"><a href="#CMake-的作用" class="headerlink" title="CMake 的作用"></a>CMake 的作用</h3><div class="tabs" id="uniquename2"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename2-1"><i class="icon"></i>CMake 的作用</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename2-1"><p>总得来说</p><ul><li>作用是：编译+测试+打包</li></ul><ol><li>生成构建工具，构建源码</li><li>单元测试</li><li>打包（编译构建工具，或者是源码）比如说做成 rpm 包之类的，就是给人的印象很好，因为是适配平台的直接安装的过程，而则需要用到打包</li></ol></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h3 id="为什么需要-CMake"><a href="#为什么需要-CMake" class="headerlink" title="为什么需要 CMake"></a>为什么需要 CMake</h3><div class="tabs" id="uniquename3"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="uniquename3-1"><i class="icon"></i>为什么需要 CMake</button></ul><div class="tab-contents"><div class="tab-item-content active" id="uniquename3-1"><h4 id="使用便利"><a href="#使用便利" class="headerlink" title="使用便利"></a>使用便利</h4><p>其实从最大的用处上来说，他们就是提供了一个平台，实现编译期大部分跨平台的功能（如果调用了系统的 API 可能跨不了）。如果你学会 CMake，那么就无需纠结你是在什么平台下去编译，而额外学习一门新的工具，真正做到了一站式通用。<br>例如可以看这一篇： <a class="btn-anzhiyu " href="https://blog.anheyu.com/"   title="从Makefile到CMake"><i class="anzhiyufont anzhiyu-icon-circle-arrow-right"></i><span>从Makefile到CMake</span></a></p><h4 id="历史原因"><a href="#历史原因" class="headerlink" title="历史原因"></a>历史原因</h4><p>CMake 的产生可以追溯到20世纪90年代末期。当时，为了提高软件跨平台的构建效率，Kitware的团队开始开发一个名为CMake（Cross-platform Make）的工具。CMake 最初是为了简化 ITK（Insight Segmentation and Registration Toolkit）项目在不同平台上的编译而开发的。后来，开发团队意识到这样一个工具对于广大开发者来说将是非常有用的，所以他们决定将其开源。随后，CMake 很快成为了开源社区中广泛接受的构建系统之一，特别是它的简洁和扩展性得到了很多大型项目的青睐，例如 KDE，OpenCV 等。</p><h4 id="帮助理解编译流程"><a href="#帮助理解编译流程" class="headerlink" title="帮助理解编译流程"></a>帮助理解编译流程</h4><p>我在第一去学习 c++使用是使用的 Visual Studio ，而没有经常性去接触到关于项目构建的问题，有时候会出现链接问题，而去查看相关 blog 的时候也是一知半解，但是结果 CMake 的学习之后才是真正理解了编译流程</p><h4 id="方便项目的管理"><a href="#方便项目的管理" class="headerlink" title="方便项目的管理"></a>方便项目的管理</h4><p>由于每一个文件都有 CMakelist 的 txt 文件，所以只要是出现编译相关的错误我们可以很快速的定位到 CMakelist 是错误配置，而写成类似文档的形式，排除起来也比命令行简单。</p><h4 id="其他高级功能"><a href="#其他高级功能" class="headerlink" title="其他高级功能"></a>其他高级功能</h4><p><strong>自动化侦测</strong>：CMake 可以自动检测系统环境，寻找编译器、库和其他工具，自动化处理许多编译时需要的设置。<br><strong>高级功能</strong>：CMake 提供了丰富的指令集合，用于实现诸如编译选项管理、依赖关系追踪、测试自动化、安装和打包等高级构建功能。<br><strong>多配置生成</strong>：CMake 能够为多种构建类型生成配置（如 Debug、Release），便于开发者在不同的构建类型之间切换。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>]]></content>
      
      
      <categories>
          
          <category> CMake </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CMake </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMake学习分享-前言</title>
      <link href="/posts/e1539f30.html"/>
      <url>/posts/e1539f30.html</url>
      
        <content type="html"><![CDATA[<h3 id="主体思路"><a href="#主体思路" class="headerlink" title="主体思路"></a>主体思路</h3><div class="tabs" id="unique-name"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="unique-name-1"><i class="icon"></i></button></ul><div class="tab-contents"><div class="tab-item-content active" id="unique-name-1"><p>本系列会采用自顶向下的想法来给大家分享学习的 CMake<br>过程中会举简单的例子，例子会通过图片的形式，或是理清楚结构，或是给于相对应的代码-打印给一个直观的表现。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h2 id="CMake-章节"><a href="#CMake-章节" class="headerlink" title="CMake 章节"></a>CMake 章节</h2><div class="tabs" id="myuniquetabs"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="myuniquetabs-1"><i class="icon" style="text-align: center;"></i></button></ul><div class="tab-contents"><div class="tab-item-content active" id="myuniquetabs-1"><ul><li>引入<ul><li>CMake学习分享-前言</li><li>CMake是一个怎么样的工具<ul><li>从Makefile到CMake</li></ul></li></ul></li><li>开始·<ul><li>如何编译一个.cpp文件</li><li>CMake 处理项目流程（处理项目时究竟干了些什么事情）</li></ul></li><li>CMake 语法<ul><li>CMake_流程控制，函数和宏</li><li>CMake_message，set，list的用法</li></ul></li><li>进一步<ul><li>如何统一编译管理多个.cpp文件</li></ul></li><li>CMake 库<ul><li>CMake 静态库</li><li>CMake 动态库</li><li>CMake 平台差异</li></ul></li><li>优化<ul><li>CMake 降低耦合</li><li>CMake常用指令推荐</li><li>CMake优雅地使用环境变量</li></ul></li><li>更进一步<ul><li>通过CMake使用opencv-lesson 2_CMake</li></ul></li></ul></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h2 id="心路历程"><a href="#心路历程" class="headerlink" title="心路历程"></a>心路历程</h2><div class="tabs" id="myuniquetabs"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="myuniquetabs-1"><i class="icon"></i></button></ul><div class="tab-contents"><div class="tab-item-content active" id="myuniquetabs-1"><p>学习 CMake 我也是学习不久，很多方面都是在 b 站看“简明教程“和“比飞鸟贵重的多_HKL”两位 up 主的教学，我想做到的是能够把这两位 up 主讲的汇总在一起，并且通过我的理解，告诉大家。从项目接触看来，我其实能力十分有限，只能为大家尽力带来我的视角下对于 CMake 的理解，如果能帮助到大家就好。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>]]></content>
      
      
      <categories>
          
          <category> CMake </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CMake </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS144-5</title>
      <link href="/posts/d466e783.html"/>
      <url>/posts/d466e783.html</url>
      
        <content type="html"><![CDATA[<h1 id="CS144-5"><a href="#CS144-5" class="headerlink" title="CS144-5"></a>CS144-5</h1><div class="tabs" id="test1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="test1-1">test1 1</button></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>前言</strong><br><code>cmake --build build --target check4</code>如下就可以开始代码了</p><p><div class="img-wrap"><div class="img-bg"><img class="img" src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/屏幕截图-2023-12-05-195315.png"/></div>&lt;/div&gt;<br>这一次是要实现一个路由表的功能，你需要去做一个存储路由的功能。</p><p>我使用的结构体加vector的组合来实现这一部分，当然你可以自己想一个合适的，我选择这种组合的原因是，用map来实现的话那么用什么来映射呢，又如何知道哪一个是最优的匹配路径，只能通过遍历，然后再通过算法去实现查询，我目前的思路是这样的，所以选择能支持快速增删的简单结构</p><p>其中实现的重点在于寻求最优匹配，这一部分涉及到网络掩码的内容，如果不懂这一部分的友友，可以去b站搜搜看，大概的意思就是多少位是一样的，剩下的这可变化的区域作为子网段，掩码的作用就是规定了这个范围，同时也告诉我们匹配的长度，用于后续求最优的依据。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div class="tabs" id="test1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="test1-1">test1 1</button></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>实验开始</strong><br>我阅读完文档可以罗列出的思路是这样的</p><p><div class="img-wrap"><div class="img-bg"><img class="img" src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/GFWB8XA@@CY2JIZ73BH-1024x847.png"/></div>&lt;/div&gt;<br>实现完代码后的思路是这样的</p><p><div class="img-wrap"><div class="img-bg"><img class="img" src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/NVVVN3M4OYNJKUOVPU-842x1024.png"/></div>&lt;/div&gt;<br>以上就是我整体的思路</p><p>难的是匹配路由表的函数，这个函数是需要通过提供的匹配长度，然后推算出当前是否是匹配的路由，后面我们可以通过这个匹配长度来判断是否是最优的</p><p>判断最优的过程是找到优的就复制，这和新手村求一组数max是一样的，很简单。</p><p>然后就是如何匹配，我们知道ip也是0和1的世界，所以我们匹配0和1的时候只要与一下不就可以了？思路是不是一下子就出来了。</p><p>那就去实现吧，我代码放在文末</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div class="tabs" id="test1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="test1-1">test1 1</button><button type="button" class="tab " data-href="test1-2">test1 2</button></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>router.cc</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;router.hh&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// route_prefix: The &quot;up-to-32-bit&quot; IPv4 address prefix to match the datagram&#x27;s destination address against</span></span><br><span class="line"><span class="comment">// prefix_length: For this route to be applicable, how many high-order (most-significant) bits of</span></span><br><span class="line"><span class="comment">//    the route_prefix will need to match the corresponding bits of the datagram&#x27;s destination address?</span></span><br><span class="line"><span class="comment">// next_hop: The IP address of the next hop. Will be empty if the network is directly attached to the router (in</span></span><br><span class="line"><span class="comment">//    which case, the next hop address should be the datagram&#x27;s final destination).</span></span><br><span class="line"><span class="comment">// interface_num: The index of the interface to send the datagram out on.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// route_prefix: 要与数据报目的地址匹配的“最多32位”的IPv4地址前缀</span></span><br><span class="line"><span class="comment">// prefix_length: 此路由适用所需的条件，即数据报目的地址的高阶（最重要）位中有多少位需要与路由前缀对应的位匹配？</span></span><br><span class="line"><span class="comment">// next_hop: 下一跳的IP地址。如果网络直接连接到路由器，则为空（在这种情况下，下一跳地址应该是数据报的最终目的地）。</span></span><br><span class="line"><span class="comment">// interface_num: 发送数据报的接口索引。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Router::add_route</span><span class="params">( <span class="type">const</span> <span class="type">uint32_t</span> route_prefix,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="type">const</span> <span class="type">uint8_t</span> prefix_length,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="type">const</span> optional&lt;Address&gt; next_hop,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="type">const</span> <span class="type">size_t</span> interface_num )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cerr &lt;&lt; <span class="string">&quot;DEBUG: adding route &quot;</span> &lt;&lt; Address::<span class="built_in">from_ipv4_numeric</span>( route_prefix ).<span class="built_in">ip</span>() &lt;&lt; <span class="string">&quot;/&quot;</span></span><br><span class="line">       &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;( prefix_length ) &lt;&lt; <span class="string">&quot; =&gt; &quot;</span> &lt;&lt; ( next_hop.<span class="built_in">has_value</span>() ? next_hop-&gt;<span class="built_in">ip</span>() : <span class="string">&quot;(direct)&quot;</span> )</span><br><span class="line">       &lt;&lt; <span class="string">&quot; on interface &quot;</span> &lt;&lt; interface_num &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="comment">//什么样的消息我们不要更新路由表？</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置一下路由信息</span></span><br><span class="line">  Route_Message route_message;</span><br><span class="line">  route_message.interface_num=interface_num;</span><br><span class="line">  route_message.next_hop=next_hop;</span><br><span class="line">  route_message.prefix_length=prefix_length;</span><br><span class="line">  route_message.route_prefix=route_prefix;</span><br><span class="line"><span class="comment">//存储路由信息</span></span><br><span class="line">  route_map.<span class="built_in">push_back</span>(route_message);</span><br><span class="line">  (<span class="type">void</span>)route_prefix;</span><br><span class="line">  (<span class="type">void</span>)prefix_length;</span><br><span class="line">  (<span class="type">void</span>)next_hop;</span><br><span class="line">  (<span class="type">void</span>)interface_num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ip_matches_route</span><span class="params">(<span class="type">uint32_t</span> ip_address, <span class="type">uint32_t</span> route_prefix, <span class="type">uint8_t</span> prefix_length)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(prefix_length&gt;<span class="number">32</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">uint32_t</span> subnet_mask = prefix_length == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">0xFFFFFFFF</span> &lt;&lt; (<span class="number">32</span> - prefix_length);</span><br><span class="line"><span class="type">uint32_t</span> masked_ip = ip_address &amp; subnet_mask;</span><br><span class="line"><span class="type">uint32_t</span> masked_route_prefix = route_prefix &amp; subnet_mask;</span><br><span class="line"><span class="keyword">return</span> masked_ip == masked_route_prefix;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Router::route</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//当前是否有接口传输数据</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;it:interfaces_)&#123;</span><br><span class="line">  <span class="keyword">auto</span> datagram=it.<span class="built_in">maybe_receive</span>();</span><br><span class="line">  <span class="keyword">if</span>(!datagram.<span class="built_in">has_value</span>())&#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">auto</span>&amp; dgram=datagram.<span class="built_in">value</span>();</span><br><span class="line">  <span class="comment">//是否已经有已经不存在的路由</span></span><br><span class="line">  <span class="keyword">if</span>(dgram.header.ttl&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//否者计算校验和，更新ttl</span></span><br><span class="line">  dgram.header.ttl--;</span><br><span class="line">  dgram.header.<span class="built_in">compute_checksum</span>();</span><br><span class="line">  <span class="comment">//是否找得到匹配一个段?</span></span><br><span class="line">  <span class="comment">//获取ip地址</span></span><br><span class="line">  <span class="type">uint32_t</span> IP=dgram.header.dst;</span><br><span class="line">  <span class="comment">//设置最匹配地址</span></span><br><span class="line">  Route_Message bestMatchRoute&#123;&#125;;</span><br><span class="line">  <span class="type">bool</span> hasBestMatch = <span class="literal">false</span>; <span class="comment">// 新增变量来跟踪是否找到有效匹配</span></span><br><span class="line">  <span class="type">size_t</span> i=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(i&lt;route_map.<span class="built_in">size</span>())&#123;</span><br><span class="line">    <span class="comment">// cout&lt;&lt;&quot;发送之前&quot;&lt;&lt;endl;</span></span><br><span class="line">    <span class="comment">// cout&lt;&lt;&quot;bestMatchRoute.prefix_length:&quot;&lt;&lt;to_string(bestMatchRoute.prefix_length)&lt;&lt;endl;</span></span><br><span class="line">    <span class="comment">// cout&lt;&lt;&quot;route_map[i].prefix_length:&quot;&lt;&lt;to_string(route_map[i].prefix_length)&lt;&lt;endl;</span></span><br><span class="line">    <span class="comment">// cout&lt;&lt;&quot;hasBestMatch:&quot;&lt;&lt;hasBestMatch&lt;&lt;endl;</span></span><br><span class="line">    <span class="comment">// cout&lt;&lt;&quot;IP:&quot;&lt;&lt;IP&lt;&lt;endl;</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">ip_matches_route</span>(IP,route_map[i].route_prefix,route_map[i].prefix_length))&#123;</span><br><span class="line">      i++;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当前的是否需要更新，如果没有赋值先赋值，如果已经初始化了就看看是不是需要更新</span></span><br><span class="line">    <span class="keyword">if</span>(hasBestMatch&amp;&amp;bestMatchRoute.prefix_length&gt;=route_map[i].prefix_length)&#123;</span><br><span class="line">      i++;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    bestMatchRoute=route_map[i];</span><br><span class="line">    hasBestMatch=<span class="literal">true</span>;</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//有合适下一跳？</span></span><br><span class="line">  <span class="keyword">if</span>(!hasBestMatch)&#123;</span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">auto</span> &amp;async_NetworkInterface=<span class="built_in">interface</span>(bestMatchRoute.interface_num);</span><br><span class="line">async_NetworkInterface.<span class="built_in">send_datagram</span>(dgram, </span><br><span class="line">            bestMatchRoute.next_hop.<span class="built_in">value_or</span>(Address::<span class="built_in">from_ipv4_numeric</span>(IP)));</span><br><span class="line">    <span class="comment">// cout&lt;&lt;&quot;发送之后&quot;&lt;&lt;endl;</span></span><br><span class="line">    <span class="comment">// cout&lt;&lt;&quot;bestMatchRoute.prefix_length:&quot;&lt;&lt;to_string(bestMatchRoute.prefix_length)&lt;&lt;endl;</span></span><br><span class="line">    <span class="comment">// cout&lt;&lt;&quot;route_map[i].prefix_length:&quot;&lt;&lt;to_string(route_map[i].prefix_length)&lt;&lt;endl;</span></span><br><span class="line">    <span class="comment">// cout&lt;&lt;&quot;hasBestMatch:&quot;&lt;&lt;hasBestMatch&lt;&lt;endl;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></div><div class="tab-item-content" id="test1-2"><p><strong>router.hh</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;network_interface.hh&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;optional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// A wrapper for NetworkInterface that makes the host-side</span></span><br><span class="line"><span class="comment">// interface asynchronous: instead of returning received datagrams</span></span><br><span class="line"><span class="comment">// immediately (from the `recv_frame` method), it stores them for</span></span><br><span class="line"><span class="comment">// later retrieval. Otherwise, behaves identically to the underlying</span></span><br><span class="line"><span class="comment">// implementation of NetworkInterface.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对NetworkInterface的包装，使得主机侧的接口变为异步：不是立即返回收到的数据报</span></span><br><span class="line"><span class="comment">//（来自`recv_frame`方法），而是将它们存储起来以供稍后检索。除此之外，</span></span><br><span class="line"><span class="comment">// 其行为与底层实现的NetworkInterface相同。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AsyncNetworkInterface</span> : <span class="keyword">public</span> NetworkInterface</span><br><span class="line">&#123;</span><br><span class="line">  std::queue&lt;InternetDatagram&gt; datagrams_in_ &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> NetworkInterface::NetworkInterface;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Construct from a NetworkInterface</span></span><br><span class="line">  <span class="comment">// 从NetworkInterface构造</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">AsyncNetworkInterface</span><span class="params">( NetworkInterface&amp;&amp; interface )</span> : NetworkInterface( interface ) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// \brief Receives and Ethernet frame and responds appropriately.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// - If type is IPv4, pushes to the `datagrams_out` queue for later retrieval by the owner.</span></span><br><span class="line">  <span class="comment">// - If type is ARP request, learn a mapping from the &quot;sender&quot; fields, and send an ARP reply.</span></span><br><span class="line">  <span class="comment">// - If type is ARP reply, learn a mapping from the &quot;target&quot; fields.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// \param[in] frame the incoming Ethernet frame</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// \brief 接收Ethernet帧并做出相应的响应。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// - 如果类型是IPv4，则将其推入`datagrams_out`队列，以供所有者稍后检索。</span></span><br><span class="line">  <span class="comment">// - 如果类型是ARP请求，则学习“发送者”字段中的映射，并发送ARP回复。</span></span><br><span class="line">  <span class="comment">// - 如果类型是ARP回复，则学习“目标”字段中的映射。</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// \param[in] frame 进来的Ethernet帧</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">recv_frame</span><span class="params">( <span class="type">const</span> EthernetFrame&amp; frame )</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> optional_dgram = NetworkInterface::<span class="built_in">recv_frame</span>( frame );</span><br><span class="line">    <span class="keyword">if</span> ( optional_dgram.<span class="built_in">has_value</span>() ) &#123;</span><br><span class="line">      datagrams_in_.<span class="built_in">push</span>( std::<span class="built_in">move</span>( optional_dgram.<span class="built_in">value</span>() ) );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Access queue of Internet datagrams that have been received</span></span><br><span class="line">  <span class="comment">// 访问已收到的Internet数据报队列</span></span><br><span class="line"></span><br><span class="line">  <span class="function">std::optional&lt;InternetDatagram&gt; <span class="title">maybe_receive</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( datagrams_in_.<span class="built_in">empty</span>() ) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    InternetDatagram datagram = std::<span class="built_in">move</span>( datagrams_in_.<span class="built_in">front</span>() );</span><br><span class="line">    datagrams_in_.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">return</span> datagram;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构建路由信息</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Route_Message</span>&#123;</span><br><span class="line">  <span class="type">uint32_t</span> route_prefix&#123;&#125;;</span><br><span class="line">  <span class="type">uint8_t</span> prefix_length&#123;&#125;;</span><br><span class="line">  std::optional&lt;Address&gt; next_hop&#123;&#125;;</span><br><span class="line">  <span class="type">size_t</span> interface_num&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// A router that has multiple network interfaces and</span></span><br><span class="line"><span class="comment">// performs longest-prefix-match routing between them.</span></span><br><span class="line"><span class="comment">// 一个拥有多个网络接口并在它们之间进行最长前缀匹配路由的路由器。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Router</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// The router&#x27;s collection of network interfaces</span></span><br><span class="line">    <span class="comment">// 路由器的网络接口集合</span></span><br><span class="line">  std::vector&lt;AsyncNetworkInterface&gt; interfaces_ &#123;&#125;;</span><br><span class="line">   <span class="comment">//构建路由映射</span></span><br><span class="line">  std::vector&lt;Route_Message&gt; route_map &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//设置辅助函数</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add an interface to the router</span></span><br><span class="line">  <span class="comment">// interface: an already-constructed network interface</span></span><br><span class="line">  <span class="comment">// returns the index of the interface after it has been added to the router</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向路由器添加一个接口</span></span><br><span class="line">  <span class="comment">// interface: 一个已经构造好的网络接口</span></span><br><span class="line">  <span class="comment">// 返回添加到路由器后的接口索引 </span></span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">add_interface</span><span class="params">( AsyncNetworkInterface&amp;&amp; interface )</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    interfaces_.<span class="built_in">push_back</span>( std::<span class="built_in">move</span>( interface ) );</span><br><span class="line">    <span class="keyword">return</span> interfaces_.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Access an interface by index</span></span><br><span class="line">  <span class="comment">// 通过索引访问接口</span></span><br><span class="line">  <span class="function">AsyncNetworkInterface&amp; <span class="title">interface</span><span class="params">( <span class="type">size_t</span> N )</span> </span>&#123; <span class="keyword">return</span> interfaces_.<span class="built_in">at</span>( N ); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add a route (a forwarding rule)</span></span><br><span class="line">  <span class="comment">// 添加一条路由（一条转发规则）</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">add_route</span><span class="params">( <span class="type">uint32_t</span> route_prefix,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">uint8_t</span> prefix_length,</span></span></span><br><span class="line"><span class="params"><span class="function">                  std::optional&lt;Address&gt; next_hop,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">size_t</span> interface_num )</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Route packets between the interfaces. For each interface, use the</span></span><br><span class="line">  <span class="comment">// maybe_receive() method to consume every incoming datagram and</span></span><br><span class="line">  <span class="comment">// send it on one of interfaces to the correct next hop. The router</span></span><br><span class="line">  <span class="comment">// chooses the outbound interface and next-hop as specified by the</span></span><br><span class="line">  <span class="comment">// route with the longest prefix_length that matches the datagram&#x27;s</span></span><br><span class="line">  <span class="comment">// destination address.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在接口之间路由数据报。对于每个接口，使用</span></span><br><span class="line">  <span class="comment">// maybe_receive() 方法消费每个进入的数据报，</span></span><br><span class="line">  <span class="comment">// 并根据路由选择正确的下一跳发送到其中一个接口。路由器</span></span><br><span class="line">  <span class="comment">// 根据与数据报目的地址匹配最长前缀长度的路由规则指定出站接口和下一跳。</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">route</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div class="tabs" id="test1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="test1-1">test1 1</button></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>为什么没有lab6,7的文章</strong><br>后面的lab6和lab7都不需要写代码仅仅是一些应用的方面，感兴趣的可以自己去做一下</p><div class="img-wrap"><div class="img-bg"><img class="img" src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/屏幕截图-2023-12-05-202543-1024x874.png"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img" src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/屏幕截图-2023-12-05-202614-1024x691.png"/></div></div></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CS144 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS144-4</title>
      <link href="/posts/a361d715.html"/>
      <url>/posts/a361d715.html</url>
      
        <content type="html"><![CDATA[<h1 id="CS144-4"><a href="#CS144-4" class="headerlink" title="CS144-4"></a>CS144-4</h1><div class="tabs" id="test1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="test1-1">test1 1</button><button type="button" class="tab " data-href="test1-2">test1 2</button></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>前言</strong><br><code>cmake - - build build - - target check3</code>如下就可以开始lab4了</p><p><div class="img-wrap"><div class="img-bg"><img class="img" src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/屏幕截图-2023-12-05-190720.png"/></div>&lt;/div&gt;<br>做着这部分最好的就是了解一下报文的类型，和结构关系。我当时做的时候在里面绕了很多弯，比如说误以为ARP以太网包是带普通数据报的，当时想是ARP顺便发过去，后面发现不是，ARP以太网包只含ARP，普通数据以太网包只含普通数据报文（IPV4）。</p></div><div class="tab-item-content" id="test1-2"><div class="img-wrap"><div class="img-bg"><img class="img" src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/LIXKOFMFBV2K8B8K0IVF6.png"/></div></div>其中的我整理的以太网头部对应的数据类型信息如下<div class="img-wrap"><div class="img-bg"><img class="img" src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/SF@97VSHFP3_3LWO6.png"/></div></div></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div class="tabs" id="test1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="test1-1">test1 1</button><button type="button" class="tab " data-href="test1-2">test1 2</button><button type="button" class="tab " data-href="test1-3">test1 3</button><button type="button" class="tab " data-href="test1-4">test1 4</button></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>实验开始</strong><br>鉴于之前我思路不清晰导致一个lab就在调试方面浪费太多太多时间，我后面使用一些图的关系来表示当时的思路</p><div class="img-wrap"><div class="img-bg"><img class="img" src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/UM3QZ6WIP90695R0L9-944x1024.png"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img" src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/VA7EWKM7ZLWJAIKRXXT-882x1024.png"/></div></div></div><div class="tab-item-content" id="test1-2"><p><strong>如何去广播？</strong></p><h1 id="其中会遇到的问题1："><a href="#其中会遇到的问题1：" class="headerlink" title="其中会遇到的问题1："></a>其中会遇到的问题1：</h1><div class="img-wrap"><div class="img-bg"><img class="img" src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/屏幕截图-2023-12-05-192515-1024x85.png"/></div></div></div><div class="tab-item-content" id="test1-3"><p><strong>包有两种那么他们的一个关系是如何的？</strong><br>ARP 包和 ipv 4 包，最大的不同其实也就是以太网包的东西不同，以太网有一个以太网头部和以太网主体部分，以太网头部存储的只有 mac 地址（发送和接收，Ip 的部分分析是由主体部分进行一个拆包实现的，对其包涵的东西进行一个拆包，但是主体仍然存在 mac 地址，这个 mac 地址才是真正需要去注意的，他们只是套着以太网帧的头套干着不同的事情</p></div><div class="tab-item-content" id="test1-4"><p><strong>为什么以太网头和ip头都要有mac地址？</strong><br>传递数据就像是间谍换马甲一样，进入一个国家就穿上一个马甲，也就是 mac 地址只有关于这两个交互国家的，而其中的真正目的 mac 是在主体部分，最后传递到对方手上的时候，以太网帧帧只是从对方的网关的 mac 到对方设备的 mac，mac 地址仅对于当前的局域网或链路是有意义的，并且它们在数据包通过网络传输的过程中会一直变化，直到到达最终的目标设备。而跨越多个网络（国家）的长途传输过程中涉及到的比如 IP 地址等信息则藏于以太网帧的负载（Payload）之内。好处显而易见的实现了一个隐藏 mac 和 ip 的功能保证安全性，同时只关注下一跳实现起来也简单。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div class="tabs" id="test1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="test1-1">test1 1</button><button type="button" class="tab " data-href="test1-2">test1 2</button><button type="button" class="tab " data-href="test1-3">test1 3</button></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>代码</strong><br>在实验过程中要注意实现recv_frame( const EthernetFrame&amp; frame )的时候就算是可以接受的信息也不代表ARP就一定是要你发，也就是说确认是否属于可接收的信息，和检测是否需要你发送是并不包含的，例外就是ARP你可能作为中间进行传递，但并不是一定让你发送你的ARP。而检查是否是你的ARP需要mac地址和ip的双重检测</p><p>以下是我实现的代码，需要自己思考的小伙伴就可以停下了</p></div><div class="tab-item-content" id="test1-2"><p><strong>network_interface.cc</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;network_interface.hh&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;arp_message.hh&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ethernet_frame.hh&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ethernet_address: Ethernet (what ARP calls &quot;hardware&quot;) address of the interface</span></span><br><span class="line"><span class="comment">// ip_address: IP (what ARP calls &quot;protocol&quot;) address of the interface</span></span><br><span class="line"><span class="comment">// ethernet_address: 以太网（ARP协议中称为“硬件”）接口的地址</span></span><br><span class="line"><span class="comment">// ip_address: IP（ARP协议中称为“协议”）接口的地址</span></span><br><span class="line">NetworkInterface::<span class="built_in">NetworkInterface</span>( <span class="type">const</span> EthernetAddress&amp; ethernet_address, <span class="type">const</span> Address&amp; ip_address )</span><br><span class="line">  : <span class="built_in">ethernet_address_</span>( ethernet_address ), <span class="built_in">ip_address_</span>( ip_address )</span><br><span class="line">&#123;</span><br><span class="line">  cerr &lt;&lt; <span class="string">&quot;DEBUG: Network interface has Ethernet address &quot;</span> &lt;&lt; <span class="built_in">to_string</span>( ethernet_address_ ) &lt;&lt; <span class="string">&quot; and IP address &quot;</span></span><br><span class="line">       &lt;&lt; ip_address.<span class="built_in">ip</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dgram: the IPv4 datagram to be sent</span></span><br><span class="line"><span class="comment">// next_hop: the IP address of the interface to send it to (typically a router or default gateway, but</span></span><br><span class="line"><span class="comment">// may also be another host if directly connected to the same network as the destination)</span></span><br><span class="line"><span class="comment">// dgram: 要发送的IPv4数据报</span></span><br><span class="line"><span class="comment">// next_hop: 要将数据报发送到的接口的IP地址（通常是路由器或默认网关，但如果与目的地在同一网络上直接连接，</span></span><br><span class="line"><span class="comment">// 也可能是另一台主机）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Note: the Address type can be converted to a uint32_t (raw 32-bit IP address) by using the</span></span><br><span class="line"><span class="comment">// Address::ipv4_numeric() method.</span></span><br><span class="line"><span class="comment">// 注意：Address类型可以通过使用Address::ipv4_numeric()方法转换为uint32_t（原始的32位IP地址）。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">NetworkInterface::send_datagram</span><span class="params">( <span class="type">const</span> InternetDatagram&amp; dgram, <span class="type">const</span> Address&amp; next_hop )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  EthernetHeader ethernet_header_;</span><br><span class="line">  EthernetFrame ethernet_Frame_;</span><br><span class="line">  <span class="comment">//目的地已知</span></span><br><span class="line">  <span class="keyword">auto</span> mac_address= arp_map_.<span class="built_in">find</span>(next_hop.<span class="built_in">ipv4_numeric</span>());</span><br><span class="line">  <span class="keyword">if</span>(mac_address!=arp_map_.<span class="built_in">end</span>())&#123;</span><br><span class="line">    <span class="comment">// cout&lt;&lt;&quot;目的地已知&quot;&lt;&lt;endl;</span></span><br><span class="line">    ethernet_header_.dst=mac_address-&gt;second.macAddress;</span><br><span class="line">    ethernet_header_.src=ethernet_address_;</span><br><span class="line">    ethernet_header_.type=ethernet_header_.TYPE_IPv4;</span><br><span class="line">    ethernet_Frame_.header=ethernet_header_;</span><br><span class="line">    ethernet_Frame_.payload=<span class="built_in">serialize</span>(dgram);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//目的地未知,发送ARP帧来取得对应的ip地址与mac映射</span></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// cout&lt;&lt;&quot;目的地未知&quot;&lt;&lt;endl;</span></span><br><span class="line">  <span class="comment">//判断是否需要发送（是否找得到记录）</span></span><br><span class="line">  <span class="keyword">if</span>(ethernet_frame_ARPMessage_map_.<span class="built_in">find</span>(next_hop.<span class="built_in">ipv4_numeric</span>())!=</span><br><span class="line">  ethernet_frame_ARPMessage_map_.<span class="built_in">end</span>())&#123;</span><br><span class="line">  <span class="comment">// cout&lt;&lt;&quot;ARP请求缓冲中&quot;&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// cout&lt;&lt;&quot;执行ARP请求&quot;&lt;&lt;endl;</span></span><br><span class="line">  ARPMessage new_arp_msg;</span><br><span class="line">  <span class="comment">//设置状态码为请求</span></span><br><span class="line">  new_arp_msg.opcode=ARPMessage::OPCODE_REQUEST;</span><br><span class="line">  new_arp_msg.sender_ethernet_address=ethernet_address_;</span><br><span class="line">  new_arp_msg.sender_ip_address=ip_address_.<span class="built_in">ipv4_numeric</span>();</span><br><span class="line">  <span class="comment">//将发送地址设置成广播地址，但是此处出现了地址错误，说明广播地址是只在以太网帧当中的</span></span><br><span class="line">  new_arp_msg.target_ip_address=next_hop.<span class="built_in">ipv4_numeric</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//添加以太网头部信息</span></span><br><span class="line">  ethernet_header_.dst=ETHERNET_BROADCAST;</span><br><span class="line">  ethernet_header_.src=ethernet_address_;</span><br><span class="line">  ethernet_header_.type=ethernet_header_.TYPE_ARP;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//封装以太网帧</span></span><br><span class="line">  ethernet_Frame_.header=ethernet_header_;</span><br><span class="line">  ethernet_Frame_.payload= std::<span class="built_in">move</span>( <span class="built_in">serialize</span>( new_arp_msg ) );</span><br><span class="line">  <span class="comment">//放入arp网络优化表，起始行时间是5000ms</span></span><br><span class="line">  ethernet_frame_ARPMessage_map_[next_hop.<span class="built_in">ipv4_numeric</span>()]=<span class="number">5000</span>;</span><br><span class="line">  <span class="comment">//那么这次是数据也要保存的，因为有可能不知道mac地址，但是仍然存在想要发送消息的愿望</span></span><br><span class="line">  InternetDatagram_buffer[next_hop.<span class="built_in">ipv4_numeric</span>()].<span class="built_in">push_back</span>(dgram);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//存入到以太网的处理队列之中</span></span><br><span class="line">  ethernet_frame_buffer_deque.<span class="built_in">push_back</span>(ethernet_Frame_);</span><br><span class="line">  (<span class="type">void</span>)dgram;</span><br><span class="line">  (<span class="type">void</span>)next_hop;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// frame: the incoming Ethernet frame</span></span><br><span class="line"><span class="comment">// frame: 进来的以太网帧</span></span><br><span class="line"><span class="function">optional&lt;InternetDatagram&gt; <span class="title">NetworkInterface::recv_frame</span><span class="params">( <span class="type">const</span> EthernetFrame&amp; frame )</span></span>&#123;</span><br><span class="line">  <span class="comment">//判断如果mac不是广播或者本地的就直接返回(不是给你的信息)</span></span><br><span class="line">  <span class="keyword">if</span>(frame.header.dst!=ethernet_address_&amp;&amp;frame.header.dst!=ETHERNET_BROADCAST)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullopt</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// cout&lt;&lt;&quot;----------------NetworkInterface::recv_frame-----------------&quot;&lt;&lt;endl;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//传入的是IPV4包</span></span><br><span class="line">  InternetDatagram internet_datagram;</span><br><span class="line">  <span class="keyword">if</span>(frame.header.type==EthernetHeader::TYPE_IPv4)&#123;</span><br><span class="line">    <span class="comment">// cout&lt;&lt;&quot;----------------EthernetHeader::TYPE_IPv4-----------------&quot;&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">parse</span>(internet_datagram,frame.payload))&#123;</span><br><span class="line">      <span class="keyword">return</span> internet_datagram;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullopt</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//传入的是ARP帧</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(frame.header.type==EthernetHeader::TYPE_ARP)&#123;</span><br><span class="line">    ARPMessage arp_msg;</span><br><span class="line">    <span class="type">bool</span> is_effective_arp=<span class="built_in">parse</span>(arp_msg,frame.payload);</span><br><span class="line">    <span class="comment">//需要去判断一下是不是要你发的arp包，即使是发给你的包也有可能是广播的形式，所以也就是要做到mac和ip的双重验证</span></span><br><span class="line">    <span class="keyword">if</span> ( arp_msg.target_ip_address != ip_address_.<span class="built_in">ipv4_numeric</span>() )&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullopt</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(is_effective_arp)&#123;</span><br><span class="line">      <span class="comment">//设置缓存</span></span><br><span class="line">      DeviceInfo device_info&#123;arp_msg.sender_ethernet_address,<span class="number">30000</span>&#125;;</span><br><span class="line">      <span class="comment">//如果有值直接覆盖，如果没有创建(更新)</span></span><br><span class="line">      arp_map_[arp_msg.sender_ip_address]=&#123;device_info&#125;;</span><br><span class="line">      <span class="comment">//应该回复什么？</span></span><br><span class="line">      <span class="comment">//如果是对方发的是ARP包,我们需要把之前未说的种种发送给对方</span></span><br><span class="line">      <span class="keyword">if</span>(arp_msg.opcode==ARPMessage::OPCODE_REPLY)&#123;</span><br><span class="line">        <span class="comment">//把之前没说过的话，都倾述出来</span></span><br><span class="line">        <span class="comment">//转换一下地址</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;正在发送未处理的数据包的循环前arp_msg.opcode:&quot;</span>&lt;&lt;arp_msg.opcode&lt;&lt;endl;</span><br><span class="line">        Address send_ip_address=Address::<span class="built_in">from_ipv4_numeric</span>(arp_msg.sender_ip_address);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;it : InternetDatagram_buffer[arp_msg.sender_ip_address])&#123;</span><br><span class="line">            <span class="built_in">send_datagram</span>(it,send_ip_address);</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;正在发送未处理的数据包的循环中,arp_msg.opcode:&quot;</span>&lt;&lt;arp_msg.opcode&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        InternetDatagram_buffer[arp_msg.sender_ip_address].<span class="built_in">clear</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//如果对方发的是请求，要我们回复arp包</span></span><br><span class="line">      <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//建立arp包</span></span><br><span class="line">       ARPMessage new_arp_msg;</span><br><span class="line">       <span class="comment">//建立包装</span></span><br><span class="line">       EthernetHeader ethernet_header_;</span><br><span class="line">       EthernetFrame ethernet_Frame_;</span><br><span class="line">       <span class="comment">//设置状态码为响应</span></span><br><span class="line">       new_arp_msg.opcode=ARPMessage::OPCODE_REPLY;</span><br><span class="line">       new_arp_msg.sender_ethernet_address=ethernet_address_;</span><br><span class="line">       new_arp_msg.sender_ip_address=ip_address_.<span class="built_in">ipv4_numeric</span>();<span class="comment">//这里只是处理了ipv4说明有可能出现ipv6需要过滤</span></span><br><span class="line">       <span class="comment">//交换源发送端mac和ip</span></span><br><span class="line">       new_arp_msg.target_ethernet_address=arp_msg.sender_ethernet_address;</span><br><span class="line">       new_arp_msg.target_ip_address=arp_msg.sender_ip_address;</span><br><span class="line">       ethernet_Frame_.payload=<span class="built_in">serialize</span>(new_arp_msg);</span><br><span class="line">       <span class="comment">//设置类型</span></span><br><span class="line">       ethernet_header_.type=ethernet_header_.TYPE_ARP;</span><br><span class="line">       <span class="comment">//目标地址和源地址交换</span></span><br><span class="line">       ethernet_header_.dst=frame.header.src;</span><br><span class="line">       ethernet_header_.src=ethernet_address_;</span><br><span class="line">       <span class="comment">//替换以太网头</span></span><br><span class="line">       ethernet_Frame_.header=ethernet_header_;</span><br><span class="line">       <span class="comment">//放入准备队列</span></span><br><span class="line">       ethernet_frame_buffer_deque.<span class="built_in">push_back</span>(ethernet_Frame_);     </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullopt</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  (<span class="type">void</span>)frame;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nullopt</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ms_since_last_tick: the number of milliseconds since the last call to this method</span></span><br><span class="line"><span class="comment">// ms_since_last_tick: 自上次调用此方法以来的毫秒数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">NetworkInterface::tick</span><span class="params">( <span class="type">const</span> <span class="type">size_t</span> ms_since_last_tick )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//更新映射，遍历一遍全部更新就是了</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> it = arp_map_.<span class="built_in">begin</span>(); it != arp_map_.<span class="built_in">end</span>(); ) &#123;</span><br><span class="line">    it-&gt;second.existenceTime=it-&gt;second.existenceTime&gt;ms_since_last_tick?</span><br><span class="line">    it-&gt;second.existenceTime-ms_since_last_tick:</span><br><span class="line">    <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (it-&gt;second.existenceTime==<span class="number">0</span>) &#123; </span><br><span class="line">        it = arp_map_.<span class="built_in">erase</span>(it); </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ++it; </span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="comment">//更新ARP请求时间</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> it =ethernet_frame_ARPMessage_map_.<span class="built_in">begin</span>(); it != ethernet_frame_ARPMessage_map_.<span class="built_in">end</span>(); ) &#123;</span><br><span class="line">    it-&gt;second=it-&gt;second&gt;ms_since_last_tick?</span><br><span class="line">    it-&gt;second-ms_since_last_tick:</span><br><span class="line">    <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (it-&gt;second==<span class="number">0</span>) &#123; </span><br><span class="line">        it = ethernet_frame_ARPMessage_map_.<span class="built_in">erase</span>(it); </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ++it; </span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  (<span class="type">void</span>)ms_since_last_tick;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">optional&lt;EthernetFrame&gt; <span class="title">NetworkInterface::maybe_send</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 按照我们实现的相应部分，这一部分的应该只返回一个消息即可</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="comment">//没准备好就发空的</span></span><br><span class="line"> <span class="keyword">if</span>(ethernet_frame_buffer_deque.<span class="built_in">empty</span>())&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullopt</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//准备好了就发过去</span></span><br><span class="line">  EthernetFrame frame=ethernet_frame_buffer_deque.<span class="built_in">front</span>();</span><br><span class="line">  ethernet_frame_buffer_deque.<span class="built_in">pop_front</span>();</span><br><span class="line">  <span class="keyword">return</span> frame;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p></div><div class="tab-item-content" id="test1-3"><p><strong>network_interface.hh</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;address.hh&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ethernet_frame.hh&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ipv4_datagram.hh&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;optional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个结构体来存储MAC地址和存在时间</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DeviceInfo</span> &#123;</span><br><span class="line">    EthernetAddress macAddress;</span><br><span class="line">    <span class="type">uint64_t</span> existenceTime; <span class="comment">// 存在时间，ms为单位</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">send_ARPMessages</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">uint32_t</span> ip_ipv4;</span><br><span class="line">  <span class="type">uint64_t</span> existenceTime;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A &quot;network interface&quot; that connects IP (the internet layer, or network layer)</span></span><br><span class="line"><span class="comment">// with Ethernet (the network access layer, or link layer).</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// This module is the lowest layer of a TCP/IP stack</span></span><br><span class="line"><span class="comment">// (connecting IP with the lower-layer network protocol,</span></span><br><span class="line"><span class="comment">// e.g. Ethernet). But the same module is also used repeatedly</span></span><br><span class="line"><span class="comment">// as part of a router: a router generally has many network</span></span><br><span class="line"><span class="comment">// interfaces, and the router&#x27;s job is to route Internet datagrams</span></span><br><span class="line"><span class="comment">// between the different interfaces.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The network interface translates datagrams (coming from the</span></span><br><span class="line"><span class="comment">// &quot;customer,&quot; e.g. a TCP/IP stack or router) into Ethernet</span></span><br><span class="line"><span class="comment">// frames. To fill in the Ethernet destination address, it looks up</span></span><br><span class="line"><span class="comment">// the Ethernet address of the next IP hop of each datagram, making</span></span><br><span class="line"><span class="comment">// requests with the [Address Resolution Protocol](\ref rfc::rfc826).</span></span><br><span class="line"><span class="comment">// In the opposite direction, the network interface accepts Ethernet</span></span><br><span class="line"><span class="comment">// frames, checks if they are intended for it, and if so, processes</span></span><br><span class="line"><span class="comment">// the the payload depending on its type. If it&#x27;s an IPv4 datagram,</span></span><br><span class="line"><span class="comment">// the network interface passes it up the stack. If it&#x27;s an ARP</span></span><br><span class="line"><span class="comment">// request or reply, the network interface processes the frame</span></span><br><span class="line"><span class="comment">// and learns or replies as necessary.</span></span><br><span class="line"><span class="comment">// “网络接口”连接IP（互联网层或网络层）</span></span><br><span class="line"><span class="comment">// 与以太网（网络接入层或链路层）。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个模块是TCP/IP协议栈的最底层</span></span><br><span class="line"><span class="comment">// （将IP与下层网络协议，例如以太网连接起来）。但是，相同的模块也会在路由器中重复使用：</span></span><br><span class="line"><span class="comment">// 一个路由器通常有多个网络接口，路由器的工作是在不同接口之间路由互联网数据报。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 网络接口将数据报（来自“客户”，例如TCP/IP协议栈或路由器）转换为以太网帧。</span></span><br><span class="line"><span class="comment">// 为了填写以太网目的地址，它会查找每个数据报的下一个IP跳转的以太网地址，</span></span><br><span class="line"><span class="comment">// 使用[地址解析协议](\ref rfc::rfc826)进行请求。</span></span><br><span class="line"><span class="comment">// 在相反的方向上，网络接口接受以太网帧，检查它们是否是为它所设计的，如果是的话，</span></span><br><span class="line"><span class="comment">// 根据其类型处理负载。如果是IPv4数据报，</span></span><br><span class="line"><span class="comment">// 网络接口会将其向上传递。如果是ARP请求或回复，</span></span><br><span class="line"><span class="comment">// 网络接口会处理帧并学习或必要时回复。</span></span><br><span class="line"><span class="comment">// 定义一个结构体来存储MAC地址和存在时间</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NetworkInterface</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// Ethernet (known as hardware, network-access, or link-layer) address of the interface</span></span><br><span class="line">  <span class="comment">// 以太网（又称硬件、网络接入层或链路层）接口的地址mac地址</span></span><br><span class="line">  EthernetAddress ethernet_address_;</span><br><span class="line">  <span class="comment">// IP (known as Internet-layer or network-layer) address of the interface</span></span><br><span class="line">  <span class="comment">// IP（又称互联网层或网络层）接口的地址</span></span><br><span class="line">  Address ip_address_;</span><br><span class="line">  <span class="comment">// uint64_t NI_cur_time_;//当前的接口时间</span></span><br><span class="line">  <span class="comment">// uint64_t NI_pre_time_;//之前的接口时间</span></span><br><span class="line">  <span class="type">uint64_t</span> max_arp_map_existenceTime_=<span class="number">30000</span>;<span class="comment">//30秒的最大时间映射</span></span><br><span class="line">  std::unordered_map&lt;<span class="type">uint32_t</span>, DeviceInfo&gt; arp_map_&#123;&#125;; <span class="comment">// ARP映射表，键为IP地址字符串</span></span><br><span class="line">  std::unordered_map&lt;<span class="type">uint32_t</span>,<span class="type">uint64_t</span>&gt; ethernet_frame_ARPMessage_map_&#123;&#125;;<span class="comment">//缓解网络堵塞，减少arp风暴</span></span><br><span class="line">  std::deque&lt;EthernetFrame&gt; ethernet_frame_buffer_deque&#123;&#125;;<span class="comment">//以太网队列</span></span><br><span class="line">  std::unordered_map&lt;<span class="type">uint32_t</span>,std::list&lt;InternetDatagram&gt;&gt; InternetDatagram_buffer&#123;&#125;;<span class="comment">//缓存期待发送的消息</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Construct a network interface with given Ethernet (network-access-layer) and IP (internet-layer)</span></span><br><span class="line">  <span class="comment">// addresses</span></span><br><span class="line">  <span class="comment">// 使用给定的以太网（网络接入层）和IP（互联网层）地址构造一个网络接口</span></span><br><span class="line">  <span class="built_in">NetworkInterface</span>( <span class="type">const</span> EthernetAddress&amp; ethernet_address, <span class="type">const</span> Address&amp; ip_address );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Access queue of Ethernet frames awaiting transmission</span></span><br><span class="line">  <span class="comment">// 访问等待传输的以太网帧队列</span></span><br><span class="line">  <span class="function">std::optional&lt;EthernetFrame&gt; <span class="title">maybe_send</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Sends an IPv4 datagram, encapsulated in an Ethernet frame (if it knows the Ethernet destination</span></span><br><span class="line">  <span class="comment">// address). Will need to use [ARP](\ref rfc::rfc826) to look up the Ethernet destination address</span></span><br><span class="line">  <span class="comment">// for the next hop.</span></span><br><span class="line">  <span class="comment">// (&quot;Sending&quot; is accomplished by making sure maybe_send() will release the frame when next called,</span></span><br><span class="line">  <span class="comment">// but please consider the frame sent as soon as it is generated.)</span></span><br><span class="line">  <span class="comment">// 发送一个IPv4数据报，封装在一个以太网帧中（如果它知道以太网目的地址）。</span></span><br><span class="line">  <span class="comment">// 将需要使用[ARP](\ref rfc::rfc826)来查找下一个跳转的以太网目的地址。</span></span><br><span class="line">  <span class="comment">// （“发送”是通过确保maybe_send()在下次调用时会释放帧来完成的，</span></span><br><span class="line">  <span class="comment">// 但请考虑一旦帧生成就认为它已经发送。）</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">send_datagram</span><span class="params">( <span class="type">const</span> InternetDatagram&amp; dgram, <span class="type">const</span> Address&amp; next_hop )</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Receives an Ethernet frame and responds appropriately.</span></span><br><span class="line">  <span class="comment">// If type is IPv4, returns the datagram.</span></span><br><span class="line">  <span class="comment">// If type is ARP request, learn a mapping from the &quot;sender&quot; fields, and send an ARP reply.</span></span><br><span class="line">  <span class="comment">// If type is ARP reply, learn a mapping from the &quot;sender&quot; fields.</span></span><br><span class="line">  <span class="comment">// 接收一个以太网帧并作出适当响应。</span></span><br><span class="line">  <span class="comment">// 如果类型是IPv4，返回数据报。</span></span><br><span class="line">  <span class="comment">// 如果类型是ARP请求，从“发送者”字段学习映射，并发送一个ARP回复。</span></span><br><span class="line">  <span class="comment">// 如果类型是ARP回复，从“发送者”字段学习映射。</span></span><br><span class="line">  <span class="function">std::optional&lt;InternetDatagram&gt; <span class="title">recv_frame</span><span class="params">( <span class="type">const</span> EthernetFrame&amp; frame )</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Called periodically when time elapses</span></span><br><span class="line">  <span class="comment">// 定期调用，当时间流逝时</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">tick</span><span class="params">( <span class="type">size_t</span> ms_since_last_tick )</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CS144 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS144-3</title>
      <link href="/posts/3d0542b6.html"/>
      <url>/posts/3d0542b6.html</url>
      
        <content type="html"><![CDATA[<h1 id="CS144-3"><a href="#CS144-3" class="headerlink" title="CS144-3"></a>CS144-3</h1><div class="tabs" id="test1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="test1-1">test1 1</button></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p>如果已经通过了lab2的测试，就可以开始lab3</p><p><div class="img-wrap"><div class="img-bg"><img class="img" src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/屏幕截图-2023-12-05-142751.png"/></div>&lt;/div&gt;<br>然后就可以开始同步实验文件了<code>cmake --build build --target check 3</code></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div class="tabs" id="test1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="test1-1">test1 1</button></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>实验开始</strong><br>这次需要实现的其实也就四个函数，其他函数只需要调用头文件中维护的变量</p><p><div class="img-wrap"><div class="img-bg"><img class="img" src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/屏幕截图 2023-12-15 233227.png"/></div>&lt;/div&gt;<br>我当时卡在不知道tick要如何实现，不让调用系统时间，只通过传参要怎么实现，说到底还是不了解这个传参的作用，其实每一次该函数被调用结束，都会重置为0，换一句话说，就是调用到第二次调用所经历的时间间隔就是传参的值，相当于一个随机的数，你需要的就是处理这个传参。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div class="tabs" id="test1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="test1-1">test1 1</button><button type="button" class="tab " data-href="test1-2">test1 2</button><button type="button" class="tab " data-href="test1-3">test1 3</button></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>代码实现</strong><br>接下来我讲讲我的实现思路，想自己思考的可以去实验了。</p><p>整体上，需要找到一个数据结构来存放我们的数据，我这里使用的是deque，因为数据的增删频繁，用queque也可以，但是实现起来复杂，没有必要。</p><p>我们创建两存储，一个是已经发送的但是未确认的，一个是准备发送的报文段。push函数用来把需要发送的报文段放入准备发送的deque类型存储，receive函数用来改变已经发送但未确认的deque类存储。时钟的开关用一个变量来维护，当发送出去后就开启时钟，如果当前发送但未确认的deque类存储中没有元素那么表明这个阶段的所有数据均发送过去，可以重置有关时钟的参数，如RTO。具体可以看我的代码和代码中的注释。</p></div><div class="tab-item-content" id="test1-2"><p><strong>TCP_sender.cc</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tcp_sender.hh&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tcp_config.hh&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* TCPSender constructor (uses a random ISN if none given) */</span></span><br><span class="line">TCPSender::<span class="built_in">TCPSender</span>( <span class="type">uint64_t</span> initial_RTO_ms, optional&lt;Wrap32&gt; fixed_isn )</span><br><span class="line">  : <span class="built_in">isn_</span>( fixed_isn.<span class="built_in">value_or</span>( Wrap32 &#123; <span class="built_in">random_device</span>()() &#125; ) ), <span class="built_in">initial_RTO_ms_</span>( initial_RTO_ms )</span><br><span class="line">  ,<span class="built_in">RTO_ms_</span>( initial_RTO_ms )</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="comment">//返回当前在传输中的序列号数量，也就是已经发送但还未收到确认的数据包数量。</span></span><br><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">TCPSender::sequence_numbers_in_flight</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> abs_seqno-por_abs_ackno;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回连续重传的次数，即同一数据包被重传的次数。</span></span><br><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">TCPSender::consecutive_retransmissions</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// Your code here.</span></span><br><span class="line">  <span class="keyword">return</span> retransmissions;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//该方法尝试发送</span></span><br><span class="line"><span class="function">optional&lt;TCPSenderMessage&gt; <span class="title">TCPSender::maybe_send</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// Your code here.</span></span><br><span class="line">  <span class="comment">//是否没有准备</span></span><br><span class="line">  <span class="keyword">if</span>(_ready_collections.<span class="built_in">empty</span>())&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullopt</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//如果准备了的话</span></span><br><span class="line">  TCPSenderMessage maybe_send_Message;</span><br><span class="line">  maybe_send_Message=_ready_collections.<span class="built_in">front</span>();</span><br><span class="line">  <span class="comment">//缓存数据(空包不要缓存)</span></span><br><span class="line">  <span class="keyword">if</span>(maybe_send_Message.<span class="built_in">sequence_length</span>()==<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> maybe_send_Message;</span><br><span class="line">  &#125;</span><br><span class="line">  _outstanding_collections.<span class="built_in">push_back</span>(maybe_send_Message);</span><br><span class="line">  _ready_collections.<span class="built_in">pop_front</span>();</span><br><span class="line">  <span class="comment">//让时钟启动</span></span><br><span class="line">  tick_start=<span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> maybe_send_Message;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//该方法初定为去放数据</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPSender::push</span><span class="params">( Reader&amp; outbound_stream )</span></span></span><br><span class="line"><span class="function"></span>&#123;    <span class="comment">// Your code here.</span></span><br><span class="line"><span class="comment">//循环去处理每一个数据，保证其空间可以放入数据即可</span></span><br><span class="line"><span class="comment">//假设看看剩余空间是否仍然有空余（sequence_numbers_in_flight() 的最大值就是 window_size）不会产生uint64_t回滚</span></span><br><span class="line">  <span class="type">uint64_t</span> available_window_space =<span class="built_in">max</span>(<span class="built_in">static_cast</span>&lt;<span class="type">uint64_t</span>&gt;(<span class="number">1</span>), window_size)-<span class="built_in">sequence_numbers_in_flight</span>();</span><br><span class="line">  <span class="comment">//用于测试</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span> (available_window_space&gt;<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// cout &lt;&lt;n&lt;&lt; &quot;available_window_space1:&quot;&lt;&lt;available_window_space&lt;&lt;&quot;,&quot;&lt;&lt;endl;</span></span><br><span class="line">    <span class="comment">//建立一个默认的消息，范围在0到MAX_PAYLOAD_SIZE</span></span><br><span class="line">    TCPSenderMessage NewMessages;</span><br><span class="line">    <span class="type">size_t</span> NewMessages_length=(<span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(available_window_space))&gt;=TCPConfig::MAX_PAYLOAD_SIZE?</span><br><span class="line">    TCPConfig::MAX_PAYLOAD_SIZE:(<span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(available_window_space));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">read</span>(outbound_stream,NewMessages_length,NewMessages.payload);</span><br><span class="line">    available_window_space-=NewMessages.payload.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">//是否需要SYN包装</span></span><br><span class="line">    <span class="keyword">if</span>(!has_SYN)&#123;</span><br><span class="line">      has_SYN=<span class="literal">true</span>;</span><br><span class="line">      NewMessages.SYN=<span class="literal">true</span>;</span><br><span class="line">      NewMessages.seqno=isn_;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">       NewMessages.seqno = Wrap32::<span class="built_in">wrap</span>( abs_seqno, isn_ );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//是否需要FIN包装</span></span><br><span class="line">    <span class="keyword">if</span>(!has_FIN&amp;&amp;outbound_stream.<span class="built_in">is_finished</span>()&amp;&amp;available_window_space&gt;<span class="number">0</span>)&#123;</span><br><span class="line">      has_FIN=<span class="literal">true</span>;</span><br><span class="line">      NewMessages.FIN=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//是否可以退出（只有当空间不足够以及到结尾以后才会产生空包）</span></span><br><span class="line">    <span class="keyword">if</span>(!NewMessages.SYN&amp;&amp;!NewMessages.FIN&amp;&amp;NewMessages.payload.<span class="built_in">size</span>()==<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//用于测试</span></span><br><span class="line">    <span class="comment">// n++;</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt;n&lt;&lt; &quot;psuh:&quot;&lt;&lt;has_SYN&lt;&lt;&quot;,&quot;&lt;&lt;endl;</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt;n&lt;&lt; &quot;available_window_space2:&quot;&lt;&lt;available_window_space&lt;&lt;&quot;,&quot;&lt;&lt;endl;</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt;n&lt;&lt; &quot;window_size:&quot;&lt;&lt;window_size&lt;&lt;&quot;,&quot;&lt;&lt;endl;</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt;n&lt;&lt; &quot;sequence_numbers_in_flight():&quot;&lt;&lt;sequence_numbers_in_flight()&lt;&lt;&quot;,&quot;&lt;&lt;endl;</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt;n&lt;&lt; &quot;NewMessages.sequence_length():&quot;&lt;&lt;NewMessages.sequence_length()&lt;&lt;&quot;,&quot;&lt;&lt;endl;</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt;n&lt;&lt; &quot;abs_seqno:&quot;&lt;&lt;abs_seqno&lt;&lt;&quot;,&quot;&lt;&lt;endl;</span></span><br><span class="line">    <span class="comment">//均可以放入</span></span><br><span class="line">    <span class="comment">//更新下次的位置</span></span><br><span class="line">    _ready_collections.<span class="built_in">push_back</span>(NewMessages);</span><br><span class="line">    abs_seqno += NewMessages.<span class="built_in">sequence_length</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// //当对方没有空间的时候，我们仍然假设他有一个，让他更新窗口</span></span><br><span class="line">  <span class="comment">// uint16_t window_size=new_win_r-new_win_l; //获取窗口的大小</span></span><br><span class="line">  <span class="comment">// if(window_size==0)&#123;</span></span><br><span class="line">  <span class="comment">// _ready_collections.push_back( send_empty_message());</span></span><br><span class="line">  <span class="comment">// return;</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">  <span class="comment">// //保证已经建立好传输</span></span><br><span class="line">  <span class="comment">// if(has_SYN)&#123;</span></span><br><span class="line">  <span class="comment">//   //生成尽可能多的TCPSenderMessage</span></span><br><span class="line">  <span class="comment">//   while(window_size!=0)&#123;</span></span><br><span class="line">  <span class="comment">//     TCPSenderMessage NewMessages;</span></span><br><span class="line">  <span class="comment">//     uint16_t NewMessages_length=window_size&gt;=</span></span><br><span class="line">  <span class="comment">//     TCPConfig::MAX_PAYLOAD_SIZE?</span></span><br><span class="line">  <span class="comment">//     TCPConfig::MAX_PAYLOAD_SIZE:window_size;</span></span><br><span class="line">  <span class="comment">//     window_size-=NewMessages_length;</span></span><br><span class="line">  <span class="comment">//     //如果是最后一段，那么我们就标识FIN包</span></span><br><span class="line">  <span class="comment">//     if(outbound_stream.is_finished())&#123;</span></span><br><span class="line">  <span class="comment">//       NewMessages.FIN=true;</span></span><br><span class="line">  <span class="comment">//     &#125;</span></span><br><span class="line">  <span class="comment">//     //只给我看我怎么构建信息啊，我直接引用？</span></span><br><span class="line">  <span class="comment">//     NewMessages.payload&#123;&amp;outbound_stream.peek()&#125;;</span></span><br><span class="line">  <span class="comment">//     outbound_stream.pop(NewMessages_length);</span></span><br><span class="line">  <span class="comment">//     NewMessages.seqno=temp.wrap( outbound_stream.bytes_popped() + 1 + outbound_stream.is_finished(), zero_point );</span></span><br><span class="line">  <span class="comment">//     total__ready_collections_length=NewMessages.seqno;</span></span><br><span class="line">  <span class="comment">//     _ready_collections.push_back(NewMessages);</span></span><br><span class="line">  <span class="comment">//   &#125;;</span></span><br><span class="line">  <span class="comment">// &#125;else&#123;</span></span><br><span class="line">  <span class="comment">//   //如果没有建立连接就先发出SYN包</span></span><br><span class="line">  <span class="comment">//   TCPSenderMessage Message_SYN;</span></span><br><span class="line">  <span class="comment">//   Message_SYN.SYN=true;</span></span><br><span class="line">  <span class="comment">//   Message_SYN.seqno=isn_;</span></span><br><span class="line">  <span class="comment">//   zero_point=isn.raw_value_;</span></span><br><span class="line">  <span class="comment">//   _ready_collections.push_back(Message_SYN);</span></span><br><span class="line">  <span class="comment">//   has_SYN=true;</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">  (<span class="type">void</span>)outbound_stream;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//该方法初定为发送空数据</span></span><br><span class="line"><span class="function">TCPSenderMessage <span class="title">TCPSender::send_empty_message</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// Your code here.</span></span><br><span class="line">  <span class="comment">//首先是定义一段空数据</span></span><br><span class="line">  <span class="keyword">return</span> TCPSenderMessage&#123;Wrap32::<span class="built_in">wrap</span>(abs_seqno, isn_ ), <span class="literal">false</span>, <span class="built_in">Buffer</span>(), <span class="literal">false</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//该方法设置窗口大小，同时删除无用段</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPSender::receive</span><span class="params">( <span class="type">const</span> TCPReceiverMessage&amp; msg )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// Your code here.</span></span><br><span class="line">  <span class="comment">//获得窗口左和窗口右(由于窗口大小是uint16MAX所以设置为uint16MAX)</span></span><br><span class="line">  window_size=msg.window_size;</span><br><span class="line">  <span class="comment">//获得abs_ackno</span></span><br><span class="line">  <span class="keyword">if</span>(msg.ackno.<span class="built_in">has_value</span>())&#123;</span><br><span class="line">    abs_ackno=msg.ackno.<span class="built_in">value</span>().<span class="built_in">unwrap</span>( isn_, por_abs_ackno );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//确认新的确认码的有效性</span></span><br><span class="line">  <span class="keyword">if</span>(!msg.ackno.<span class="built_in">has_value</span>()||abs_ackno&gt;abs_seqno||abs_ackno&lt;por_abs_ackno)&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 删除已经确认的段</span></span><br><span class="line">  <span class="keyword">while</span> (!_outstanding_collections.<span class="built_in">empty</span>() ) &#123;</span><br><span class="line">    <span class="keyword">if</span>( _outstanding_collections.<span class="built_in">front</span>().seqno.<span class="built_in">unwrap</span>(isn_,abs_ackno) +_outstanding_collections.<span class="built_in">front</span>().<span class="built_in">sequence_length</span>() - <span class="number">1</span> &gt;= abs_ackno)&#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _outstanding_collections.<span class="built_in">pop_front</span>();</span><br><span class="line">    <span class="comment">// RTO设置</span></span><br><span class="line">    cur_time = <span class="number">0</span>;</span><br><span class="line">    RTO_ms_ = initial_RTO_ms_;</span><br><span class="line">    retransmissions = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; &quot;receive&quot;&lt;&lt;RTO_ms_&lt;&lt;endl;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//设置时钟关闭</span></span><br><span class="line">  <span class="keyword">if</span>(_outstanding_collections.<span class="built_in">empty</span>())&#123;</span><br><span class="line">    tick_start=<span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//更新确认</span></span><br><span class="line">  por_abs_ackno=abs_ackno;</span><br><span class="line">  (<span class="type">void</span>)msg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该段设置为更新时间</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPSender::tick</span><span class="params">( <span class="type">const</span> <span class="type">size_t</span> ms_since_last_tick )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// Your code here.</span></span><br><span class="line">  <span class="comment">//是否建立启动了时钟,是否建立了连接</span></span><br><span class="line">  <span class="keyword">if</span>(!tick_start||!has_SYN)&#123;</span><br><span class="line">    <span class="comment">// cout &lt;&lt;n&lt;&lt; &quot;是否建立启动了时钟,是否建立了连接&quot;&lt;&lt;&quot;tick_start:&quot;&lt;&lt;tick_start&lt;&lt;&quot;,&quot;&lt;&lt;&quot;has_SYN:&quot;&lt;&lt;has_SYN&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// //测试temp</span></span><br><span class="line">  <span class="comment">// uint64_t temp=cur_time;</span></span><br><span class="line">  cur_time+=ms_since_last_tick;</span><br><span class="line">  <span class="comment">// cout &lt;&lt;n&lt;&lt; &quot;赋值时的时间&quot;&lt;&lt;&quot;cur_time:&quot;&lt;&lt;temp&lt;&lt;&quot;,&quot;&lt;&lt;&quot;ms_since_last_tick:&quot;&lt;&lt;cur_time-temp&lt;&lt;endl;</span></span><br><span class="line">  <span class="comment">//是没有超时的话返回</span></span><br><span class="line">  <span class="keyword">if</span>(cur_time&lt;RTO_ms_)&#123;</span><br><span class="line">    <span class="comment">// cout &lt;&lt;n&lt;&lt; &quot;是没有超时的话返回&quot;&lt;&lt;&quot;cur_time:&quot;&lt;&lt;cur_time&lt;&lt;&quot;,&quot;&lt;&lt;&quot;RTO_ms_:&quot;&lt;&lt;RTO_ms_&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//RTO退避</span></span><br><span class="line">  <span class="keyword">if</span>((window_size)&gt;<span class="number">0</span>)&#123;</span><br><span class="line">    RTO_ms_*=<span class="number">2</span>;</span><br><span class="line">    <span class="comment">//  cout &lt;&lt;n&lt;&lt; &quot;RTO退避&quot;&lt;&lt;&quot;RTO_ms_:&quot;&lt;&lt;RTO_ms_&lt;&lt;&quot;,&quot;&lt;&lt;&quot;window_size:&quot;&lt;&lt;window_size&lt;&lt;endl;</span></span><br><span class="line">  &#125;<span class="comment">//从新放到我们准备发送的deque</span></span><br><span class="line">  <span class="keyword">if</span>(!_outstanding_collections.<span class="built_in">empty</span>())&#123;</span><br><span class="line">    _ready_collections.<span class="built_in">push_front</span>(_outstanding_collections.<span class="built_in">front</span>());</span><br><span class="line">    retransmissions++;</span><br><span class="line">    cur_time=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//  cout &lt;&lt;n&lt;&lt; &quot;从新放到我们准备发送的deque&quot;&lt;&lt;&quot;cur_time:&quot;&lt;&lt;cur_time&lt;&lt;&quot;,&quot;&lt;&lt;&quot;retransmissions:&quot;&lt;&lt;retransmissions&lt;&lt;endl;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// cout&lt;&lt;n&lt;&lt;&quot;最后的所有参数一览&quot;&lt;&lt;&quot;ms_since_last_tick&quot;&lt;&lt;ms_since_last_tick&lt;&lt;&quot;,&quot;</span></span><br><span class="line">  <span class="comment">// &lt;&lt;&quot;has_SYN:&quot;&lt;&lt;has_SYN&lt;&lt;&quot;,&quot;</span></span><br><span class="line">  <span class="comment">// &lt;&lt;&quot;tick_start:&quot;&lt;&lt;tick_start&lt;&lt;&quot;,&quot;</span></span><br><span class="line">  <span class="comment">// &lt;&lt;&quot;cur_time:&quot;&lt;&lt;cur_time&lt;&lt;&quot;,&quot;</span></span><br><span class="line">  <span class="comment">// &lt;&lt;&quot;RTO_ms_:&quot;&lt;&lt;RTO_ms_&lt;&lt;&quot;,&quot;</span></span><br><span class="line">  <span class="comment">// &lt;&lt;&quot;retransmissions:&quot;&lt;&lt;retransmissions&lt;&lt;endl;</span></span><br><span class="line">  (<span class="type">void</span>)ms_since_last_tick;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p></div><div class="tab-item-content" id="test1-3"><p><strong>TCP_sender.hh</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;byte_stream.hh&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tcp_receiver_message.hh&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tcp_sender_message.hh&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TCPSender</span></span><br><span class="line">&#123;</span><br><span class="line">  Wrap32 isn_;</span><br><span class="line">  <span class="type">uint64_t</span> initial_RTO_ms_;</span><br><span class="line">  <span class="type">uint64_t</span> RTO_ms_;</span><br><span class="line">  <span class="type">uint64_t</span> window_size=<span class="number">1</span>;</span><br><span class="line">  <span class="type">uint64_t</span> cur_time=<span class="number">0</span>;<span class="comment">//这次的总毫秒数</span></span><br><span class="line">  <span class="type">uint64_t</span> abs_seqno=<span class="number">0</span>;<span class="comment">//记录下次的绝对位置</span></span><br><span class="line">  <span class="type">uint64_t</span> por_abs_ackno=<span class="number">0</span>;<span class="comment">//记录上次的绝对位置</span></span><br><span class="line">  <span class="type">uint64_t</span> abs_ackno=<span class="number">0</span>;<span class="comment">//记录下次的绝对位置</span></span><br><span class="line">  <span class="type">uint8_t</span> retransmissions=<span class="number">0</span>;<span class="comment">//记录重传次数</span></span><br><span class="line">  <span class="type">bool</span> tick_start=<span class="literal">false</span>;<span class="comment">//是否启动了时钟</span></span><br><span class="line">  <span class="type">bool</span> has_SYN=<span class="literal">false</span>;<span class="comment">//连接与否</span></span><br><span class="line">  <span class="type">bool</span> has_FIN=<span class="literal">false</span>;<span class="comment">//是否尝试断开</span></span><br><span class="line">  std::deque&lt;TCPSenderMessage&gt; _outstanding_collections=&#123;&#125;; <span class="comment">// 记录所有已发送未完成的段</span></span><br><span class="line">  std::deque&lt;TCPSenderMessage&gt; _ready_collections=&#123;&#125;;       <span class="comment">// 记录所有准备好发送的段</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">/* Construct TCP sender with given default Retransmission Timeout and possible ISN */</span></span><br><span class="line">   <span class="comment">/* 使用给定的默认重传超时和可能的ISN构造TCP发送者 */</span></span><br><span class="line">  <span class="built_in">TCPSender</span>( <span class="type">uint64_t</span> initial_RTO_ms, std::optional&lt;Wrap32&gt; fixed_isn );</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Push bytes from the outbound stream */</span></span><br><span class="line">  <span class="comment">/* 从出站流中推送字节 */</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">( Reader&amp; outbound_stream )</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Send a TCPSenderMessage if needed (or empty optional otherwise) */</span></span><br><span class="line">  <span class="comment">/* 如果需要发送TCPSenderMessage，则发送（否则返回空的optional） */</span></span><br><span class="line">  <span class="function">std::optional&lt;TCPSenderMessage&gt; <span class="title">maybe_send</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Generate an empty TCPSenderMessage */</span></span><br><span class="line">   <span class="comment">/* 生成一个空的TCPSenderMessage */</span></span><br><span class="line">  <span class="function">TCPSenderMessage <span class="title">send_empty_message</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Receive an act on a TCPReceiverMessage from the peer&#x27;s receiver */</span></span><br><span class="line">    <span class="comment">/* 接收并响应对端接收者的TCPReceiverMessage */</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">receive</span><span class="params">( <span class="type">const</span> TCPReceiverMessage&amp; msg )</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Time has passed by the given # of milliseconds since the last time the tick() method was called. */</span></span><br><span class="line">  <span class="comment">/* 自上次调用tick()方法以来，时间已经过去了给定的毫秒数 */</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">tick</span><span class="params">( <span class="type">uint64_t</span> ms_since_last_tick )</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Accessors for use in testing */</span></span><br><span class="line">    <span class="comment">/* 用于测试的访问器 */</span></span><br><span class="line">  <span class="function"><span class="type">uint64_t</span> <span class="title">sequence_numbers_in_flight</span><span class="params">()</span> <span class="type">const</span></span>;  <span class="comment">// How many sequence numbers are outstanding?// 有多少序列号正在传输中？</span></span><br><span class="line">  <span class="function"><span class="type">uint64_t</span> <span class="title">consecutive_retransmissions</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">// How many consecutive *re*transmissions have happened?// 发生了多少次连续的*重*传输？</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CS144 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS144-2</title>
      <link href="/posts/4a027220.html"/>
      <url>/posts/4a027220.html</url>
      
        <content type="html"><![CDATA[<h1 id="CS144-2"><a href="#CS144-2" class="headerlink" title="CS144-2"></a>CS144-2</h1><div class="tabs" id="test1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="test1-1">test1 1</button></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>检查</strong><br>在实验2之前，要保证之前的实验1已经通过测试<br><code>cmake --build build --target check 1</code>如果出现如下就可以继续实验了</p><div class="img-wrap"><div class="img-bg"><img class="img" src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/屏幕截图-2023-12-04-223142.png"/></div></div></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div class="tabs" id="test1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="test1-1">test1 1</button></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>获取实验文件</strong><br><code>git fetch</code>来检索实验分配的最新版本<br><code>git merge origin/check2-startercode</code>然后同步这次的实验代码<br>在这一部分中，你需要实现TCPReceiver，和一个wrapping_integers这是我们整个实验中的端口的服务端和绝对/相对序列号的转换<br>在这实验之前，你需要了解报文中的确认号（ackno），序列号（seqno）以及连接请求（SYN）和断开请求（FIN），了解这些就足以应对这个实验。<br>你需要知道的是以上四个量在传递过程中的值的变化，最好是自己尝试画出来</p><div class="img-wrap"><div class="img-bg"><img class="img" src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/屏幕截图-2023-12-05-125014-1024x678.png"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img" src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/屏幕截图-2023-1"/></div></div></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div class="tabs" id="test1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="test1-1">test1 1</button></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>实验开始</strong><br>首先这一部分难的地方并不在于去理解发送中的状态更新，而是在于如何在适当的时刻去利用相对位置和绝对位置这两个状态，而且要实现这两个转换个，如果在实现了转换的部分，同时如果这个在收发过程想明白，那么这个实验容易通过的。</p><p>首先你需要知道，当2的32次方超过就会溢出，如果是无符号型就会回滚到0，所以我们需要利用这一点，直接强转，让绝对位置变成相对位置。我当时对于unwrap的实现思路是算出有多少个循环（也就是2^32有多少个）然后把检查点左边的和右边的最近求出来，比较一下距离谁近就可以了。</p><p>关于这一部分，我之前的思路是直接用相对位置来比较检查点的距离，然后直接加上循环几圈，但是后面出现了端点是检查点的情况，以及端点是序列号的情况，这导致后面一直出现边界问题，所以倒不如直接求出来两个绝对位置，然后求他们到检查点的距离来得要巴适。</p><p>对于这一部分如果不清楚的话我们可以做一道题</p><p>时钟问题：一台机器每个一段时间都会记录累计的工作总小时数 m，每一个人只知道最后记得的工作时间在24刻度的时钟的 n 刻度上，小明现在只知道 n 和 m 如何求出总的工作实际数 g？</p><p>(m-n)%24就是求出从 n 到 m 有多少个完整的周期，然后 24 x (m-n)%24+n 就是最后的结果</p><p>换而 lab 2言之 (m-n)&gt;&gt;32&lt;&lt;32+n</p><p>这一部分可以琢磨一下，我当时琢磨了两天（泪目），当然实现起来还是以上的扩展版本，要多注意边界问题。</p><p>其次是你需要知道的结构体，第一个是TCP应答消息，第二个是TCP的发送消息</p><p>然后需要好好思考这些结构体的成员变量如何联系到本次实验的主题，以及如何在调用函数的时候用到他们，同时需要按F12去查看对应的成员变量类型是否有成员函数，清楚了这些函数作用可以极大减少代码量，这需要你自己去发现，因为这部分文档中也并没有直接给出来，估计故意是让大家思考的。</p><div class="img-wrap"><div class="img-bg"><img class="img" src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/屏幕截图-2023-12-04-225439.png"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img" src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/屏幕截图-2023-12-04-225641.png"/></div></div>清楚其结构才能明白如何调用函数头文件中的辅助函数。我实现的过程也是很曲折的，一步一步整理思路，然后去调用F12去看代码实现，具体的思路过程可以看我粘贴在文末的代码注释，在此之前建议自己思考，这个思考过程才是提升自己的最好方式。接下来我复制文档的一部分（偷个懒）在 64 位索引和 32 位 seqno 之间转换作为热身，我们需要实现 TCP 的索引表示方式。上周你创建了一个重组器，它重新组装子字符串，每个独立的字节有一个 64 位的流索引，流中的第一个字节的索引总是零。一个 64 位的索引足够大以至于我们可以把它当作永不溢出。2^64 是真的大然而，在 TCP 头中，空间是宝贵的，并且流中的每个字节的索引不是用 64 位索引表示，而是用 32 位的“序列号”，或者“seqno”表示。这添加了三个复杂点：- 1.你的实现需要计划 32 位整数的环绕。TCP 中的流可以任意长——TCP 可以发送的 ByteStream 的长度没有限制。但是 2^32 字节只有 4 GiB，这并不大。一旦一个 32 位序列号计数到 2^32 - 1，流中的下一个字节将有序列号零。- 2.TCP 序列号从一个随机值开始：为了避免对早先在同一端点之间的连接的旧段产生混乱，TCP 试图确保序列号不能被猜测并且不太可能重复。因此，一个流的序列号不会从零开始。流中的第一个序列号是一个被称为初始序列号（ISN）的随机 32 位数。这是表示“零点”或 SYN（流的开始）的序列号。其余的序列号在此后表现正常：数据的第一个字节将有 ISN+1（mod 2^32）的序列号，第二个字节将有 ISN+2（mod 2^32）的序列号，等等。- 3.逻辑开始和结束每个占用一个序列号：除了确保收到所有的数据字节，TCP 还确保字节流的开始和结束可靠地被接收。因此，在 TCP 中，SYN（stream-beginning）和 FIN（stream-ending）控制标志被分配序列号。每个序列号占用一个序列号。（SYN 标志占用的序列号是 ISN。）流中的每个数据字节也占用一个序列号。记住，SYN 和 FIN 并不是流本身的一部分，它们不是“字节”——他们表示字节流本身的开始和结束。<div class="img-wrap"><div class="img-bg"><img class="img" src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/屏幕截图-2023-12-04-231234-1024x432.png"/></div></div></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div class="tabs" id="test1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="test1-1">test1 1</button></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>tcp_receiver.cc</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tcp_receiver.hh&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPReceiver::receive</span><span class="params">( TCPSenderMessage message, Reassembler&amp; reassembler, Writer&amp; inbound_stream )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  需要使用到的有inser函数</span></span><br><span class="line"><span class="comment">  ：</span></span><br><span class="line"><span class="comment">  Reassembler::insert( uint64_t first_index, string data, bool is_last_substring, Writer&amp; output )</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  绝对序号，data，是不是最后一个数据包，output系统</span></span><br><span class="line"><span class="comment">  而output是一个Writer类型，需要外界提供，所以目光在inbound_stream</span></span><br><span class="line"><span class="comment">  message.payload是数据字段</span></span><br><span class="line"><span class="comment">  所以写出来应该是</span></span><br><span class="line"><span class="comment">  reassembler.insert(message.seqno,message.payload,message.FIN,inbound_stream)</span></span><br><span class="line"><span class="comment">  但是应该分别为连接请求和确认和中间段包，和挥手包四种可能</span></span><br><span class="line"><span class="comment">  而reassembler.insert(message.seqno,message.payload,message.FIN,inbound_stream)</span></span><br><span class="line"><span class="comment">  已经包涵了FIN包的处理，以及SYN包的空包处理，也就是说，需要关心的也就first_index这个接口</span></span><br><span class="line"><span class="comment">  当SYN=1时是SYN包，此时没有数据，且设定了初始的绝对位置,此时应该是不需要传递到insert中的</span></span><br><span class="line"><span class="comment">  当SYN=0时是中间段，此时的seqno就是我们的数据index</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//此处我不知道SYN如果多发了几次要怎么处理，然后还是不同的情况下，一般来说一个是再开一个线程</span></span><br><span class="line"><span class="comment">//如果此时我们的SYN包接受到，那么我们保存我们已经接受到SYN包,保存一下状态，以及初始的序列号</span></span><br><span class="line">  <span class="keyword">if</span>(message.SYN)&#123;</span><br><span class="line">    <span class="comment">//如果接收到了就保存这个状态</span></span><br><span class="line">    SYN_received=<span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//第一次开启的时候会记录一下零点的位置</span></span><br><span class="line">    zero_point=message.seqno;</span><br><span class="line">    FIN_received=message.FIN;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  abs_seq=message.seqno.<span class="built_in">unwrap</span>( zero_point, inbound_stream.<span class="built_in">bytes_pushed</span>() );</span><br><span class="line">  <span class="comment">//排除掉我们可能出现的SYN情况，FIN包他本身就可以处理</span></span><br><span class="line">  <span class="keyword">if</span>(SYN_received)&#123;</span><br><span class="line">    <span class="comment">//insert接受的是下一个abs_seq的下标，而abs_seq是依据当前流系统接收的包，拆包后的长度-1是因为只改变index后的数据，以及是否是SYN包是为了包涵当开头时，是0，没有向前的下标了</span></span><br><span class="line">    reassembler.<span class="built_in">insert</span>( abs_seq+ message.SYN - <span class="number">1</span>,message.payload,message.FIN,inbound_stream);</span><br><span class="line">    <span class="keyword">if</span>(FIN_received)&#123;</span><br><span class="line">      <span class="comment">//后面可以用作半退出状态去接收数据</span></span><br><span class="line">      half_close=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TCPReceiverMessage <span class="title">TCPReceiver::send</span><span class="params">( <span class="type">const</span> Writer&amp; inbound_stream )</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  这里就应该发送SYN包和ACK包，问题是要一起发送还是发送两次？</span></span><br><span class="line"><span class="comment">  看了一下结构体确实是需要发送两次,但是他返回的就一种，那算了，就返回ACK包就行了</span></span><br><span class="line"><span class="comment">  直接通过返回来返回给对方？</span></span><br><span class="line"><span class="comment">  窗户应该设置多大？</span></span><br><span class="line"><span class="comment">  那么我认为inbound_stream似乎没有什么用</span></span><br><span class="line"><span class="comment">  然而是用来获取检查点的</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">   <span class="comment">//由于我们一次连接只需要对SYN响应一次，所以我们响应过一次就设置为false防止误用，这条废除，因为后续连接需要保存syn</span></span><br><span class="line">  TCPReceiverMessage message_ACK;</span><br><span class="line">  <span class="comment">//SYN包：</span></span><br><span class="line">  <span class="type">uint64_t</span> res = inbound_stream.<span class="built_in">available_capacity</span>();</span><br><span class="line">  message_ACK.window_size = res &gt; UINT16_MAX ? UINT16_MAX : res;</span><br><span class="line">  <span class="keyword">if</span>(!SYN_received)&#123;</span><br><span class="line">    <span class="keyword">return</span> message_ACK;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//这一步网上看到的是用inbound_stream.bytes_pushed当做要装包的数据，我寻思难道不是seqno？</span></span><br><span class="line">  <span class="comment">//这是因为seq插入后，不一定是完全的包，我们会经历合并等等操作，最后返回的应该是我们接受到的有效长度，所以用的是inbound_stream.bytes_pushed()</span></span><br><span class="line">  <span class="comment">//+1是为了当有效长度的一个确认，然后是否是FIN包，我们也需要确认如果是最后一个包，我们分别需要对其seq确认，和FIN包确认，</span></span><br><span class="line">  <span class="comment">//正版的是分开两次确认不知道为什么这两必须是同时合并一步确认</span></span><br><span class="line">  message_ACK.ackno=temp.<span class="built_in">wrap</span>( inbound_stream.<span class="built_in">bytes_pushed</span>() + <span class="number">1</span> + inbound_stream.<span class="built_in">is_closed</span>(), zero_point );</span><br><span class="line">   <span class="keyword">return</span> message_ACK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><br><strong><em>tcp_receiver.hh</em></strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reassembler.hh&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tcp_receiver_message.hh&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tcp_sender_message.hh&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TCPReceiver</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">TCPReceiver</span>():<span class="built_in">SYN_received</span>(<span class="literal">false</span>),<span class="built_in">half_close</span>(<span class="literal">false</span>),<span class="built_in">FIN_received</span>(<span class="literal">false</span>),<span class="built_in">zero_point</span>(<span class="number">0</span>),<span class="built_in">temp</span>(<span class="number">0</span>),<span class="built_in">abs_seq</span>(<span class="number">0</span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">TCPReceiver接收TCPSenderMessages，将它们的有效载荷插入到正确的流索引的Reassembler中。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">receive</span><span class="params">( TCPSenderMessage message, Reassembler&amp; reassembler, Writer&amp; inbound_stream )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* TCPReceiver将TCPReceiverMessages发送回TCPSender。 */</span></span><br><span class="line">  <span class="function">TCPReceiverMessage <span class="title">send</span><span class="params">( <span class="type">const</span> Writer&amp; inbound_stream )</span> <span class="type">const</span></span>;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">//是不是正在连接中</span></span><br><span class="line">  <span class="type">bool</span> SYN_received;</span><br><span class="line">  <span class="comment">//是不是完成了半关闭</span></span><br><span class="line">  <span class="type">bool</span> half_close;</span><br><span class="line">  <span class="comment">//用来标记结束</span></span><br><span class="line">  <span class="type">bool</span> FIN_received;</span><br><span class="line">  <span class="comment">//为ack数做准备</span></span><br><span class="line">  <span class="comment">//初始的绝对长度</span></span><br><span class="line">  Wrap32 zero_point;</span><br><span class="line">  Wrap32 temp;</span><br><span class="line">  <span class="type">uint64_t</span> abs_seq;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p><div class="img-wrap"><div class="img-bg"><img class="img" src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/屏幕截图-2023-12-05-125922-1024x218.png"/></div>&lt;/div&gt;<br><strong><em>wrapping_integers.cc</em></strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;wrapping_integers.hh&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">Wrap32 <span class="title">Wrap32::wrap</span><span class="params">( <span class="type">uint64_t</span> n, Wrap32 zero_point )</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> Wrap32 &#123; zero_point + <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(n) &#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//zero_point 是uint32_t类型</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">Wrap32::unwrap</span><span class="params">( Wrap32 zero_point, <span class="type">uint64_t</span> checkpoint )</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//求出序列号的循环中的绝对位置</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span> abs_seqno = <span class="built_in">static_cast</span>&lt;<span class="type">uint64_t</span>&gt;( <span class="keyword">this</span>-&gt;raw_value_ - zero_point.raw_value_ );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (abs_seqno&gt;checkpoint)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> abs_seqno;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里checkpoint&gt;&gt;32求出的是检查点的2的32次倍数，而checkpoint-abs_seqno求出的是从序列号到checkpoint的距离的周期数，相当于把abs_seqno置原点，重新求周期，求一个，从而和检查点处于同一个周期内</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//其实最重要的是吧检查点和序号的周期全部拿走，让其余检查点共处一个相对周期</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span> cycle=((checkpoint-abs_seqno)&gt;&gt;<span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span> r=<span class="built_in">static_cast</span>&lt;<span class="type">uint64_t</span>&gt;((<span class="number">1ull</span>&lt;&lt;<span class="number">32</span>)*(cycle+<span class="number">1</span>)+abs_seqno);</span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span> l=<span class="built_in">static_cast</span>&lt;<span class="type">uint64_t</span>&gt;((<span class="number">1ull</span>&lt;&lt;<span class="number">32</span>)*cycle+abs_seqno);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(checkpoint-l&gt;r-checkpoint)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">但是只需要相对的位置就可以了，因为假设我们的周期只有一个，那么检查点的相对序列和当前相对序列的距离如果大于周期的一半，</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">说明checkpoint更加接近另一个循环的点，而我们求的是向下取整的cycle，</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">所以我们后续去加上cycle的时候，是在检查点左侧最近的位置，</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">而如果我们的序列号相对位置是大于周期一半的话，</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">由于题目是说要求检查点最近的点，</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">那么肯定就是在检查点右边最近的，</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">也就是我们当前的绝对序列号的下一个周期，</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">所以要进位</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">由于相对周期要判断的条件太多，还不如选择暴力的最后判断，况且性能还行，就不需要这样做了</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><br><strong><em>wrapping_integers.hh</em></strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdint&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Wrap32类型代表一个32位无符号整数，该整数：</span></span><br><span class="line"><span class="comment">从一个任意的&quot;零点&quot;（初始值）开始，并且</span></span><br><span class="line"><span class="comment">当达到2^32 - 1时，回到零。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Wrap32</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="type">uint32_t</span> raw_value_ &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Wrap32</span><span class="params">( <span class="type">uint32_t</span> raw_value )</span> : raw_value_( raw_value ) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 构造一个 Wrap32，给定一个绝对序列号 n 和零点。*/</span></span><br><span class="line">  <span class="function"><span class="type">static</span> Wrap32 <span class="title">wrap</span><span class="params">( <span class="type">uint64_t</span> n, Wrap32 zero_point )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">unwrap方法返回一个绝对序列号，该序列号将包装到这个Wrap32，给定零点</span></span><br><span class="line"><span class="comment">以及一个&quot;检查点&quot;：接近期望答案的另一个绝对序列号。</span></span><br><span class="line"><span class="comment">有许多可能的绝对序列号都包装到同一个Wrap32。</span></span><br><span class="line"><span class="comment">unwrap方法应该返回最接近检查点的那个。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">uint64_t</span> <span class="title">unwrap</span><span class="params">( Wrap32 zero_point, <span class="type">uint64_t</span> checkpoint )</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">  Wrap32 <span class="keyword">operator</span>+( <span class="type">uint32_t</span> n ) <span class="type">const</span> &#123; <span class="keyword">return</span> Wrap32 &#123; raw_value_ + n &#125;; &#125;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>==( <span class="type">const</span> Wrap32&amp; other ) <span class="type">const</span> &#123; <span class="keyword">return</span> raw_value_ == other.raw_value_; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CS144 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS144-1</title>
      <link href="/posts/d30b239a.html"/>
      <url>/posts/d30b239a.html</url>
      
        <content type="html"><![CDATA[<h1 id="CS144-1"><a href="#CS144-1" class="headerlink" title="CS144-1"></a>CS144-1</h1><div class="tabs" id="test1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="test1-1">test1 1</button></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>前言</strong><br><code>cmake --build build --target check 0</code>来检查你的lab0后就可以开始这部分的实验了<br>事实上对于这部分实验，在我整个实验中花费的时间是最长的，代码也是最长的，而且即使通过了，后续的实验中，也会由于这部分导致超时，而无法通过。所以参考了其他大佬的思路才通过了这部分的测试</p><p>这是我参考的大佬的链接，需要代码的可以去他那边看看<code>https://github.com/Mobuiss</code></p><p>目前大多数对于这一题的思路就是重复子串的合并，我一开始想到的也是用map来实现这个过程，但是后面写得也很长，性能很低。大佬的思路就不一样了，是用一个vector来维护buffer，下面详细讲。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div class="tabs" id="test1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="test1-1">test1 1</button></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>实验开始</strong><br>这个实验的主体是通过insert这个函数实现的 </p><p>它的传参有</p><p><code>uint64_t first_index</code> <code>string data</code> <code>bool is_last_substring</code> <code>Writer&amp; output</code></p><p>first_index是每一个data绝对位置，也就是类似于leetcode中合并区间的区间下标。data就是数据本身，可以调用.size来获取长度，is_last_substring就是问是否是最后一个数据段,output是一个输出接口，调用output.push（）就可以把完整的数据段输出。</p><p>实现过程：</p><p>先是看是否是最后一段数据，如果是就设置保存一下，后面可以用来作为结束的依据。</p><p>然后就是判断是否是过于新或者过于旧的片段我们就不要</p><div class="img-wrap"><div class="img-bg"><img class="img" src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/屏幕截图-2023-12-06-205242.png"/></div></div>如果是旧消息（原作者意思是设置左边界）或者新消息（原作者是设置右边界）我们就截取窗口位置<div class="img-wrap"><div class="img-bg"><img class="img" src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/屏幕截图-2023-12-06-205538.png"/></div></div>他在实现右边界是比较有意思的，由于之前排除掉就消息，只剩下刚刚好符合的消息，和新消息，通过min函数来判断是否符合容量去实现的。也就是新消息和刚好落在窗口内的消息一起判断了<div class="img-wrap"><div class="img-bg"><img class="img" src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/M0UPLX1HSOJSQ0N63JDY4.png"/></div></div>后面的思路也是让让拍案叫绝，是通过一个vector来维护一串数字，这些数字可以转换成char类型，把符合条件的消息全部转换成int放到vecotr中，然后通过一个随机固定的数字val填充为填充的，原作者用的值，咳咳(笑而不语)。然后如果需要的下标不是val的值（也就是恰好等于我们的需要的下标）则把其后面连续的都放到buffer中<div class="img-wrap"><div class="img-bg"><img class="img" src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/C79TGM1QIOJZ464BH.png"/></div></div>具体实现可以去看原作者是如何做的，接下来我讲另一种思路也就是我一开始想做的，也是绝大多数人的思路经历和上面一样的筛选步骤后存入后由于map会自动排序，会形成如下（实际上维护可能只有两到三个左右的消息段，这里为了演示画多一点）<div class="img-wrap"><div class="img-bg"><img class="img" src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/EHS39GNTQ6Y70ZQ188T1-202x300.png"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img" src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/0C6LZBWIM89AEUVMQXF.png"/></div></div>然后会通过辅助函数来将所有的片段拍在一起，其中涉及到左合并和右合并<div class="img-wrap"><div class="img-bg"><img class="img" src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/L70S1R0FXCDLJXAGOFB-e1702352108675.png"/></div></div></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><p>然后回放到map中（图中有可能结果有多个不相邻的判断，不一定是只有一个），下次放入判断前重新检查一下是否有新的片段成为了需要的下标，就推送到output里</p><p>由于笔者写的这部分代码确实不太好，所以如果想参考的话可以去我上面推荐的作者或者其他博客看看。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CS144 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS144-0</title>
      <link href="/posts/a40c130c.html"/>
      <url>/posts/a40c130c.html</url>
      
        <content type="html"><![CDATA[<h1 id="CS144-0"><a href="#CS144-0" class="headerlink" title="CS144-0"></a>CS144-0</h1><p>由于没有学校的邮箱，前面虚拟机交流也很简单，直接从代码发送阶段开始。<br><div class="tabs" id="test1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="test1-1">test1 1</button><button type="button" class="tab " data-href="test1-2">test1 2</button></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>1.编写报文</strong><br>实验步骤：</p><p>在你的虚拟机上，获取实验的源代码: <code>git clone https://github.com/cs144/minnow</code></p><p>进入 Lab 0 目录: <code>cd minnow</code></p><p>创建一个目录来编译实验室软件: <code>cmake -S . -B build</code></p><p>编译源代码: <code>cmake --build build</code></p><p>在构建目录外部，打开并开始编辑 <code>writeups/check 0. Md 文件。</code></p><p>在文件 <code>../apps/webget. cc</code> 中，找到并实现 get_URL 函数。你需要使用 HTTP 协议，使用 TCPSocket 和 Address 类。<br><span class='p red'>这里会出现的问题是克隆GitHub库的时候，由于网络问题克隆不了，建议多尝试，不推荐直接从GitHub库下载后导入虚拟机，因为后续需要同步新的实验，会由于git库的归属问题，导致无法同步。</span></p><p>做这一部分以前，要先有Http报文的前置知识，了解整个http的报文结构，才能完成这一部分的实验</p></div><div class="tab-item-content" id="test1-2"><p><strong>知识点</strong><br><a class="btn-anzhiyu " href="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/87812_FUF8PO1PX9DM3E-1024x639.png"   title=""><i class="anzhiyufont anzhiyu-icon-circle-arrow-right"></i></a><br><a class="btn-anzhiyu " href="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/MMWT9GZ0MBZEGUC073KU-1024x334.png"   title=""><i class="anzhiyufont anzhiyu-icon-circle-arrow-right"></i></a></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div></p><div class="tabs" id="test1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="test1-1">test1 1</button><button type="button" class="tab " data-href="test1-2">test1 2</button><button type="button" class="tab " data-href="test1-3">test1 3</button></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>1.1发送get报文</strong><br>在这个实验中，只需要发送最简单的GET报文请求即可，即写一段字符串，包含GET，HTTP类型，Host接口，以及最后的连接关闭。</p><p>这部分代码并不难，我会放在文章的末尾，在此之前如果你只是过来看思路，可以自己先思考一下，需要注意的是每一个元素之间需要有一个空格以及最后也需要一个换行，细节上需要去留意。</p><p>之后我们在控制台make我们的代码</p></div><div class="tab-item-content" id="test1-2"><p><strong>测试</strong><br>通过运行 <code>./apps/webget cs144.keithw.org /hello</code> 来测试程序。你可以实验不同的 http URL。比如说 <code>./apps/webget www.baidu.com /hello</code><br><a class="btn-anzhiyu " href="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/PQWU7GDORQ_039M@F1L-1024x450.png"   title=""><i class="anzhiyufont anzhiyu-icon-circle-arrow-right"></i></a></p></div><div class="tab-item-content" id="test1-3"><p><strong>自动化测试</strong><br>然后运行 <code>cmake --build build --target check_webget</code> 进行自动测试。<br><a class="btn-anzhiyu " href="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/NXXCAKXEKMW6DLM465-1024x428.png"   title=""><i class="anzhiyufont anzhiyu-icon-circle-arrow-right"></i></a></p><p>当看到两个测试用例通过，代表你可以继续下一步的实验了，打开 <code>src/byte stream.hh</code> 和 <code>src/byte stream.cc</code> 文件，实现给定接口的对象。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div class="tabs" id="test1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="test1-1">test1 1</button></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>2.实现字节系统</strong><br>我提供一些简单的接口描述</p><div class='checkbox'><input type="checkbox" />            <p>void push( std::string data ); // 将数据推入流中，但只推入可用容量的数据。</p>            </div><div class='checkbox'><input type="checkbox" />            <p>void close(); // 表示流已经结束，不会有更多数据写入。; // 将数据推入流中，但只推入可用容量的数据。</p>            </div><div class='checkbox'><input type="checkbox" />            <p>void set_error(); // 表示流出现错误。</p>            </div><div class='checkbox'><input type="checkbox" />            <p>bool is_closed() const; // 判断流是否已关闭。</p>            </div><div class='checkbox'><input type="checkbox" />            <p>uint64_t available_capacity() const; // 当前可以推入流的字节数。</p>            </div><div class='checkbox'><input type="checkbox" />            <p>uint64_t bytes_pushed() const; // 已推入流的总字节数。</p>            </div># 读取者接口：<div class='checkbox'><input type="checkbox" />            <p>void pop( uint64_t len ); // 从缓冲区移除 len 字节。</p>            </div><div class='checkbox'><input type="checkbox" />            <p>bool is_finished() const; // 判断流是否已完成（关闭并完全弹出）。</p>            </div><div class='checkbox'><input type="checkbox" />            <p>bool has_error() const; // 判断流是否发生过错误。</p>            </div><div class='checkbox'><input type="checkbox" />            <p>uint64_t bytes_buffered() const; // 当前缓冲的字节数量（推入但尚未弹出的）。</p>            </div><div class='checkbox'><input type="checkbox" />            <p>uint64_t bytes_popped() const; // 已从流中弹出的总字节数。</p>            </div><p>这一部分我总体的实现思路是，直接通过原生的string作为buffer，然后通过设置一些变量在头文件中记录状态，比如poped函数就可以直接返回这些状态。具体代码我会放在文末，或者您可以访问我的GitHub，来获得代码。</p><p>然后通过使用 <code>cmake --build build --target check0</code> 命令运行自动化测试。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div class="tabs" id="test1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="test1-1">test1 1</button><button type="button" class="tab " data-href="test1-2">test1 2</button><button type="button" class="tab " data-href="test1-3">test1 3</button></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>代码</strong></p><h3 id="webget-cc"><a href="#webget-cc" class="headerlink" title="webget.cc"></a>webget.cc</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;socket.hh&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;span&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;string&gt;MoreRequest;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_URL</span><span class="params">( <span class="type">const</span> string&amp; host, <span class="type">const</span> string&amp; path )</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">      <span class="function">Address <span class="title">addr</span><span class="params">(host,<span class="string">&quot;http&quot;</span>)</span></span>;</span><br><span class="line">      TCPSocket tcp_socket;<span class="comment">//建立套接字，用来连接（有了插坐）</span></span><br><span class="line"> <span class="keyword">try</span>&#123;</span><br><span class="line">        tcp_socket.<span class="built_in">connect</span>(addr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> ( <span class="type">const</span> exception&amp; e ) &#123;</span><br><span class="line">    cerr &lt;&lt; <span class="string">&quot;Unable to connect:&quot;</span>&lt;&lt;e.<span class="built_in">what</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">    string DefaultRequest=<span class="string">&quot;GET&quot;</span>;</span><br><span class="line">    string ConnectionHead = <span class="string">&quot;Close&quot;</span>;</span><br><span class="line">    string CacheControlHead=<span class="string">&quot;no-cache&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!MoreRequest.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">for</span>(string &amp;str:MoreRequest)&#123;</span><br><span class="line">        CacheControlHead+=(<span class="string">&quot;,&quot;</span>+str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">RequestHead</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    DefaultRequest+<span class="string">&quot; &quot;</span>+path+ <span class="string">&quot; HTTP/1.1\r\n&quot;</span> )</span></span>;</span><br><span class="line">    RequestHead+=<span class="string">&quot;Host: &quot;</span> + host+ <span class="string">&quot;\r\n&quot;</span>;</span><br><span class="line">    RequestHead+=<span class="string">&quot;Cache-Control: &quot;</span> + CacheControlHead + <span class="string">&quot;\r\n&quot;</span>;</span><br><span class="line">    RequestHead+=<span class="string">&quot;Connection: &quot;</span> + ConnectionHead + <span class="string">&quot;\r\n\r\n&quot;</span>;</span><br><span class="line">    tcp_socket.<span class="built_in">write</span>(RequestHead);</span><br><span class="line">    string outinfo;</span><br><span class="line">  tcp_socket.<span class="built_in">read</span>( outinfo );</span><br><span class="line">  <span class="keyword">while</span> ( !outinfo.<span class="built_in">empty</span>() ) &#123;</span><br><span class="line">    cout &lt;&lt; outinfo;</span><br><span class="line">    tcp_socket.<span class="built_in">read</span>( outinfo );</span><br><span class="line">  &#125;</span><br><span class="line">    tcp_socket.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">( <span class="type">int</span> argc, <span class="type">char</span>* argv[] )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ( argc &lt;= <span class="number">0</span> ) &#123;</span><br><span class="line">      <span class="built_in">abort</span>(); <span class="comment">// For sticklers: don&#x27;t try to access argv[0] if argc &lt;= 0.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> args = <span class="built_in">span</span>( argv, argc );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The program takes two command-line arguments: the hostname and &quot;path&quot; part of the URL.</span></span><br><span class="line">    <span class="comment">// Print the usage message unless there are these two arguments (plus the program name</span></span><br><span class="line">    <span class="comment">// itself, so arg count = 3 in total).</span></span><br><span class="line">    <span class="keyword">if</span> ( argc != <span class="number">3</span> ) &#123;</span><br><span class="line">      cerr &lt;&lt; <span class="string">&quot;Usage: &quot;</span> &lt;&lt; args.<span class="built_in">front</span>() &lt;&lt; <span class="string">&quot; HOST PATH\n&quot;</span>;</span><br><span class="line">      cerr &lt;&lt; <span class="string">&quot;\tExample: &quot;</span> &lt;&lt; args.<span class="built_in">front</span>() &lt;&lt; <span class="string">&quot; stanford.edu /class/cs144\n&quot;</span>;</span><br><span class="line">      <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get the command-line arguments.</span></span><br><span class="line">    <span class="type">const</span> string host &#123; args[<span class="number">1</span>] &#125;;</span><br><span class="line">    <span class="type">const</span> string path &#123; args[<span class="number">2</span>] &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call the student-written function.</span></span><br><span class="line">    <span class="built_in">get_URL</span>( host, path );</span><br><span class="line">  &#125; <span class="built_in">catch</span> ( <span class="type">const</span> exception&amp; e ) &#123;</span><br><span class="line">    cerr &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="test1-2"><h3 id="bytestream-cc"><a href="#bytestream-cc" class="headerlink" title="bytestream.cc"></a>bytestream.cc</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;byte_stream.hh&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">ByteStream::<span class="built_in">ByteStream</span>( <span class="type">uint64_t</span> capacity ) : <span class="built_in">capacity_</span>( capacity ) &#123;&#125;</span><br><span class="line"><span class="type">static</span>  <span class="type">size_t</span> SHUT_RDWR=<span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Writer::push</span><span class="params">( string data )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;ByteStreamState==SHUT_RDWR)&#123;</span><br><span class="line">  <span class="built_in">set_error</span>();</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">uint64_t</span> <span class="title">datasize</span><span class="params">(data.size())</span></span>;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;headroom_&lt;datasize)&#123;</span><br><span class="line">  <span class="built_in">set_error</span>();</span><br><span class="line">  datasize=<span class="keyword">this</span>-&gt;headroom_;</span><br><span class="line">  data.<span class="built_in">resize</span>(datasize);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>-&gt;buffer+=data;</span><br><span class="line">  <span class="keyword">this</span>-&gt;buffered+=datasize;</span><br><span class="line">  <span class="keyword">this</span>-&gt;pushed+=datasize;</span><br><span class="line">  <span class="keyword">this</span>-&gt;headroom_-=datasize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Writer::close</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;ByteStreamState==SHUT_RDWR)&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>-&gt;ByteStreamState=SHUT_RDWR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Writer::set_error</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// unsigned int WriteOFF_0</span></span><br><span class="line">  <span class="comment">// unsigned int Overflow_1</span></span><br><span class="line">  <span class="comment">// unsigned int ReadOFF_2</span></span><br><span class="line">  <span class="keyword">this</span>-&gt;errorsize++;</span><br><span class="line">  <span class="comment">// string WriteOFF=&quot;Unable to write because write has been turned off&quot;;</span></span><br><span class="line">  <span class="comment">// string Overflow=&quot;Data exceeds the maximum limit&quot;;</span></span><br><span class="line">  <span class="comment">// string ReadOFF=&quot;Unable to read because read has been turned off&quot;;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Writer::is_closed</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;ByteStreamState==SHUT_RDWR)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">Writer::available_capacity</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>-&gt;headroom_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">Writer::bytes_pushed</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>-&gt;pushed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string_view <span class="title">Reader::peek</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">string_view</span>(<span class="keyword">this</span>-&gt;buffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Reader::is_finished</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;ByteStreamState==SHUT_RDWR&amp;&amp;buffered==<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Reader::has_error</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;errorsize!=<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Reader::pop</span><span class="params">( <span class="type">uint64_t</span> len )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(len&lt;<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(len&gt;<span class="keyword">this</span>-&gt;buffered)</span><br><span class="line">  &#123;</span><br><span class="line">    len=<span class="keyword">this</span>-&gt;buffered;</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="keyword">this</span>-&gt;buffer.<span class="built_in">erase</span>(<span class="number">0</span>, len);</span><br><span class="line">   <span class="keyword">this</span>-&gt;buffered-=len;</span><br><span class="line">   <span class="keyword">this</span>-&gt;headroom_+=len;</span><br><span class="line">   <span class="keyword">this</span>-&gt;poped+=len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">Reader::bytes_buffered</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>-&gt;buffered;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">Reader::bytes_popped</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>-&gt;poped;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="test1-3"><h3 id="bytestream-hh"><a href="#bytestream-hh" class="headerlink" title="bytestream.hh"></a>bytestream.hh</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string_view&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Reader</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Writer</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ByteStream</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> errorsize=<span class="number">0</span>;</span><br><span class="line">  <span class="type">uint64_t</span> capacity_;</span><br><span class="line">  <span class="type">uint64_t</span> buffered=<span class="number">0</span>;</span><br><span class="line">  <span class="type">uint64_t</span> pushed=<span class="number">0</span>;</span><br><span class="line">  <span class="type">uint64_t</span> poped=<span class="number">0</span>;</span><br><span class="line">  <span class="type">uint64_t</span> headroom_=capacity_;</span><br><span class="line">  std::string buffer&#123;&#125;;</span><br><span class="line">  <span class="type">size_t</span> ByteStreamState=<span class="number">4</span>;</span><br><span class="line">  <span class="comment">// Please add any additional state to the ByteStream here, and not to the Writer and Reader interfaces.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">ByteStream</span><span class="params">( <span class="type">uint64_t</span> capacity )</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Helper functions (provided) to access the ByteStream&#x27;s Reader and Writer interfaces</span></span><br><span class="line">  <span class="function">Reader&amp; <span class="title">reader</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">const</span> Reader&amp; <span class="title">reader</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function">Writer&amp; <span class="title">writer</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">const</span> Writer&amp; <span class="title">writer</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Writer</span> : <span class="keyword">public</span> ByteStream</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">( std::string data )</span></span>; <span class="comment">// Push data to stream, but only as much as available capacity allows.</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span></span>;     <span class="comment">// Signal that the stream has reached its ending. Nothing more will be written.</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">set_error</span><span class="params">()</span></span>; <span class="comment">// Signal that the stream suffered an error.</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">is_closed</span><span class="params">()</span> <span class="type">const</span></span>;              <span class="comment">// Has the stream been closed?</span></span><br><span class="line">  <span class="function"><span class="type">uint64_t</span> <span class="title">available_capacity</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">// How many bytes can be pushed to the stream right now?</span></span><br><span class="line">  <span class="function"><span class="type">uint64_t</span> <span class="title">bytes_pushed</span><span class="params">()</span> <span class="type">const</span></span>;       <span class="comment">// Total number of bytes cumulatively pushed to the stream</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Reader</span> : <span class="keyword">public</span> ByteStream</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">std::string_view <span class="title">peek</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">// Peek at the next bytes in the buffer</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">( <span class="type">uint64_t</span> len )</span></span>;      <span class="comment">// Remove `len` bytes from the buffer</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">is_finished</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">// Is the stream finished (closed and fully popped)?</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">has_error</span><span class="params">()</span> <span class="type">const</span></span>;   <span class="comment">// Has the stream had an error?</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">uint64_t</span> <span class="title">bytes_buffered</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">// Number of bytes currently buffered (pushed and not popped)</span></span><br><span class="line">  <span class="function"><span class="type">uint64_t</span> <span class="title">bytes_popped</span><span class="params">()</span> <span class="type">const</span></span>;   <span class="comment">// Total number of bytes cumulatively popped from stream</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * read: A (provided) helper function thats peeks and pops up to `len` bytes</span></span><br><span class="line"><span class="comment"> * from a ByteStream Reader into a string;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">( Reader&amp; reader, <span class="type">uint64_t</span> len, std::string&amp; out )</span></span>;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CS144 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS144前言</title>
      <link href="/posts/db34f9f3.html"/>
      <url>/posts/db34f9f3.html</url>
      
        <content type="html"><![CDATA[<div class="tabs" id="test1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="test1-1">test1 1</button><button type="button" class="tab " data-href="test1-2">test1 2</button></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>CS144 - 前言</strong><br>在我开始深入CS144这门课程之前，我必须先声明一下 —— 我并非什么大佬。实际上，我在网络系统这方面的旅程才刚刚开始，有时候，我自己也还在为之前的认知感到惊讶。毕竟，将书本知识转化为可以在真实世界中运行的代码是一条充满挑战的路。我分享的内容，可能不见得是行业内的最优解，但至少代表了我的一点小小见解，希望能给你提供一些不同的思考角度。</p></div><div class="tab-item-content" id="test1-2"><p><strong>小声逼逼</strong></p><div class="img-wrap"><div class="img-bg"><img class="img" src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/d9f7af772a7bd52f9f904d06899f5d151788e195.jpg@1256w_1256h_!web-article-pic.avif" alt="说白了，别嫌我太菜。"/></div><span class="image-caption">说白了，别嫌我太菜。</span></div></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div class="tabs" id="test1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="test1-1">test1 1</button></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>原地址</strong><br>好，正题来了，这是CS144课程的官方链接<a class="btn-anzhiyu " href="https://cs144.github.io/"   title="CS144"><span>CS144</span></a> 强烈推荐给像我一样对网络系统感兴趣的朋友们。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div class="tabs" id="test1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="test1-1">test1 1</button></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>心路历程(废话 busi)</strong><br>开始实操这门课的项目时，我真的遇到了不少的阻力。以前我更多的是书面上的学习，对概念和理论比较了解，但在动手实现它们的时候，突然间好像有一面墙立在了我的面前，让我手足无措，反反复复在文档与之前学过的知识对照，又双叒叕地与bug和失败结果打交道。程序员嘛，谁没有过在编译器前哭泣的时候呢？</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div class="tabs" id="test1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="test1-1">test1 1</button><button type="button" class="tab " data-href="test1-2">test1 2</button></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>有所所获</strong><br>这个过程中，我学到了很多东西——不仅仅是知识上的收获，更多的是在面对问题和困难时，如何保持冷静，如何一步步地解决问题。我不得不说，这些经验是十分宝贵的，它们磨练了我的耐心和毅力，也让我对计算机网络的理解更加深刻。</p></div><div class="tab-item-content" id="test1-2"><p><strong>持续进步</strong><br>在不断的尝试和失败中，我领悟到了计算机网络的复杂性，也见证了代码的力量。每一次debug，每一次代码的修改，都让我对初看起来高不可攀的网络协议有了一点点新的理解。通过实际编写和实现代码，我开始真正感受到了协议之间的美妙互动和逻辑上的严谨性。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div class="tabs" id="test1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="test1-1">test1 1</button></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>讲给你们</strong><br>我希望可以把这份乐趣和收获分享给每一个读到这篇博客的你。不管你现在是一个处于编程起步阶段的新手，还是一直在寻找新知和挑战的资深开发者，我都相信CS144能给你带来一些新的启发。别忘了，最好的学习方式，往往是直接跳进来，动手去做，去体验，像游泳一样，旱地学泳是不可以的，拘泥于书本也是不可以的。</p><p>所以，让我们一起继续这趟探索之旅吧。接下来的篇章，我会深入分享我在实现CS144项目中的具体经历和收获。希望我的旅程可以给你带来一些帮助，也期待听到你的故事和成长。别怕起步难，我们都在这条路上！</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><p>以下是中文文档，你可以通过中英来更好的理解文档。</p><a class="btn-anzhiyu " href="https://huanxue.love/230-2/"   title="旧站文档"><i class="anzhiyufont anzhiyu-icon-circle-arrow-right"></i><span>旧站文档</span></a>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CS144 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Greetings, Universe!</title>
      <link href="/posts/534e3aec.html"/>
      <url>/posts/534e3aec.html</url>
      
        <content type="html"><![CDATA[<h1 id="该网站的诞生"><a href="#该网站的诞生" class="headerlink" title="该网站的诞生"></a>该网站的诞生</h1><p>从前，在Echo的小窝里，有一群聪明的猫猫虫<br><div class="img-wrap"><div class="img-bg"><img class="img" src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/4353.gif" style="width:400px;"/></div></div><br>猫猫虫们聪明又可爱，他们相亲相爱<br><div class="img-wrap"><div class="img-bg"><img class="img" src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/2579762.gif" style="width:400px;"/></div></div><br>，互相交流建站的经验，和生活琐事。<br><div class="img-wrap"><div class="img-bg"><img class="img" src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/50.gif" style="width:400px;"/></div></div><br>有一天，有一只猫猫发现了不得了的事情<br><div class="img-wrap"><div class="img-bg"><img class="img" src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/30.gif" style="width:400px;"/></div></div><br>人家隔壁的石头搭建的窝也太好看了吧<br><div class="img-wrap"><div class="img-bg"><img class="img" src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/20211115204431_27525.jpeg" style="width:400px;"/></div></div><br>猫猫们也想要那样的一个窝，但是目前的窝又是猫猫们舍不得的，这可把猫猫们急的呀团团转<div class="img-wrap"><div class="img-bg"><img class="img" src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/80.gif" style="width:400px;"/></div></div><br>怎么办？<br><div class="img-wrap"><div class="img-bg"><img class="img" src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/254623.jpg" style="width:400px;"/></div></div><br>怎么办？<br><div class="img-wrap"><div class="img-bg"><img class="img" src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/3454s6443.jpg" style="width:400px;"/></div></div><br>突然聪明的猫猫们想出了一个办法<br>小孩子才做选择，猫猫们全都要<br>于是本站诞生啦！<br><div class="img-wrap"><div class="img-bg"><img class="img" src="https://testingcf.jsdelivr.net/gh/huanxueshengmou/picture-host/5435354.gif" style="width:400px;"/></div></div></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
